<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lgz_blog</title>
  
  <subtitle>Hey!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T11:17:35.791Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lgz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/02/28/hello-world/"/>
    <id>http://example.com/2021/02/28/hello-world/</id>
    <published>2021-02-28T11:17:35.791Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统相关概念</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统（operating-System，-OS）"><a href="#1-操作系统（operating-System，-OS）" class="headerlink" title="1 操作系统（operating System， OS）"></a>1 操作系统（operating System， OS）</h1><p>操作系统是计算机系统中最基本的系统软件</p><h2 id="1-1-操作系统作用"><a href="#1-1-操作系统作用" class="headerlink" title="1.1 操作系统作用"></a>1.1 操作系统作用</h2><ol><li>管理分配资源，组织调度计算机的工作<ul><li>处理机管理（进程管理）</li><li>存储器管理（内存）</li><li>文件管理（文件系统）</li><li>设备管理（I/O）</li></ul></li><li>为用户和其他软件提供接口和环境。<ul><li>命令接口：用户利用这些命令来组织和控制作业的运行<ul><li>交互式命令接口（联机）</li><li>批处理命令接口（脱机）</li></ul></li><li>程序接口：系统调用，请求操作系统服务。<h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2 操作系统特征"></a>1.2 操作系统特征</h2></li></ul></li><li>并发：两个或多个事件在同一时间间隔内发生。通过分时实现。</li><li>共享：指系统中的资源可供内存中多个并发的进程共同使用。<ul><li>互斥共享方式</li><li>同时访问方式</li></ul></li><li>虚拟： 把一个物理上的实体变为若干个逻辑上的对应物。</li><li>异步：并发执行时，由于资源有限，进程的执行不是一贯到底而是走走停停，以不可预知的速度向前推进。<h2 id="1-3-操作系统的运行机制"><a href="#1-3-操作系统的运行机制" class="headerlink" title="1.3 操作系统的运行机制"></a>1.3 操作系统的运行机制</h2></li><li>内核态：操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。内核态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令,包括：<ul><li>时钟管理：计时中断实现进程切换</li><li>中断机制</li><li>原语：<ul><li>处于操作系统的最底层，是最接近硬件的部分</li><li>操作不可中断（关闭中断，让其所有动作执行完在打开中断）</li><li>运行时间较短且调用频繁。</li></ul></li><li>系统控制的数据结构及处理：<ul><li>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理： 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理：缓冲区管理、设备分配和回收等<blockquote><p>系统调用运行在系统的内核态，为了获取操作系统的服务，用户程序必须使用系统调用，系统调用会转换为内核态并且调用操作系统。</p></blockquote></li></ul></li></ul></li><li>用户态：只使用了机器指令中的一个子集，将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</li><li>中断：<ul><li>中断，外中断，来自CPU执行指令以外的事件的发生。（外设请求、人为干预）</li><li>异常，内中断，源自CPU执行指令内部的事件。（指令中断、硬件故障、软件中断）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统（operating-System，-OS）&quot;&gt;&lt;a href=&quot;#1-操作系统（operating-System，-OS）&quot; class=&quot;headerlink&quot; title=&quot;1 操作系统（operating System， OS）&quot;&gt;&lt;/a&gt;1 </summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>运输层协议</title>
    <link href="http://example.com/2021/02/27/%E8%BF%90%E8%BE%93%E5%B1%82TCP/"/>
    <id>http://example.com/2021/02/27/%E8%BF%90%E8%BE%93%E5%B1%82TCP/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h1><ul><li>网络层提供了<strong>主机</strong>之间的逻辑通信，运输层协议为不同主机上的<strong>应用进程</strong>之间提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直相连一样。</li><li>运输层协议实在端系统而不是路由器中实现的。在发送端，运输层将从发送应用程序进程接受到的报文转换成运输层分组，称为报文段（segment）</li><li>UDP（User Datagram Protocol，用户数据报协议）为调用他的应用程序提供了一种不可靠、无连接的服务。</li><li>TCP（Transmission Control Protocol， 传输控制协议） 为调用它的应用程序提供了一种可靠的、面向连接的服务。</li><li>将主机间交付拓展到进程间交付被称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）</li><li>UDP流量是不可调节的，使用UDP的应用程序可以根据需要以其愿意的任何速率发送数据。</li><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接受进程。</li><li>TCP还提供拥塞控制（congestion control）。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务。TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</li></ul><h1 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2 多路复用和多路分解"></a>2 多路复用和多路分解</h1><p>一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据地门户。在接受主机地运输层实际上并没有将数据直接交付给进程，而是将数据交给一个中间地套接字。每个套接字都有一个标识符，标识符的格式取决于他是UDP还是TCP套接字。</p><p>将运输层报文段中地数据交付到正确地套接字（通过端口号）的工作称为多路分解（demultiplexing）<br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层称为多路复用。</p><h1 id="3-UDP、无连接运输"><a href="#3-UDP、无连接运输" class="headerlink" title="3 UDP、无连接运输"></a>3 UDP、无连接运输</h1><ol><li>应用场景</li></ol><ul><li>包总量较少的通信（DNS，SNMP等）</li><li>视频、音频等多媒体通信（及时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信</li></ul><ol start="2"><li>UDP特点</li></ol><ul><li>UDP只做传输协议能做的最少工作，只在IP数据服务上增加了两个最基本的服务：复用和分用 以及差错检测</li><li>UDP没有拥塞控制，采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层；TCP有拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制TCP发送方。TCP仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要多长时间。而实时应用通常要求及时性，能够容忍一些数据丢失。</li><li>无需建立连接：TCP开始数据传输之前需要三次握手。UDP不需要任何准备即可进行数据传输。</li><li>无状态连接：TCP需要在端系统中维护连接状态。包括接受和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不维护连接状态，也不跟踪这些参数。</li><li>分组首部开销小 ：TCP40字节，UDP8字节。UDP首部只有8个字节，分为四个字段：源端口、目的端口、UDP长度、UDP校验和<ul><li>端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。</li><li>长度为UDP报文段中的字节数(首部+数据)</li><li>检验和：检验和提供了差错检测功能。因为不能保证源和目的之间的所有链路都提供差错检测。虽然提供差错检测，但他对差错恢复无能为力。</li></ul></li></ul><ol start="3"><li>TCP和UDP的区别<br><br>主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小来讲</li></ol><ul><li>TCP面向连接，UDP无连接。TCP3次握手建立连接，UDP发送前不需要建立连接</li><li>TCP可靠，UDP不可靠，TCP丢包有确认重传机制，UDP不会</li><li>TCP有序，会对报文进行重排；而UDP无序，后发送信息可能先到达</li><li>TCP必须进行数据验校，UDP的校验可选</li><li>TCP有流量控制（滑动窗口）和拥塞控制，UDP没有</li><li>TCP传输慢，UDP传输快，因为TCP要建立连接、保证可靠有序，还有流量、拥塞控制</li><li>TCP包头较大（20字节）UDP较小（8字节）<h1 id="4-TCP"><a href="#4-TCP" class="headerlink" title="4 TCP"></a>4 TCP</h1><h2 id="4-1-TCP报文结构"><a href="#4-1-TCP报文结构" class="headerlink" title="4.1 TCP报文结构"></a>4.1 TCP报文结构</h2>TCP提供全双工服务<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/DF87911636F94317A7FDB929EA21815A/13972" alt="TCP报文结构"></li></ul><ol><li>源端口和目的端口：唯一确定一条TCP连接，TCP在发送数据前必须在彼此间建立连接，意思是：双方需要保存对方的信息。</li><li>序列号seq：占4个字节，用于标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号，确保TCP传输有序。</li><li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li><li>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。用于确认不丢包。</li><li>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li><li>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li><li>其他标志位的含义：<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/C232A5EDEF7348EBACB6E426C08571E6/13974" alt="其他标志位含义"></li><li>数据偏移(首部长度)：4比特。指示以32比特的字为单位的TCP首部长度，因为有选项字段，作为一个4比特的字节，TCP被限制为只能带60字节的头部。</li><li>接受窗口。16比特。用于流量控制，限制窗口大小到65535字节。</li><li>选项。可选与变长。在发送方与接收方协商最大报文段长度（MSS）时使用，或者在高速网络环境下用作窗口调节因子时使用、时间戳、ASCK（选择确认)。</li></ol><h2 id="4-2-三次握手"><a href="#4-2-三次握手" class="headerlink" title="4.2 三次握手"></a>4.2 三次握手</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/F59FF5FC9B48486092B2D9E035539503/13976"></p><ol><li>第一次握手：客户端发送初始序号seq = x和SYN=1的请求标志。此时服务器得知客户端发送正常，自己接收正常。</li><li>第二次握手：服务器发送请求标志SYN=1,确认标志ACK=1，自己的序号seq=y，发送客户端的确认信号x+1。客户端知道自己发送、接收正常，服务器接收、发送正常。</li><li>第三次握手：客户端发送确认信号ACK=1，发送自己的序号seq=x+1，发送对方的确认号ACK=y+1。服务器知道客户端发送、接收正常，自己接收、发送也正常。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/CACA11D7C63E4F118D6CFC5A862D6334/13978"></p><ol><li>第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态，是客户端的请求断开。</li><li>第二次挥手：服务器收到客户端的请求后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态，服务器确认客户端的断开请求。</li><li>第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态），服务器请求断开。</li><li>第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态，客户端确认服务器断开。<h2 id="4-3-常见问题"><a href="#4-3-常见问题" class="headerlink" title="4.3 常见问题"></a>4.3 常见问题</h2></li><li>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</li></ol><ul><li>连接时，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，对应用于同步+应答。</li><li>连接关闭时，当服务端收到FIN报文时，也许还有话要说，并不会立即关闭SOCKET，所以不会立即返回一个FIN，而是先回复一个ACK报文，告诉客户端自己已经收到了FIN，而只有等服务端把要说的话说完，才能发送FIN，因此需要四步。</li></ul><ol start="2"><li>为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</li></ol><ul><li>我们需要假想网络传输是不可靠的，有可能最后一个ACK将会丢失，TIME_WAIT状态可以用来重发可能丢失的ACK报文。在客户端发出最后的ACK回复时，如果服务端没有收到ACK，它将不断重复发送FIN片段，所以客户端不能立即关闭，它必须确认服务端收到了该ACK。</li><li>客户端会在发出ACK之后进入TIME_WAIT的状态，并等待两倍的MSL的时间，Maximum Segment Lifetime，片段在网络中的最大生存时间，两倍的MSL就是一个发送和一个回复所需要的最大时间，如果超出该时间，客户端还没有再次收到FIN，那么客户端就会推断ACK已经被成功接收，此时TCP连接结束。</li></ul><ol start="3"><li>为什么不能用两次握手进行连接？</li></ol><ul><li>三次握手完成了两个重要的功能：<ul><li>双方做好发送数据的准备工作。</li><li>允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</li></ul></li><li>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</li></ul><ol start="4"><li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li></ol><ul><li>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<h2 id="4-4-注意事项"><a href="#4-4-注意事项" class="headerlink" title="4.4 注意事项"></a>4.4 注意事项</h2></li></ul><ol><li>当主机接收到TCP报文段与进行中的进程都不匹配的情况时，发送重置报文段。当主机发送一个重置报文段时，他告诉该源“我没有那个报文段的套接字，请不要发送该报文段了”。当UDP套接字不匹配时，主机发送特殊的ICMP数据报。</li><li>TCP的半打开状态<ul><li>如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双方就无法获悉异常</li><li>半打开的一个常见原因是一方程序的非正常结束（断电、断网）如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了。而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST)处理</li></ul></li><li>同时打开与同时关闭<ul><li>两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2发送SYN同步信息的同时，B:port2也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。</li><li>而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段</li></ul></li><li>重置报文段 RST字段<ul><li>针对不存在端口的连接请求</li><li>终止一条连接：重置报文段会被立即发送，任何排队的数据都将被抛弃；接收方会说明通信另一端采用了终止的方式而不是一次正常关闭。</li><li>半开连接：服务器主机被切断连接重启后，留给客户端一个半开的连接。当再次从这条连接上接收到数据时，服务器对其一无所知，并回复一个重置报文段关闭连接。</li><li>一个重置报文段能破坏TIME_WAIT状态并强制连接关闭。</li></ul></li><li>TCP保活机制<br><br>若某个连接长时间处于空闲状态，在该连接地一端会发送一个探测数据包（可以不含任何数据，但一般会包含垃圾字节）从而实现保活功能。<ul><li>对方主机正在工作且可以到达。正常响应，保活计时器重置</li><li>对方主机崩溃。没有响应，请求段会保活时间间隔指定地时间后超时断开连接。</li><li>对方主机崩溃已重启。重置报文段，断开连接</li><li>对方主机正在工作但无法到达。同2</li></ul></li><li>TCP 连接的本质是什么，真的是“链接”吗<br><br>状态和序列号，以及错误校验（可以查看TCP和UDP的请求头，就会发现两者之间的差距了），其实所谓的TCP三次握手请求连接，无非就是初始化一个序列号，保证后面的数据有序到达，同时TCP还支持重传，错误校验，保证数据的可靠性，当然UDP也提供校验。<ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul></li><li>大量的Time-wait怎么办<ul><li>Time-wait 状态不能消除，只能快速的回收或重用</li><li>reuse 处于Time-wait状态可以被后续连接重用</li><li>recycle 开启服务器对于time-wait的快速回收</li><li>time-out 修改系统默认的TIMEOUT时间<h2 id="4-5-TCP超时重传"><a href="#4-5-TCP超时重传" class="headerlink" title="4.5 TCP超时重传"></a>4.5 TCP超时重传</h2>异常网络，会出现如下网络状况</li></ul></li><li>数据顺利到对端，对端顺利响应ACK</li><li>数据包中途丢失</li><li>数据包顺利达到，但是ACK报文丢失</li><li>数据报数据达到，但是对异常未响应</li></ol><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/DA957EFC9E6F4DACAE0E8F0698937C1E/14096" alt="超时重传"></p><p>出现异常情况时，TCP就会超时重传。TCP每发送一个报文段，就对这个报文段，就对这个报文段设一个计时器，如果确认的时间到了而没有收到确认，就会重传报文段。这就是超时重传。</p><p>客户端一直没有得到ACK报文，客户端会一直重传，影响重传效率的是RTO（Retransmission Timeout）。RTO指发送数据后，传送数据等待ACK的时间。RTO(重传超时时间)非常重要。</p><ol><li>设长了，重发慢，没有效率</li><li>设短了，重发快，网络拥塞。</li></ol><p>如果底层传输特性已知，则重传相对简单，但是TCP体层完全异构，所以必须适应适应时延差异。</p><p>经典的自适应算法：</p><p><code>$SRTT = \alpha * SRTT + (1 - \alpha) * RTT$</code></p><p><code>$RTO = min(UBOUND, max(LBOUND, \beta * SRTT)$</code></p><p>UBOUND是最大的timeout时间，上限值，LBOUND是最小的timeout<br>时间，下限值。但这样会因为ACK传输导致RTT多义性问题。</p><p>carn算法，忽略重传，不采样重传的RTT，一旦发生重传，就对现有的RTO翻倍。<br>当不发生重传时，才根据上式计算平均往返时间RTT和重传时间。</p><p>处理差错的两种主要方法是差错校正码和数据重传。</p><p>当RTT测量值小于连接地实际值，就可能发生伪重传。在这种情况下，若TCP地等待时间稍长，不必要地重传就可能不发生。</p><h2 id="4-6-TCP滑动窗口"><a href="#4-6-TCP滑动窗口" class="headerlink" title="4.6 TCP滑动窗口"></a>4.6 TCP滑动窗口</h2><p>TCP的滑动窗口主要有两个作用：一是提供TCP的可靠性；二是提供TCP的流控特性。同时滑动 窗口机制还体现了TCP面向字节流的设计思路。解决乱序和流量控制。</p><blockquote><p>发送端叫拥塞窗口，为了解决拥堵，接收端是滑动窗口，为了解决流量控制。发送量取二者最小值。</p></blockquote><p>对于TCP会话的的发送方，任何时候器缓存数据可以分为四类:</p><ol><li>已经发送并受到对方的ACK</li><li>已经发送但未收到ACK</li><li>未发送但对方允许发送</li><li>对方不允许发送</li></ol><p>其中， 已经发送还未收到ACK和未发生但是对方允许发送的部分称为发送窗口<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/3D6CFB3A7E6E4B4B8C14674EC3FBEEFE/14115"><br>当接收到ACK后续的确认字节时，窗口便会滑动<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/489CF3079D0B43B185721DA291A2F29E/14117"><br>对于TCP会话的接收方，缓存数据可以分为三类</p><ol><li>已接收</li><li>未接受准备接收</li><li>未准备接收</li></ol><p>其中未接受准备接收称为接收窗口。</p><p>TCP是双工的协议，会话的双方可以同时接收、发送数据。TCP会话双方都各自维护一个发送窗口和接收窗口。滑动窗口实现面向流的可靠性来源于“确认重传机制”，TCP滑动窗口的可靠性也来源与确认重传。发送窗口只有受到对方对于本段ACK的确认，才会移动左边界。前面还有字节未接收的情况下，窗口不会移动。</p><p>滑动窗口功能的建立与序列号(seq)和确认号(ack)有关<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/14431655D304484BBE6BFCCA8C002539/14203"></p><h3 id="4-6-1-延时确认"><a href="#4-6-1-延时确认" class="headerlink" title="4.6.1 延时确认"></a>4.6.1 延时确认</h3><p>在许多情况下，TCP并不对每个到来的数据包都反回ACK，利用TCP的累积ACK字段就能实现该功能。累积确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传的数据结合发送。这种捎带传输的方法经常用于批量数据传输。</p><h3 id="4-6-2-Nagle算法"><a href="#4-6-2-Nagle算法" class="headerlink" title="4.6.2 Nagle算法"></a>4.6.2 Nagle算法</h3><p>当一个TCP连接中有在传数据（已发送还未经确认的数据）时，小的报文段（长度小于SMSS（发送发最大报文段））就不能被发送，直到所有的在传数据都收到ACK。在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。</p><h3 id="4-6-3-零窗口与TCP持续计时器"><a href="#4-6-3-零窗口与TCP持续计时器" class="headerlink" title="4.6.3 零窗口与TCP持续计时器"></a>4.6.3 零窗口与TCP持续计时器</h3><p>TCP通过接受端的通告窗口来实现流量控制。通告窗口指示了接受端可接受的数据量。当窗口值变为0时，可以阻止发送端继续发送，直到窗口大小恢复非零值。</p><p>当接收端重新获得可用空间时，会给发送端传输一个窗口更新，告知其可以继续发送数据。这样的窗口更新不包含数据，且没有可靠性，如果丢失，双方就一直处于等待状态。</p><p>为防止这种死锁发生，发送方会采用一个持续计时器间歇性地查询接收端，看其窗口是否增长。持续计时器会触发窗口探测地传输，强制要求接受端返回ACK（包含窗口大小）。</p><h3 id="4-6-4-糊涂窗口综合征"><a href="#4-6-4-糊涂窗口综合征" class="headerlink" title="4.6.4 糊涂窗口综合征"></a>4.6.4 糊涂窗口综合征</h3><p>通告窗口较小时，发送端会立即发送数据填满该窗口，这样在连接中就会出现大量高耗费地小数据包。对发送端来说，通告窗口较小应该避免发送小数据包；接受端应该尽量避免通告小窗口。</p><h2 id="4-7-TCP拥塞控制"><a href="#4-7-TCP拥塞控制" class="headerlink" title="4.7 TCP拥塞控制"></a>4.7 TCP拥塞控制</h2><p>计算机网络中的带宽、交换节点中的缓存和处理机等都是网络的资源。某段时间，网络需求超过了可用部分，网络性能就会变坏，这被称为拥塞。拥塞控制就是防止过多的网络流量注入到网络中。TCP拥塞控制由四个核心算法组成：满开始、拥塞避免、快速重传和快速恢复。</p><h3 id="4-7-1-慢开始和拥塞避免"><a href="#4-7-1-慢开始和拥塞避免" class="headerlink" title="4.7.1 慢开始和拥塞避免"></a>4.7.1 慢开始和拥塞避免</h3><p>发送发维持一个拥塞窗口的状态变量，拥塞窗口取决于网络的拥塞程度。发送方让自己的发送窗口等于拥塞窗口。考虑到接收方的接受能力，发送窗口可能小于拥塞窗口.</p><p>慢开始的思路就是一开始不发送大量的数据，先探测网络的拥塞程度。由小到大增加拥塞窗口。</p><ol><li>当主机发送数据时，如果将较大的发送窗口全部注入到网络中，可能引起拥塞</li><li>可以试探一下，由小到大增大拥塞窗口的数量</li><li>慢开始从1个MSS开始指数增长，为了防止其增长过大，设置一个门限ssthresh，当其达到门限时，变为拥塞避免算法。</li></ol><p>拥塞避免算法是使拥塞窗口缓慢增长，每经过一个RTT就将拥塞窗口加一。</p><ol><li>TCP连接初始化，拥塞窗口为1</li><li>执行慢开始算法，cwind指数增长，指导cwind=ssthresh时，开始拥塞避免算法.</li><li>当网络拥塞时（超时的丢包事件）将ssthresh设为当前的一半，cwind设为1重新开始。<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/4F66217AA2F845A78641437C306527C2/14119"><br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/EDC9663545AF4AD6A45CB43613576031/14121"></li></ol><h3 id="4-7-2-快重传和快恢复"><a href="#4-7-2-快重传和快恢复" class="headerlink" title="4.7.2 快重传和快恢复"></a>4.7.2 快重传和快恢复</h3><p>快重传要求接收方受到一个失序的报文段后立即发送重复确认（为使发送方尽早知道报文段为传到对方）。快重传规定只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必继续等待。</p><p>快重传还配合有快恢复，主要思想包括：</p><ol><li>一旦受到三个重复确认，执行乘法减小，ssthresh门限减半，但是并不执行慢开始</li><li>将cwind（拥塞窗口）设为ssthresh，执行拥塞避免算法。</li></ol><p>整体上，TCP拥塞窗口的原则时加法增大、乘法减小。可以看出TCP较好的保证了流之间的公平性，一旦丢包就减半退让。</p><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/2C6EDD14FA124DAB8595CC1BD14B186D/14123"><br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/8BFF5B63C99D44619D066B60F7409CBE/14125"></p><p>ACK号与接收端缓存中的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为失序数据，因为这些数据和之前接收的序列号不连续。合理采用SACK信息能更快地实现空缺填补，且能减少不必要地重传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-相关概念&quot;&gt;&lt;a href=&quot;#1-相关概念&quot; class=&quot;headerlink&quot; title=&quot;1 相关概念&quot;&gt;&lt;/a&gt;1 相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;网络层提供了&lt;strong&gt;主机&lt;/strong&gt;之间的逻辑通信，运输层协议为不同主机上的&lt;st</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://example.com/2021/02/27/RabbitMQ/"/>
    <id>http://example.com/2021/02/27/RabbitMQ/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MQ的三个作用"><a href="#1-MQ的三个作用" class="headerlink" title="1 MQ的三个作用"></a>1 MQ的三个作用</h1><ol><li>异步</li><li>解耦，消息统一分发</li><li>流量削峰</li></ol><h1 id="2-AMQP事物机制控制"><a href="#2-AMQP事物机制控制" class="headerlink" title="2 AMQP事物机制控制"></a>2 AMQP事物机制控制</h1><ol><li>txSelect, txCommit, txRollback</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MQ的三个作用&quot;&gt;&lt;a href=&quot;#1-MQ的三个作用&quot; class=&quot;headerlink&quot; title=&quot;1 MQ的三个作用&quot;&gt;&lt;/a&gt;1 MQ的三个作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;解耦，消息统一分发&lt;/li&gt;
&lt;li&gt;流量削峰&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="http://example.com/2021/02/27/dubbo/"/>
    <id>http://example.com/2021/02/27/dubbo/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo是一款高性能的Java RPC框架</p><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=72">ZooKeeper+Dubbo分布式架构基础教程</a></p><ol><li>面向接口的的远程方法调用，智能容错和负载均衡，服务自动注册和发现<h1 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1 RPC"></a>1 RPC</h1></li></ol><ul><li>A服务器的方法调用B服务器的方法，不在同一个内存空间。<ol><li>客户端调用</li><li>序列化</li><li>发送消息</li><li>发序列化</li><li>调用本地服务</li><li>服务处理</li><li>返回结果</li><li>将结果序列化</li><li>返回消息</li><li>反序列化</li><li>返回调用结果<h1 id="2-RMI"><a href="#2-RMI" class="headerlink" title="2 RMI"></a>2 RMI</h1></li></ol></li><li>java原生支持的远程调用，采用JRMP作为通信协议</li><li>client、server、registy注册中心</li></ul><ol><li>大致原理：服务端在注册中心注册服务，客户端从注册中心获取服务具体信息，客户端调用服务端执行服务。</li><li>步骤<ol><li>创建远程接口，继承Remote</li><li>实现远程接口，并且继承UnicastRemoteObject</li><li>启动RMI注册服务，指定端口号</li><li>创建要被访问的远程对象的实例</li><li>把远程对象实例注册到RMI注册服务器上</li></ol></li></ol><h1 id="3-dubbo高可用"><a href="#3-dubbo高可用" class="headerlink" title="3 dubbo高可用"></a>3 dubbo高可用</h1><ol><li>服务路由（包含一条路由规则）<ul><li>dubbo提供了三种服务路由实现（条件路由ConditionRouter、脚本路由ScriptRouter、标签路由TagRouter）</li></ul></li><li>条件路由规则的格式：<ul><li>服务消费者匹配条件 =&gt; 服务提供者匹配条件</li><li>host = 10.20.153.10 =&gt; host = 10.20.153.11</li><li>该条规则表示IP为10.20.153.10的服务消费者止咳调用IP为10.20.153.11机器上的服务，不可调用其他机器上的服务。</li><li>如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。</li><li>包括黑名单、白名单、读写分离、前后天分离</li></ul></li><li>集群容错<ul><li>FailoverCluster,某个服务器产生异常，重试其他服务器，可以设置重试次数。</li><li>Failfast Cluter快速失败，只调用一次，立即报错。通常用于非幂等性的写操作</li></ul></li><li>负载均衡（面试题）<ul><li>随机权重分配，无状态</li><li>轮训服务器，有状态</li><li>活跃计数器随机</li><li>一致性哈希，为IP分配固定的服务器</li></ul></li><li>dubbo降级服务<ul><li>服务降级就是指在由于非主业务异常导致的服务不可用时（服务器宕机/网络超时/并发数太高等），可以返回默认值，避免异常影响主业务的处理</li></ul></li></ol><blockquote><p>zookeeper 和 redis 用于消息中心的很重要的原因是知道断开</p></blockquote><p>Dubbo SPI流程：名字–&gt;文件–&gt;实现类–&gt;对象–&gt;依赖注入–&gt;AOP–&gt;完整的一个对象</p><blockquote><p>Dubbo的依赖注入与spring的区别，注入的是一个属性的代理对象，根据实际要用时传入的url中的实际对象赋真正的值，也就是set的时候并没有确定最终的对象。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dubbo是一款高性能的Java RPC框架&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BA411q7ia?p=72&quot;&gt;ZooKeeper+Dubbo分布式架构基础教程&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向接口的的</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://example.com/2021/02/27/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2021/02/27/%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-程序与进程"><a href="#1-程序与进程" class="headerlink" title="1 程序与进程"></a>1 程序与进程</h1><p>进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数据）的真正运行实例。</p><p>进程结构一般由3部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享同一个代码段。数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数的参数，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括了进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及数据在处理机执行时所发生的活动</li><li>进程时系统进行资源分配和调度的独立单位。进程的独立运行由进程控制块PCB控制和管理。进程映像时静态的进程。程序段、相关数据、PCB三部分构成了进程映像。PCB进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。</li></ul><h1 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2 进程状态"></a>2 进程状态</h1><ol><li>运行状态：进程在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态</li><li>就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行</li><li>阻塞状态：又称等待状态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入输出的完成。即使处理机空闲，该进程也不能运行。</li><li>创建状态：进程正在被创建。</li><li>结束状态：进程正从系统中消失。</li></ol><h1 id="3-linux系统进程启动过程"><a href="#3-linux系统进程启动过程" class="headerlink" title="3 linux系统进程启动过程"></a>3 linux系统进程启动过程</h1><p>0号进程–&gt;1号内核进程-&gt;1号内核线程–&gt;1号用户进程–&gt;getty进程–&gt;shell进程</p><p>整个linux系统的所有进程也是一个树结构。树根时系统自动构造的，即在内核态下执行的0号进程，它是所有进程的祖先。由0号进程创建1号进程（内核态），1号负责执行内核的部分初始化工作及进行系统配置，并创建若干个用于告诉缓存和虚拟储存管理的内核线程。</p><p>随后1号进程调用execve（）运行可执行程序init，并演变成用户态1号进程，他按照系统配置文件/etc/initab的要求，完成系统的启动工作，创建编号为1号、2号等若干终端注册进程getty。当getty检测到来自终端的信号时， getty将通过 execve执行注册程序 login， 此时就可以通过用户名、密码登录。如果登录成功，login() 程序执行shell， shell进程接替 getty 进程的pid 取代getty进程。后续进程再通过shell产生。</p><h1 id="4-进程的创建"><a href="#4-进程的创建" class="headerlink" title="4 进程的创建"></a>4 进程的创建</h1><p>创建状态：进程正在创建尚未就绪，经过几个创建步骤：申请空白PCB、向PCB写入控制和管理信息、然后为进程分配所需资源、最后转入就绪状态。</p><h2 id="4-1-引起进程创建的事件"><a href="#4-1-引起进程创建的事件" class="headerlink" title="4.1 引起进程创建的事件"></a>4.1 引起进程创建的事件</h2><ul><li>系统创建<ul><li>用户登录：分时系统中户登录都可以看成一个新的进程。系统为该终端创建一个新的进程并插入就绪队列</li><li>作业调度：批处理作业中，当系统按照一定算法调度作业时，将该作业调入内存为其分配资源，提供服务。</li></ul></li><li>用户请求：用户可以基于自己的需求创建进程</li></ul><h2 id="4-2-进程创建的过程"><a href="#4-2-进程创建的过程" class="headerlink" title="4.2 进程创建的过程"></a>4.2 进程创建的过程</h2><ol><li>为进程申请一个唯一的进程识别号和空白PCB（PCB是有限的，若PCB申请失败则创建失败）</li><li>为进程分配资源、为新进程的程序、数据、用户栈分配内存空间（如果资源不足，并不是创建失败，而是处于等待状态，等待资源。</li><li>初始化PCB，主要包括标志信息、状态信息、处理机信息等。</li><li>如果就绪队列能够接受新进程，就将进程插入就绪队列中</li></ol><h2 id="4-3-Linux下的进程创建"><a href="#4-3-Linux下的进程创建" class="headerlink" title="4.3 Linux下的进程创建"></a>4.3 Linux下的进程创建</h2><p>父进程和子进程：除了0号进程，Linux系统中其他任何一个进程都是由其他进程创建的。而相对的，fork函数的调用方是父进程，创建的新进程是子进程。</p><p>fork函数不需要参数，返回值是一个进程标识符。</p><ol><li>对于父进程，fork函数返回创建子进程的ID</li><li>子进程fork函数返回0</li><li>创建出错的话fork函数返回-1</li></ol><p>fork函数创建了一个新的进程，并从内核中为其分配一个可用的进程标识符PID，之后为其分配进程空间，并将父进程空间的内容复制到子进程空间，包括数据段和堆栈段，与父进程共享代码段。这时候系统中多了一个进程，父进程和子进程都接受系统的调度。由于复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。fork函数返回两次，分别在父进程和子进程中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    if(pid&lt;0)&#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;else if(pid &#x3D;&#x3D;0)&#123;</span><br><span class="line">        printf(&quot;Subprocess, PID: %u&quot;, getpid());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Parentprocess, PID: %u&quot;, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程完全复制了父进程的地址空间，包括堆栈段和数据段。但是子进程并未复制代码段，而是共用代码段。</p><h1 id="5-进程的结束"><a href="#5-进程的结束" class="headerlink" title="5 进程的结束"></a>5 进程的结束</h1><p>结束状态：进程从系统中消失，这可能因为正常结束或其他原因中断退出。进程结束时，系统首先置该进程为结束状态，然后进一步释放和回收资源。</p><h2 id="5-1-进程结束的事件"><a href="#5-1-进程结束的事件" class="headerlink" title="5.1 进程结束的事件"></a>5.1 进程结束的事件</h2><ol><li>正常结束</li><li>异常结束：出现某种错误导致无法运行：越界、非法指令、运行超时等</li><li>外界干预：进程应外界请求而终止。<h2 id="5-2-进程的终止过程"><a href="#5-2-进程的终止过程" class="headerlink" title="5.2 进程的终止过程"></a>5.2 进程的终止过程</h2></li><li>根据被终止的标识符，检索PCB，从中读取进程状态</li><li>若进程处于执行状态，立即终止并置标志为真</li><li>若进程还有子孙进程，则终止子孙进程防止其不可控</li><li>将终止进程的所有资源释放给系统或父进程</li><li>将终止进程移除队列<h2 id="5-3-进程的切换"><a href="#5-3-进程的切换" class="headerlink" title="5.3 进程的切换"></a>5.3 进程的切换</h2></li><li>保留处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li><li>选择另一个进程执行，并更新其PCB</li><li>更新内存管理的数据结构</li><li>恢复处理机上下文。</li></ol><h1 id="6-孤儿进程和僵尸进程"><a href="#6-孤儿进程和僵尸进程" class="headerlink" title="6 孤儿进程和僵尸进程"></a>6 孤儿进程和僵尸进程</h1><p>在linux中，正常情况下子进程是通过父进程创建的，子进程和父进程的运行是一个异步的过程。父进程无法预料子进程在何时结束，于是就产生了孤儿进程和僵尸进程</p><h2 id="6-1-孤儿进程"><a href="#6-1-孤儿进程" class="headerlink" title="6.1 孤儿进程"></a>6.1 孤儿进程</h2><p>指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对他们完成状态收集工作。</p><h2 id="6-2-僵尸进程"><a href="#6-2-僵尸进程" class="headerlink" title="6.2 僵尸进程"></a>6.2 僵尸进程</h2><p>是指一个进程使用fork创建子进程，如果子进程退出，而父进程没有用wait或waitpid调用子进程的状态信息，子进程的进程描述符仍在系统中，这种进程被成为僵尸进程。</p><p>简单理解为，孤儿是父进程已退出而子进程未退出；而僵尸进程是父进程未退出而子进程先退出。</p><p>为了避免僵尸进程，需要父进程通过wait函数来回收子进程。</p><h2 id="6-3-守护进程"><a href="#6-3-守护进程" class="headerlink" title="6.3 守护进程"></a>6.3 守护进程</h2><p>在Linux系统的引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。守护进程是脱离于终端在后台运行的进程，守护进程脱离终端是为了避免进程在执行过程中在终端上显示并且不会被终端的信息打断。</p><p>守护进程是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。守护进程常常在系统引导装入时启动，在系统关闭时终止。Linux系统有很多的守护进程，大多数服务都是通过守护进程实现的。如作业规划进程、打印进程。</p><p>在Linux中每一个与用户交流的界面称为终端，每一个终端开始的进程都会依附于该终端，这个终端就被称为进程的控制终端，当控制终端被关闭时，相应的进程都会被关闭。但是守护进程可以突破这种限制，他从被执行是开始运转，整个系统关闭时才退出。如果想让某个进程不因为用户或终端等变化受到影响，那么就需要把一个进程变成一个守护进程。</p><h1 id="7-进程通信"><a href="#7-进程通信" class="headerlink" title="7 进程通信"></a>7 进程通信</h1><p>进程间通信就是不同进程间传播或交换信息。首先进程间可以通过传送、打开文件来实现，不同的进程通过一个或多个文件来传递信息。一般来说进程间通信不包括这种低级的通信方式。Linux操作系统几乎支持所有的UNIX系统进程通信方法：管道、消息队列、共享内存、信号量、套接字。</p><h2 id="7-1-管道"><a href="#7-1-管道" class="headerlink" title="7.1 管道"></a>7.1 管道</h2><p>父子进程通过管道通信，管道是一种两个进程间单向通信的机制。因为管道传递数据的单向性，管道又被称为半双工管道。管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。</p><p>无名管道的特点：</p><ol><li>数据只能由一个进程流向另一个进程（一个读管道和一个写管道）；如果要进行双工通信，则需要建立两个管道。</li><li>管道只能用于父子通信或兄弟进程通信（有亲缘关系的进程）。</li></ol><p>除了上述局限性，管道还有一些不足，比如管道没有名字（匿名管道）；管道的缓冲区大小受限（Linux下一般是4kb）；管道传输的是无格式的字节流等。这就需要管道输入方和输出方事先约定好数据格式。使用管道通信时，两端的进程向管道读写数据是通过创建管道时，系统设置的文件描述符进行的。本质上说管道也是一种文件，但它又和一般的文件不同，可以克服文件通信的一些问题。</p><p>通过管道通信的两个进程，一个向管道写数据，一个从中读数据。写入的数据每次都添加到管道缓冲区的末尾，读数据都是从缓冲区的头部读出。</p><h2 id="7-2-具名管道"><a href="#7-2-具名管道" class="headerlink" title="7.2 具名管道"></a>7.2 具名管道</h2><p>还有一种管道叫具名管道（FIFO）它的不同之处是它提供一个路径名与之关联，以FIFO的形式存在于文件系统中。这样即使与FIFO创建不存在亲缘关系的进程，只要可以访问路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程和创建FIFO的进程之间），因此通过FIFO不相关的进程也能交换数据。</p><p>有名管道的特点：</p><ol><li>它可以使互不相关的两个进程实现通信</li><li>该管道可以通过路径名来指明，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当作普通文件一样读写，使用很方便。</li><li>FIFO严格遵守先进先出的规则，对于管道与FIFO，总是从开始处返回数据，而把数据添加到末尾。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/54BB3B539E804E7997F19381159A517F/14746" alt="有名管道和无名管道的区别"></p><h2 id="7-3-消息队列"><a href="#7-3-消息队列" class="headerlink" title="7.3 消息队列"></a>7.3 消息队列</h2><p>消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现。</p><p>消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。</p><p>与命名管道相比，消息队列的优势在于：</p><ol><li>消息队列可以独立于发送和接受进程存在，从而消除了同步命名管道打开和关闭时可能产生的的困难。</li><li>可以同时通过发送消息以避免命名管道的同步和阻塞问题，而不需要由进程自己来提供同步方法</li><li>接受程序可以通过消息类型有选择的接受数据，而不是向命名管道中那样，只能默认地接受。</li></ol><p>事实上它是一种正在被淘汰的通信方式，完全可以用流管道和套接口的方式取代。</p><h2 id="7-4-共享内存"><a href="#7-4-共享内存" class="headerlink" title="7.4 共享内存"></a>7.4 共享内存</h2><p>共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据一种非常有效的方式。不同进程间的共享内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的地址空间中，所有进程都可以访问共享内存中的地址。</p><p>不过，共享内存未提供同步机制，需要进程自行进行同步操作。</p><p>共享内存的优缺点：</p><ol><li>优点：使用共享内存通信非常方便，而且函数接口简单，数据共享还使用进程间的数据不用传送，而是直接访问内存，加快了效率，并没有亲缘关系的要求。</li><li>缺点：共享内存没有提供同步机制，这使得共享内存的通信往往要借助其他手段来完成。</li></ol><h2 id="7-5-信号量"><a href="#7-5-信号量" class="headerlink" title="7.5 信号量"></a>7.5 信号量</h2><p>共享内存是进程间通信的最快的方式，但是共享内存的同步问题自身无法解决（即进程该何时去共享内存取得数据，而何时不能取），但用信号量可以轻易解决这个问题。</p><h1 id="8-进程调度"><a href="#8-进程调度" class="headerlink" title="8 进程调度"></a>8 进程调度</h1><h2 id="8-1-调度层次"><a href="#8-1-调度层次" class="headerlink" title="8.1 调度层次"></a>8.1 调度层次</h2><p>进程调度分为三级调度，作业调度，中级调度，进程调度</p><ol><li>作业调度（高级调度）：主要任务是按照一定原则从外存中将处于后备状态的作业挑选一个或多个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度），每个作业只调入一次，调出一次。具体过程：选择作业→bai分配资源→建立进程du（建立进程：申请空zhi白PCB → 分配资源 → 初始化PCB →插入进程就绪队列）</li><li>内存调度。 进程的挂起与就绪。提高内存利用率和系统吞吐量。</li><li>低级调度，按某种方法和策略从就绪队列中选取一个进程，为期分配处理机。<h2 id="8-2-调度算法"><a href="#8-2-调度算法" class="headerlink" title="8.2 调度算法"></a>8.2 调度算法</h2></li><li>先来先服务算法（FCFS）<ul><li>FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度</li><li>FCFS是不可剥夺算法，长作业会使后到的短作业长期等待</li><li>算法简单，效率低，对长作业有利，有利于CPU繁忙性工作</li></ul></li><li>短作业优先（SJF，Short Job First）算法<ul><li>从后备队列中选择一个或若干个估计运行时间最短的作业掉入内存运行</li><li>对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态</li></ul></li><li>优先级调度算法<ul><li>优先级调度算法每次从后备队列中选取优先级最高的一个或几个作业</li><li>优先级调度可以剥夺时占有，也可以非剥夺式占有</li></ul></li><li>高响应比优先<ul><li>高响应比优先是对FCFS和SJF算法的一种平衡，计算每个作业的响应比</li><li>响应比的计算为（等待时间 + 要求服务时间）/要求服务时间</li></ul></li><li>时间片轮转调度算法<ul><li>时间片轮转算法适用于分时系统，系统讲所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms</li><li>受系统响应时间影响，队列进程数目，进程长短影响较大</li></ul></li><li>多级反馈队列调度算法<ul><li>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展</li></ul><ol><li>设置多个就绪队列，为各个队列赋予优先级，1，2，3等</li><li>赋予各个队列中时间片大小不同，优先级高时间片越小</li><li>一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行。</li><li>仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推<h1 id="9-进程同步"><a href="#9-进程同步" class="headerlink" title="9 进程同步"></a>9 进程同步</h1></li></ol></li><li>临界区<ul><li>虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源</li></ul></li><li>同步<ul><li>进程之间具有直接制约关系，进程之间需要按照一定的次序进行</li></ul></li><li>互斥<ul><li>进程之间的间接制约关系，不能同时访问临界区</li></ul></li><li>信号量<ul><li>信号量是一个整形变量，可以被定义为两个标准的原语wait(S),signal(S)即P，V操作<ul><li>P操作 如果信号量大于0， 执行-1操作，如果等于0，执行等待信号量大于0</li><li>V操作 对信号量完成加1操作，唤醒睡眠的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore mutex &#x3D; 1 </span><br><span class="line">void P1()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">void P2()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>管程</li></ol><ul><li>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块<ul><li>使用信号量机制时，进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。</li><li>管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用</li><li>引入管程的目的：1. 把分散在各进程中的临界区集中起来进行管理；2. 防止进程有意无意的违反同步操作;3. 便于高级语言程序书写和验证。</li></ul></li></ul><ol start="6"><li>生产者-消费者问题<br><br> 问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品<br>由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问<br>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># define N 100</span><br><span class="line">typedef int semahpore</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">semaphore empty &#x3D; N;</span><br><span class="line">semaphore full &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void producer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        int item &#x3D; produceItem();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Item.push(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        int item &#x3D; Item.top();</span><br><span class="line">        Item.pop();</span><br><span class="line">        consume(item);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(&amp;empty())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>读写者问题<br><br>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行</li></ol><p>用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore count &#x3D; 0;</span><br><span class="line">semaphore read_mutex &#x3D; 1;</span><br><span class="line">semaphore write_mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void read()&#123;</span><br><span class="line">    P(&amp;read_mutex);</span><br><span class="line">    count++;</span><br><span class="line">    if(count&#x3D;&#x3D;1) P(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">    read();</span><br><span class="line">    p(&amp;read_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    if(count&#x3D;&#x3D;0) V(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write()&#123;</span><br><span class="line">    P(&amp;write_mutex);</span><br><span class="line">    write();</span><br><span class="line">    V(&amp;write_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>哲学家进餐问题<br><br>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根<br><br>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore chop[5] &#x3D; &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void process()&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        P(chop[i]);</span><br><span class="line">        P(chop[(i+1)%5]);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chop[i]);</span><br><span class="line">        V(chop[(i+1)%5]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-程序与进程&quot;&gt;&lt;a href=&quot;#1-程序与进程&quot; class=&quot;headerlink&quot; title=&quot;1 程序与进程&quot;&gt;&lt;/a&gt;1 程序与进程&lt;/h1&gt;&lt;p&gt;进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>应用层协议</title>
    <link href="http://example.com/2021/02/27/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AEHTTP/"/>
    <id>http://example.com/2021/02/27/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AEHTTP/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1 网络应用程序体系结构"></a>1 网络应用程序体系结构</h1><p>两种主流应用体系结构</p><ol><li>客户-服务器体系结构</li></ol><ul><li>服务器具有固定周知的地址，且总是打开</li><li>客户之间不直接通信，客户只通过服务器的IP地址与服务器通信</li><li>解决一服务器对多用户的问题：配备大量的数据中心，创建强大的虚拟服务器</li><li>举例：Web, FTP, telnet, 电子邮件</li></ul><ol start="2"><li>P2P体系结构</li></ol><ul><li>不通过专门的服务器，是对等方和对等方之间的通信。</li><li>应用程序对位于数据中心的专用服务器有很小的依赖，甚至没有</li><li>举例：共享文件（迅雷等）</li></ul><ol start="3"><li>混合结构，比如许多即时讯息应用</li></ol><ul><li>服务器跟踪用户的IP地址—-&gt;客户-服务器体系结构</li><li>用户与用户之间的报文在主机之间直接发送—-&gt;P2P体系结构<h1 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2 进程通信"></a>2 进程通信</h1>进行通信实际上就是进程(process)，而不是程序。一个进程可以被认为是运行在端系统上的一个程序。</li><li>多个进程在同一个端系统上时，直接使用进程间通信机制进行通信，且通信规则由操作系统来决定。</li><li>当进程在不同的端系统上，相互之间进行通信，需要发送端生成报文并向网络中发送，接收端接受报文并可能通过回送报文进行响应。</li></ul><ol><li>客户和服务器进程</li></ol><ul><li>进程与计算机网络之间的接口：套接字<ul><li>套接字是应用层和运输层之间的接口</li><li>由于套接字是建立网络应用程序的可编程接口，所以套接字也被称为应用程序编程接口（Application Programming Inteface）</li></ul></li><li>应用程序开发者可以控制套接字在应用层端的一切，但是对运输层几乎没有控制权，对运输层的控制仅限于<ul><li>选择传输协议</li><li>设定几个运输层参数（最大缓存和最大报文长度等）</li><li>一旦选择了一个运输层协议，应用程序就建立在由该协议提供的运输层服务之上。</li></ul></li></ul><ol start="2"><li>进程寻址<br><br>从一台主机将分组发到另外一台主机，需要标识接受进程的地址<ul><li>目的地主机（由IP地址唯一标识）</li><li>指定运行在接受主机上的接收进程，具体地说，是接收套接字（通过端口号标识）<h1 id="3-可供应用程序使用的运输服务"><a href="#3-可供应用程序使用的运输服务" class="headerlink" title="3. 可供应用程序使用的运输服务"></a>3. 可供应用程序使用的运输服务</h1></li></ul></li><li>可靠数据传输：只要运输协议提供了这种服务，发送进程只要将数据传递进套接字，就可以完全信任数据能够无差错地到达接收进程<ul><li>不提供可靠地数据传输服务：容忍丢失的应用</li></ul></li><li>吞吐量：发送进程能够向接收进程交付比特的速率<ul><li>带宽敏感应用希望能够提供特定速率</li><li>弹性应用可以根据当前可用带宽的多少提供吞吐量，例如电子邮件、文件传输和Web传送</li></ul></li><li>定时<br><br> 类似于对吞吐量的保证，运输层协议可以提供定时保证，比如保证发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms.<ul><li>交互式实时应用对数据交付有严格的时间限制</li></ul></li><li>安全性<h1 id="4-因特网提供的运输服务"><a href="#4-因特网提供的运输服务" class="headerlink" title="4 因特网提供的运输服务"></a>4 因特网提供的运输服务</h1></li><li>TCP服务<ul><li>面向连接的服务<ul><li>握手阶段：在应用层数据报文流动之前，TCP先让客户和服务器互相交换运输层控制信息，提醒双方即将有大量分组到来。</li><li>握手之后：一个TCP连接就建立起来，这条连接是双工的。</li><li>结束时：应用程序结束报文发送时，必须拆除该连接。</li></ul></li><li>可靠地数据传送服务<ul><li>无差错且按适当顺序交付所有发送的数据</li></ul></li><li>TCP协议还具有拥塞控制机制，它不针对某一进程，而是针对整个因特网。当发和收双方之间的网络出现拥塞时，TCP的拥塞机制就会抑制发送进程，同时也会限制每个TCP连接，让他们公平地共享网络带宽。</li></ul></li><li>UDP服务<br><br> UDP是不提供不必要服务的轻量级运输协议，仅提供最小服务。<ul><li>无连接的，也就是通信没有握手的过程</li><li>提供的是不可靠数据传送服务，它不保证对方能否收到，也不能保证报文的顺序。</li><li>没有拥塞控制机制，UDP的发送端可以以任何速率向下层注入数据。(可能受到中间链路带宽受限或者拥塞的影响，实际端到端的吞吐量甚至比这个速率还小)</li></ul></li><li>SSL<ul><li>TCP和UDP都没有提供任何加密机制，在TCP的基础上进行加强的套接字(Secure Sockets Layers SSL)</li><li>流程：发送进程将明文数据传给SSL套接字，发送主机中的SSL加密该数据并传递给TCP套接字，经过网络，传给接受进程的TCP套接字，它将加密数据传给SSL，由SSL进行解密，最后SSL通过SSL套接字将明文数据传递给接受进程。<blockquote><p>电子邮件、远程终端访问、web和文件传输等流行的因特网应用都使用了TCP协议，最主要的原因还是TCP提供着可靠的数据传输服务。因特网电话应用（Skype）则能够容忍某些丢失,选择了UDP。但是许多防火墙搜设置阻挡UDP流量，所以因特网电话应用也通常使用TCP作为备份。</p></blockquote></li></ul></li></ol><h1 id="5-应用层协议-HTTP"><a href="#5-应用层协议-HTTP" class="headerlink" title="5 应用层协议-HTTP"></a>5 应用层协议-HTTP</h1><p>应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。web的应用层协议是HTTP（超文本传输协议）。</p><h2 id="5-1-http相关概念"><a href="#5-1-http相关概念" class="headerlink" title="5.1 http相关概念"></a>5.1 http相关概念</h2><ol><li>超文本传输协议（HyperText Transfer Protocol） HTTP</li><li>同一资源定为符（Uniform Resource Locator） URL(网页地址, 包括协议、主机、端口、路径)</li><li>统一资源标识符（Uniform Resource Identifier）URI（由某个协议方案标识的资源的定为标识符）（[协议名]://[用户名]:[密码]@[服务器地址]:[服务器端口号]/[路径]?[查询字符串]#[片段ID]）</li><li>URI与URL区别<ul><li>URL是一种URI，它通过网络位置进行标示。</li><li>URI可以被视为定位符（URL），名称（URN）或者两者兼备。URN定义某事物的身份，URL提供查找该事物的方法。</li></ul></li><li>HTTP使用TCP作为它的支撑运输协议。HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节，这是分层体系结构的最大优点。</li><li>服务器向客户发送被请求文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议(stateless protoless)。<h2 id="5-2-非持续连接和持续连接"><a href="#5-2-非持续连接和持续连接" class="headerlink" title="5.2 非持续连接和持续连接"></a>5.2 非持续连接和持续连接</h2></li></ol><ul><li>非持续连接<ul><li>每个请求/响应是经过一个单独的TCP连接发送</li><li>缺点：<ul><li>必须为每个请求对象建立和维护一个全新的连接。对每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量。</li><li>每个对象经受两倍RTT（往返时延，数据完全发送完到收到确认信号的时间，传播*2 + 排队）的交付时间，一个RTT用于建立TCP，另一个RTT用于请求和接受一个对象</li></ul></li></ul></li><li>持续连接<ul><li>每个请求/响应对是经过一个相同的TCP连接发送</li><li>对对象的请求可以一个接一个的发出，而不必等待对未决请求的回答</li></ul></li><li>HTTP/1.1中默认保持持久连接，但是1.0的HTTP需要设置connection:keep-live<h2 id="5-3-HTTP报文格式"><a href="#5-3-HTTP报文格式" class="headerlink" title="5.3 HTTP报文格式"></a>5.3 HTTP报文格式</h2></li></ul><ol><li>请求报文<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/5FDF98FF4BAD4B0CB5E586AA1D495FC7/13364" alt="请求报文"></li></ol><p>包括请求行、首部行（请求头部）、空行、实体体</p><p>HTTP请求报文的第一行叫请求行，包括：方法字段、URL字段、HTTP版本字段</p><p>请求头部是一个个key-value对，比如<code>Accept-Language: en-US</code></p><p>CR(Carriage Return)回车符<br>LF(Line Feed)换行符</p><p>使用GET方法时请求实体为空，使用POST方法时才使用请求实体</p><ol start="2"><li>响应报文<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/66A0D094FAC149E18D944C6BC66B191A/13366" alt="响应报文"></li></ol><p>包括状态行、首部行、空行、实体体</p><p>HTTP响应报文的第一行叫状态行，包括：协议版本字段、状态码字段、相应状态信息</p><p>实体体部分是报文的主要部分，包含了请求的对象</p><h2 id="5-4-请求方法"><a href="#5-4-请求方法" class="headerlink" title="5.4 请求方法"></a>5.4 请求方法</h2><p>HTTP/1.1协议中定了9种方法来表明Request-URL指定资源的不同的操作方式</p><ol><li>OPTIONS询问支持的方法。返回服务器针对特定资源的HTTP请求方法.</li><li>HEAD获得报文首。向服务器索要与GET请求一致的响应，响应体不会被返回。主要用户URL有效性及资源更新日期时间。</li><li>GET获取资源。向特定资源发出请求（GET可能会被爬虫随意访问）</li><li>POST传输实体主体。向指定资源提交数据处理的请求（提交表单、上传文件）数据被包含在请求体中。POST可能会导致新建资源或已有资源的修改</li><li>PUT传输文件。自身不带验证机制，存在安全性问题。向指定资源上传最新内容。（本身不带安全验证，可以上传恶意文件，从而获取权限，存在安全机制一般不用）</li><li>DELETE删除文件。与PUT一样，不带安全验证，可以删除特定文件，存在安全性问题<a href="https://www.freebuf.com/articles/web/172695.html">安全问题</a>。请求服务器删除REQUEST_URL所标识的资源。</li><li>TRACE追踪路径。服务器会把通信路径返回客户端（通常不会用，易受攻击）。</li><li>CONNECT。要求 与代理服务器通信时建立隧道，使用SSL和TSL.CONNECT这个方法的作用就是把服务器作为跳板，让服务器代替用户去访问其它网页，之后把数据原原本本的返回给用户。这样用户就可以访问到一些只有服务器上才能访问到的网站了，这就是HTTP代理.<a href="https://www.cnblogs.com/xyl1932432873/p/7735866.html">详细解释</a></li><li>PATCH局部修改某一资源。</li></ol><h2 id="5-5-GET与POST的区别"><a href="#5-5-GET与POST的区别" class="headerlink" title="5.5 GET与POST的区别"></a>5.5 GET与POST的区别</h2><ol><li>作用：GET用于获取资源，POST用于传输实体主体</li><li>参数：GET和POST都能使用额外的参数，但是GET参数以查询字符串的形式出现在URL中，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin</a> 这个过程用户可见。而POST的参数存储在实体主体中。通过HTTP的POST机制。POST参数可以通过一些抓包工具（Fiddler）查看。<br><br>因为URL只支持ASCLL码，因此GET参数中文会被编码，空格被编码为%20</li><li>安全： 安全的HTTP方法不会改变服务器状态，可以说他是只读的<br><br>get方法是安全的，POST不是，POST方法传输主体内容，这个内容可能是某个表单数据，服务器可能把其存入数据库中，这样状态就发生了改变。</li><li>幂等性<br><br>幂等性的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。<br><br>所有安全的方法是幂等的，GET、HEAD、PUT、DELETE方法都是幂等的。而POST方法不是幂等的。<br>一个幂等的操作典型如：把编号为5的记录的A字段设置为0，这种操作不管执行多少次都是幂等的。一个非幂等的操作典型如：把编号为5的记录的A字段增加1，这种操作显然就不是幂等的。</li><li>GET请求会被浏览器主动cache,而post不会，除非手动设置。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li><li>XMLHTTPRequest<br><br>XMLHTTPRequest是一个API，它为客户端和服务器之间传输数据的功能。他提供了一个URL来获取数据的简单方式，而且不会使整个页面刷新。这使得网页只更新一部分不会打扰到用户，在AJAX中被大量使用。在xmlhttprequest中POST会先发送header再发送data（当然也和浏览器的做法相关），而get方法会一起发送。</li><li>其他<br><br>Get传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递<br><br>Get方式只支持ASCII字符，向服务器传输的中文字符可能会乱码。POST支持标准字符集，可以正确的传递中文字符</li></ol><h2 id="5-6-PUT、POST区别"><a href="#5-6-PUT、POST区别" class="headerlink" title="5.6 PUT、POST区别"></a>5.6 PUT、POST区别</h2><p>put是幂等的，如果两个请求相同，后一个会把第一个覆盖掉。(PUT用来改资源)<br><br>post不是幂等的，后一个请求不会把第一个请求覆盖掉。(Post用来增加资源)</p><h2 id="5-7-HTTP首部Request"><a href="#5-7-HTTP首部Request" class="headerlink" title="5.7 HTTP首部Request"></a>5.7 HTTP首部Request</h2><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">客户端能够接受的内容类型</td><td align="center">text/html</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">浏览器可以支持的web服务器返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Accept-Language</td><td align="center">浏览器可以接受的语言</td><td align="center">zh-CN</td></tr><tr><td align="center">Cache-Control</td><td align="center">指定请求和相应遵循的缓存机制</td><td align="center">max-age=0</td></tr><tr><td align="center">Connection</td><td align="center">表示是否需要持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Cookie</td><td align="center">HTTP请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器</td><td align="center">键值对</td></tr><tr><td align="center">Host</td><td align="center">请求服务器的域名和端口号</td><td align="center"><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td align="center">Upgrade-Insecure-Requests</td><td align="center">浏览器可以处理HTTPS协议</td><td align="center">1</td></tr><tr><td align="center">User-Agent</td><td align="center">发出请求的用户信息</td><td align="center">Mozilla/5.0</td></tr></tbody></table><h2 id="5-8-HTTP-首部-Response"><a href="#5-8-HTTP-首部-Response" class="headerlink" title="5.8 HTTP 首部 Response"></a>5.8 HTTP 首部 Response</h2><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">告诉所有的缓存机制是否可以缓存及缓存哪种类型</td><td align="center">private</td></tr><tr><td align="center">Connection</td><td align="center">是否保持持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Content-Encoding</td><td align="center">返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Content-type</td><td align="center">返回内容的MIME类型</td><td align="center">text/html charset=utf-8</td></tr><tr><td align="center">Date</td><td align="center">原始服务器消息发出时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Expires</td><td align="center">响应过期的时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Server</td><td align="center">Web服务器软件名称</td><td align="center">BWS1.1</td></tr><tr><td align="center">Set-Cookie</td><td align="center">设置浏览器缓存</td><td align="center">BDSVRTM=114; path=/</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">文件传输编码</td><td align="center">chunked</td></tr></tbody></table><h2 id="5-9-HTTP状态码"><a href="#5-9-HTTP状态码" class="headerlink" title="5.9 HTTP状态码"></a>5.9 HTTP状态码</h2><p>HTTP中状态码大致分为5大类：</p><ol><li>100-199信息性状态码<ul><li>100 continue： 收到了请求的初始部分，请客户端继续</li></ul></li><li>200-299 成功状态码<ul><li>200 OK：请求被正常处理</li><li>204 No Content: 请求被接受，但是响应报文只有首部和状态行，没有实体部分</li><li>206 Partial Content: 客户端只请求了一部分的资源，服务器只针对请求的部分资源进行返回</li></ul></li><li>300-399 重定向状态码<ul><li>301 Moved Permanently: 永久重定向。服务器返回此响应时，会自动将请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。 </li><li>302 Found（临时移动）（对应转发）: 临时重定向，资源被临时移动了。但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎页面或网站已被移动。</li><li>303 See Other: 表示用户请求的资源代表着另一个URI，应该使用GET去获取资源。当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 </li><li>304 Not Modified: 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。<br>  如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应。由于服务器可以告诉 搜索引擎自从上次抓取后网页没有更改过，因此可节省带宽和开销。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</li><li>307 Temporary Redirect（临时重定向）（对应重定向）: 同302。</li></ul></li><li>400-499 客户端错误状态码<ul><li>400 Bad Request: 告知客户端它发送了一个错误的请求</li><li>401 Unauthorized: 请求需进行认证</li><li>403 Forbidden: 请求被服务器拒绝了</li><li>404 Not Found：服务器无法找到对应资源</li><li>405 Method Not Allowed：请求中带有不支持的方法（方法禁用）</li></ul></li><li>500-599 服务器错误状态码<ul><li>500 Internet Server Error: 服务器内部错误</li><li>502 Bad GateWay： 代理或网关服务器从下一条链路收到了伪响应（网关错误）</li><li>503 Server Unavailable: 服务器正忙</li><li>504 GateWay Timeout: 一个代理网关等待另一服务器时超时了<h2 id="5-10-cookie和session"><a href="#5-10-cookie和session" class="headerlink" title="5.10 cookie和session"></a>5.10 cookie和session</h2><h3 id="5-10-1-cookie"><a href="#5-10-1-cookie" class="headerlink" title="5.10.1 cookie"></a>5.10.1 cookie</h3></li></ul></li></ol><p>HTTP服务器时无状态的，但是一个Web站点通常希望能够识别用户，（限制访问、用户身份）为此使用cookie技术。</p><p>网络服务器用HTTP头向客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。</p><p>cookie技术的4个组件：<br></p><ol><li>HTTP响应报文中的cookie首部行</li><li>HTTP请求报文中的cookie首部行</li><li>用户端系统中保留有一个cookie文件，由浏览器进行管理。</li><li>位于Web站点的后端数据库</li></ol><p>过期时间：</p><ol><li>会话cookie： 若不设置过期时间，表示这个cookie的生命周期未浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie</li><li>持久cookie： 若设置了过期时间，浏览器会把cookie存储到硬盘上（可以拒绝），关闭后在打开这些cookie仍然有效<h3 id="5-10-2-session"><a href="#5-10-2-session" class="headerlink" title="5.10.2 session"></a>5.10.2 session</h3>session机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息</li></ol><p>当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。</p><p>session_id的存储</p><ol><li>保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session</li><li>由于cookie可以被人为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符</li><li>另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id</li></ol><h3 id="5-10-2-session-和-cookie区别"><a href="#5-10-2-session-和-cookie区别" class="headerlink" title="5.10.2 session 和 cookie区别"></a>5.10.2 session 和 cookie区别</h3><ol><li>存取方式不同<br><br>cookie只能保存ASCII字符，Unicode和二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较难。<br>而session中能够存取任何类型的数据，十分方便。</li><li>隐私策略不同<ul><li>cookie存储在客户端浏览器中，对客户可见，客户端可以窥探甚至修改cookie内容。</li><li>session存储在服务器上，对用户透明，不存在泄漏风险。</li><li>cookie可以像google及百度一样将敏感信息加密后保存，在服务器上进行解密。</li></ul></li><li>有效时间不同<ul><li>由于session依赖于session_ID的cookie，而session_id的过期时间默认为-1，关闭浏览器即消失。而cookie可以设置长期的保存。</li></ul></li><li>服务器压力不同<ul><li>由于不从的存储方式，存储在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大。</li></ul></li><li>浏览器支持不同<ul><li>cookie需要客户端浏览器的支持，假如客户端禁用或不支持cookie，则会话跟踪会失效</li><li>假如客户端不支持cookie，就需要运用session及URL地址重写。注意，所有用到session的程序url都要进行重写，否则session会话会失效</li></ul></li><li>跨域支持不同<ul><li>cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用</li><li>session尽在当前域名有效<blockquote><p>跨域名访问：<a href="https://www.cnblogs.com/sexintercourse/p/7011427.html">跨域问题</a> <a href="https://www.cnblogs.com/hujunzheng/p/5744755.html">cookie跨域</a></p></blockquote></li></ul></li></ol><h2 id="5-11-web缓存和条件GET方法"><a href="#5-11-web缓存和条件GET方法" class="headerlink" title="5.11 web缓存和条件GET方法"></a>5.11 web缓存和条件GET方法</h2><ol><li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本</li><li>条件GET方法<ul><li>条件GET使缓存器证实他的对象是最新的。<ul><li>请求报文中使用GET方法、</li><li>请求报文中包含“If-Modified-Since”首部行</li></ul></li><li>304 not modified告诉缓存器可以继续使用该对象<h2 id="5-12-HTTP和HTTPS的区别"><a href="#5-12-HTTP和HTTPS的区别" class="headerlink" title="5.12 HTTP和HTTPS的区别"></a>5.12 HTTP和HTTPS的区别</h2></li></ul></li><li>HTTPS协议需要CA申请证书，需要缴费</li><li>HTTP是超文本传输协议，明文传输，HTTPS是SSL加密传输</li><li>HTTP是80端口，HTTPS是443端口</li><li>HTTP连接很简单，无状态，HTTPS经过SSL+HTTP协议构建，加密传输，身份认证</li><li>HTTPS耗性能，安全性要求低用HTTP</li></ol><h2 id="5-12-CGI（Common-Gateway-Interface）公共网关接口"><a href="#5-12-CGI（Common-Gateway-Interface）公共网关接口" class="headerlink" title="5.12 CGI（Common Gateway Interface）公共网关接口"></a>5.12 CGI（Common Gateway Interface）公共网关接口</h2><p>CGI 是HTTP 中重要的技术之一，有着不可替代的作用。CGI是一个web服务器的标注接口。通过CGI接口Web服务器就能获取客户端提交的信息转交给服务器端的CGI程序处理，最后结果返回给客户端。</p><p>CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。服务器和客户端之间的通信，是浏览器和服务端web服务器的HTTP通信，所以只需知道浏览器执行哪个CGI程序即可.<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/F3459DFFB8F74C0690421E549BA2D514/13681"></p><h2 id="5-13-因特网中的电子邮件"><a href="#5-13-因特网中的电子邮件" class="headerlink" title="5.13 因特网中的电子邮件"></a>5.13 因特网中的电子邮件</h2><p>因特网电子邮件系统由3个主要组成部分：用户代理（user-agent)、邮件服务器（mail server)、简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）</p><ol><li><p>SMTP<br><br><strong>25号</strong>端口、TCP连接，传输的三个阶段： 握手、传输、关闭连接。</p></li><li><p>与HTTP的对比<br><br>都是TCP连接，持续的HTTP和SMTP都是持续连接。</p><ul><li>HTTP是一个拉协议，TCP连接由想接受文件的机器发起。SMTP是一个推协议，TCP连接由发送文件的机器发起。</li><li>SMTP要求报文采用7比特ASCII码格式，如果报文包含了非7比特ASCII字符，必须按照7比特ASCII码进行编码。HTTP数据则不受这种限制。</li><li>如何处理一个既包含文本又包含图形的文档。HTTP把每个对象封装到各自的HTTP响应报文中，SMTP则把所有报文对象放在同一个报文之中。</li></ul></li><li><p>邮件报文格式</p><ul><li>必须包含From首部行和To首部行</li></ul></li><li><p>邮件访问协议</p><ul><li>第三版邮局协议（Post Office Protocol-Version3，POP3）</li><li>因特网邮件访问协议（Internet Mail Access Protocol， IMAP）</li><li>HTTP</li><li>一张图说明邮件协议之间的关系<br>  <img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/5588B8730F3643EBA96E38F18D1D6707/13766" alt="邮件协议"><h1 id="5-14-FTP文件传输协议"><a href="#5-14-FTP文件传输协议" class="headerlink" title="5.14 FTP文件传输协议"></a>5.14 FTP文件传输协议</h1></li></ul></li><li><p>HTTP是超文本传输协议，是面向网页的；FTP是文件传输协议，是面向文件的。  </p></li><li><p>HTTP协议默认端口：80号端口。FTP协议默认端口：21号端口。</p></li><li><p>FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据。</p></li><li><p>因为在FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是带外传送的，如果控制信息和数据信息通过同一个TCP传输，则称为带内传送（HTTP）</p></li><li><p>FTP中控制连接贯穿整个会话，但是数据连接在一个文件开始传输时建立，传输结束后关闭，所以每次传输一个新文件时，都会建立一个数据连接。控制连接是持久连接，数据连接是非持久连接。</p></li><li><p>有状态。FTP需要在整个会话期间，保留用户的状态，也就是将控制连接同用户账户关联起来，同时记录在远程目录树上的操作，这就限制了FTP可以同时维持的会话总数。</p></li></ol><h1 id="5-15-DNS"><a href="#5-15-DNS" class="headerlink" title="5.15 DNS"></a>5.15 DNS</h1><ol><li>DNS（Domain Name System）提供主机名到IP地址转换的目录服务。</li><li>DNS运行在UDP传输协议之上，使用<strong>53号</strong>端口</li><li>DNS是：1. 一个由分层的DNS服务器实现的分布式数据库。2. 一个使得主机能够查询分布式数据库的应用层协议。</li><li>DNS采用分布式的设计方案，因为单一的DNS服务器无法解决单点故障，无法保证通信容量以及无法临近所有的查询主机和维护困难等问题。</li><li>根DNS服务器：因特网上由13个根DNS服务器，每台服务器是一个冗余的计算机网络以*提供安全性和可靠性</li><li>顶级域DNS服务器：负责顶级域名如com、org、net、edu等以及各个国家顶级域名的转换。</li><li>权威DNS服务器：因特网上，具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。</li><li>本地DNS服务器：邻近其所在网络的其他主机。当主机发出DNS请求时，请求被发往本地DNS服务器，起着代理的作用。</li><li>递归查询：从请求主机到本地DNS服务器的查询是递归的，其余都是迭代的</li><li>DNS缓存每当DNS服务器发出请求后受到回答时，就将回答的内容缓存在自己的主机空间上。注意有效时间</li></ol><h1 id="5-16-P2P2文件分发"><a href="#5-16-P2P2文件分发" class="headerlink" title="5.16 P2P2文件分发"></a>5.16 P2P2文件分发</h1><p>p2p体系结构具有良好的自扩展性。这种扩展性的直接成因是对等方除了是比特的消费者之外还是重新分发者。</p><h2 id="5-16-1-BitTorrent"><a href="#5-16-1-BitTorrent" class="headerlink" title="5.16.1 BitTorrent"></a>5.16.1 BitTorrent</h2><ol><li>参与一个特定文件分发的所有对等方的集合被称为一个洪流</li><li>在一个洪流中的对等方彼此下载等长度的文件块</li><li>当一个对等方下载文件块的时候，也向其他对等方发送了多个块，一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件。</li><li>P2P文件共享协议，参与一个特定文件分发的所有对等方结合被称为一个洪流（torrent），在一个洪流的对等方彼此下载等长度的文件块，可以随时离开洪流，也可继续向其他对等方上载。每个洪流都有一个追踪器。</li><li>Alice加入某洪流时，会在追踪器里进行注册，周期性通知追踪器它仍在洪流中。我们称所有与ALICE成功的创建了一个TCP链接的对等方成为邻近对等方。</li><li>洪流随机从参与对等方的结合中选择一个子集，将他们的IP地址发给Alice，Alice维护这张对等方列表，试图与所有对等方建立并行的TCP连接。</li><li>Alice周期询问每个邻近对等方（连上的）他们有的文件块列表，她随时知道邻居有哪些文件块</li><li>Alice使用最稀缺优先技术，首先请求那些邻居们副本数量最少的块，使该文件块迅速分发，以均衡每个块在洪流中的副本数量</li><li>BitTorrent使用一种算法，Alice优先从像她传时速度最快的邻居（4个，每10s修改一次）那里获取文件块。</li><li>每过30s，Alice也要随机选择另外一个对等方Bob，向他发送块。若Alice是Bob最快的前四快，Bob也是Alice的前4快，则Bob和Alice互相发送数据。</li><li>每过30s换一个新的对象，互相交换数据（一报还一报），为了使对等方能够找到彼此协调的速率上传</li></ol><ul><li>几个概念<ul><li>分布式散列表（DHT）</li><li>经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）（视频流）</li><li>内容分发网（Content Distribution Network，CDN ）<h1 id="5-17-网关和代理对比"><a href="#5-17-网关和代理对比" class="headerlink" title="5.17 网关和代理对比"></a>5.17 网关和代理对比</h1></li></ul></li></ul><ol><li>协议<br><br>理连接的是两个或多个使用相同协议的应用程序，而网关连接的则是两个或多个使用不同协议的应用程序。网关扮演的是‘协议转换器’的角色，即使客户端和服务端使用的是不同的协议，客户端也可以通过网关来和客户端进行交互。</li><li>功能<br><br>网关：如果一台电脑需要访问网络外的其他电脑，那么就需要配置网关来获得访问网络外部的权限。如果没有网关，电脑就无法访问局域网之外的网络部分，就像是被锁在家里一样。<br><br>代理服务器除了网关的功能外，还有信息过滤的功能。代理服务器能隐藏你的网络信息，任何用户想访问带有代理服务器的网络，都只能看到代理服务器的IP。代理服务器还有缓存功能。</li></ol><h2 id="5-18-总结"><a href="#5-18-总结" class="headerlink" title="5.18 总结"></a>5.18 总结</h2><p>一个web页面的请求过程</p><ol><li>DHCP配置主机信息(找主机IP)</li></ol><ul><li>主机生成一个DHCP请求报文，并将这个报文放入目的端口67和源端口68的UDP报文段中</li><li>该报文段放在一个广播IP地址(255.255.255.255)和源IP地址(0.0.0.0)的IP数据报中。</li><li>该数据报被放在MAC帧中，目的地址FF:FF:FF:FF:FF:FF,广播到交换机连接的所有设备</li><li>交换的DHCP服务器收到广播帧后，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码，再经过层层封装到MAC帧中</li><li>该帧的目的地址是主机的mac地址，主机收到该帧后分解得DHCP报文，之后配置IP地址，子网掩码，DNS服务器IP地址，安装默认网关</li></ul><ol start="2"><li>ARP解析网关MAC地址(找网关MAC地址)</li></ol><ul><li>主机通过浏览器生成一个TCP套接字，为了发送HTTP请求，需要知道网站对应的IP地址。</li><li>生成一个DNS查询报文，端口53(DNS服务器)</li><li>DNS查询报文放入目的地址为DNS服务器IP地址的IP数据报中</li><li>IP数据报放入一个以太网帧中，发送至网关路由器</li><li>DHCP过程只知道网关的IP地址，为了获取网关的MAC地址，需要用ARP协议。</li><li>主机生成一个目的地址为网关路由器IP的ARP查询报文，放入一个广播帧中，并发送这个以太网帧，交换机将其发送给所有的连接设备。</li><li>网关接收到该帧后，分解得到ARP报文，发现IP地址与自己相匹配，发送一个ACK报文回应自己的MAC地址。</li></ul><ol start="3"><li>DNS解析域名(找服务器IP)</li></ol><ul><li>知道了网关的MAC地址后就可以继续DNS解析过程</li><li>网关接收到DNS查询报文后，抽出IP数据报，并根据该表选择该转发的路由器</li><li>路由器根据内部网关协议(RIP、OSPF)和外部网关协议(BGP)配置路由器到DNS的路由表项</li><li>之前的DNS报文到DNS服务器后，照常依次抽出报文，在DNS库中查找解析域名</li><li>找到DNS记录后发送DNS回答报文，然后将其放入UDP报文段、IP数据报，通过路由器反转发回网关路由器，经过交换机到主机。</li></ul><ol start="4"><li>HTTP请求页面</li></ol><ul><li>有了HTTP服务器的IP地址后，主机便可以生成TCP套接字，向web服务器发送HTTP get报文</li><li>建立HTTP连接前需要进行TCP连接，进行三次握手，过程略</li><li>建立连接后发送HTTP的GET报文，交付给HTTP服务器</li><li>HTTP服务器从TCP中读出报文，生成HTTP相应报文，将web页面放入HTTP报文主体中发挥主机</li><li>浏览器收到HTTP相应报文后抽取WEB页面内容进行渲染，显示web页面</li></ul><p><a href="https://www.cnblogs.com/summerday152/p/13762598.html">计算机常用考试题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-网络应用程序体系结构&quot;&gt;&lt;a href=&quot;#1-网络应用程序体系结构&quot; class=&quot;headerlink&quot; title=&quot;1 网络应用程序体系结构&quot;&gt;&lt;/a&gt;1 网络应用程序体系结构&lt;/h1&gt;&lt;p&gt;两种主流应用体系结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户-服务器</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloud_netflix</title>
    <link href="http://example.com/2021/02/27/springcloud_netflix/"/>
    <id>http://example.com/2021/02/27/springcloud_netflix/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springcloud生态"><a href="#springcloud生态" class="headerlink" title="springcloud生态"></a>springcloud生态</h1><p><a href="https://www.bilibili.com/video/BV1jJ411S7xr?p=15">springcloud</a></p><h2 id="1-4-个问题"><a href="#1-4-个问题" class="headerlink" title="1 4 个问题"></a>1 4 个问题</h2><ol><li>API （解决网关）</li><li>HTTP， RPC（解决分布式通讯）</li><li>注册和发现（解决高可用）</li><li>熔断机制（进行服务降级）</li></ol><p>微服务：将单一的应用程序划分成一组小的服务</p><blockquote><p>mycat 数据库读写分离  elastic search</p></blockquote><p>spring cloud netflix</p><p>spring cloud 中国社区·</p><p>eureca是对应zookeeper的</p><h2 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2 Eureka"></a>2 Eureka</h2><p>是Netflix的一个子模块，是一个机遇rest的服务</p><ol><li>导入依赖</li><li>编写配置文件</li><li>开启这个功能@Enable</li><li>配置类</li></ol><p>eureka好死不如赖活着</p><p>eureka与zookeeper区别</p><p>CAP三选二<br>C 强一致性<br>A 可用性<br>P 分区容错性</p><p>zookeeper保证的是CP，enreka保证的是AP</p><blockquote><p>面试题，两者的区别</p></blockquote><h2 id="3-ribbon"><a href="#3-ribbon" class="headerlink" title="3 ribbon"></a>3 ribbon</h2><ol><li>spring cloud ribbon 是基于netflix实现的一套客户端负载均衡工具</li></ol><p>nginx是集中时，由nginx决定分发给谁</p><p>ribbon是进程时，由消费方通过注册中心获取所有可用，通过算法决定如何选择。</p><blockquote><p>feign是面向接口版本的ribbon, 也是负载均衡的</p></blockquote><h2 id="4-Hystrix"><a href="#4-Hystrix" class="headerlink" title="4 Hystrix"></a>4 Hystrix</h2><p>Hystrix 可以提供服务熔断和服务降级</p><p>服务熔断机制是对应雪崩效应的一种微服务链路保护机制</p><p>相关概念，备份，服务降级</p><p>服务熔断是提供者，服务降级是消费者</p><p>降级是客户端的，因为后台为了释放资源已经关闭了，可以用feign配合hystrix来进行</p><p>服务熔断：服务端，某个服务超时或者异常，引起熔断，保险丝</p><p>服务降级：客户端，从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再会被调用，不走服务器。此时在客户端，我们可以准备一个FallbackFactory，返回一个默认的值，但整体服务水平下降了。</p><h1 id="5-路由网关-zuul"><a href="#5-路由网关-zuul" class="headerlink" title="5 路由网关 zuul"></a>5 路由网关 zuul</h1><ol><li>身份验证和安全性</li><li>监控</li><li>动态路由</li><li>压力测试</li><li>减载</li><li>静态响应处理</li><li>多区域弹性</li></ol><blockquote><p>统一路由，统一权限认证</p></blockquote><p>通过配置文件对请求进行路由和过滤</p><h1 id="6-spring-cloud-config"><a href="#6-spring-cloud-config" class="headerlink" title="6 spring cloud config"></a>6 spring cloud config</h1><p>config为微服务架构中的微服务提供集中化的外部配置支持 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springcloud生态&quot;&gt;&lt;a href=&quot;#springcloud生态&quot; class=&quot;headerlink&quot; title=&quot;springcloud生态&quot;&gt;&lt;/a&gt;springcloud生态&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilib</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloudalibaba</title>
    <link href="http://example.com/2021/02/27/springcloudalibaba/"/>
    <id>http://example.com/2021/02/27/springcloudalibaba/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-nacos实时QPS"><a href="#1-nacos实时QPS" class="headerlink" title="1 nacos实时QPS"></a>1 nacos实时QPS</h1><p>服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户端，由客户端进行服务限流降级等操作。客户端的操作行为也会被推送到服务端，从而形成QPS</p><h1 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h1><ol><li>服务发现组件nacos</li><li>配置中心组件nacos</li><li>断路保护组件sentinel</li><li>远程组件dubbo,而原来是Openfeign</li><li>seata分布式事务</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-nacos实时QPS&quot;&gt;&lt;a href=&quot;#1-nacos实时QPS&quot; class=&quot;headerlink&quot; title=&quot;1 nacos实时QPS&quot;&gt;&lt;/a&gt;1 nacos实时QPS&lt;/h1&gt;&lt;p&gt;服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://example.com/2021/02/27/zookeeper/"/>
    <id>http://example.com/2021/02/27/zookeeper/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1 zookeeper"></a>1 zookeeper</h1><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=31">zookeeper+Dubbo</a></p><p>包括数据发布订阅、负载均衡、命名服务、集群管理分布式锁、分布式队列等功能。</p><ol><li>zookeeper提供了分布式数据一致性解决方案</li></ol><p>一致性：</p><ul><li>强一致性：锁机制、如果数据不一致，不提供服务</li><li>最终一致性：数据最终同步即可，没有实时性要求</li></ul><ol start="2"><li>CAP原则（一致性、可用性和分区容错性）</li></ol><ul><li>一致性：指的是强一致性 (C)</li><li>可用性：服务一直处于可用状态 (A)</li><li>分区容错性：在遇到任何网络分区故障，仍需要对外提供一致性和可用性服务。(P)<br>3选2， 要么AP 要么CP</li></ul><ol start="2"><li><p>一致性协议</p><ul><li><p>2PC二阶段提交</p><ul><li>阶段一预执行，但事务没有提交</li><li>阶段二执行事务提交或者中断事务，如果所有参与者都返回ack，则执行事务，否则中断<blockquote><p>这一个过程需要协调者</p><br></blockquote></li></ul></li><li><p>二阶段提交的问题</p><ul><li>同步阻塞：协调者发送消息后需要阻塞</li><li>单点：如果协调者挂了，就完了</li><li>脑裂导致数据不一致：如果协调者与某个节点断开，有些节点提交了，有些没有不一致</li></ul></li><li><p>3PC阶段提交</p><ul><li>阶段1，协调者向所有参与者发送canCommit询问，能否响应事务请求，相当于网络测试</li><li>阶段2，如果阶段1所有节点都能通讯，所有都执行预提交，也就是preCommit操作预提交，如果某个节点返回no或等待超时，则则中断事务。</li><li>阶段3，doCommit，如果所有阶段2都成功，执行提交，发送提交请求，否则中断事务。</li></ul></li><li><p>3PC解决了同步阻塞和单点问题，一个是超时时间解决同步阻塞，一个是如果协调者在三阶段挂了，其他节点没收到commit会自动提交</p></li></ul></li><li><p>paxos算法</p><ul><li>基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题的最有效的算法。</li><li>解决问题，在分布式系统中，如果产生宕机或网络异常，快速的正确的在集群内部解决数据一致性问题（过半理念）zookeeper基于 fast paxos版本</li><li>paxos中的四个角色<ul><li>client：产生提案者</li><li>peoposer：提案者</li><li>acceptor：决策者</li><li>learners: 学习者（只遵循最后的结果）</li></ul></li><li>paxos分为两个阶段<ul><li>阶段1：prepare阶段：准备解决</li><li>阶段2：accept阶段：同意阶段</li></ul></li><li>prepare阶段<ul><li>proposer做出一个提案，编号为n发送给所有acceptor。</li><li>第一次接受prepare请求：maxN被保存，同时响应</li><li>不是第一次，每个决策者保存一个最大提案号maxN,如果n小于maxN，证明提案已过时，拒绝。如果大于maxN，更新maxN，进行响应。</li><li>如果收到的响应过半，立刻进入第二阶段。</li></ul></li><li>accept阶段<ul><li>传递编号n和value， (n, value)，如果n大于等于maxN,同意提案，进行响应。如果小于，那么拒绝提案，不会响应。</li></ul></li></ul><ol><li> 活锁问题（解决办法，执行时间稍稍错开）</li></ol></li><li><p>zookeeper 使用的是ZAB（Fast Paxos），因为Paxos存在活锁和全序的问题</p></li></ol><ul><li>ZAB（zookeeper atomic broadcast）：是一种支持崩溃恢复的原子广播协议</li><li>Zookeeper使用单一主进程Leader处理客户端发送过来的所有事务请求（写清求）。当服务器数据发生变更后，会把请求包装成提案，发送给所有follower，只要follower达到半数，同意请求，之后leader通知所有follower，进行同步数据。读请求的话，leader会自己响应。</li><li>如果客户端发送到follower上的话，如果是读请求，follwer自己响应，否则是写清求的话，会将请求转发给leader，走leader的流程。</li></ul><ol start="5"><li>zookeeper的三种角色</li></ol><ul><li>leader：主要负责处理集群的写清求，并发起投票，只有超过半数的节点同意后才会提交该写请求</li><li>follower：处理读请求，响应结果。转发写清求得到leader,并在选举leader过程中参与投票。</li><li>observer：可以理解为没有投票权的follower，主要职责是协助follower处理读请求，当整个zk集群读请求负载很高时，增加。如果增加follower会增加写请求负载，因为follower也要投票。</li></ul><ol start="5"><li>zookeeper两种模式</li></ol><ul><li>恢复模式：当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，完成leader和其他机器的同步，当大多数server完成和leader的同步后，恢复模式结束。</li><li>广播模式：一旦leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li><li>在ZAB的事务的二阶段提交中，移除了事务的中断，要么ack，要么放弃，leader无需等待所有的follower的ack.</li></ul><ol start="6"><li>zxid</li></ol><ul><li>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid</li></ul><ol start="7"><li>leader选举原则<ol><li>zookeeper集群只有超过了半数以上的服务器启动，集群才能正常工作</li><li>在集群正常工作之前，myid小的服务器会给myid大服务器进行投票，持续到集群正常工作，选出leader</li><li>选出leader之后，之前的服务器的状态由looking改变为following,之后的服务器都是follower</li></ol></li><li>zab解决全序问题，因为事务执行顺序不同，导致结果不同，leader会创建一个队列，保证最终结果。</li></ol><blockquote><p>相关操作</p></blockquote><blockquote><ol><li>ls path watch 监听节点子节点的变化</li></ol></blockquote><blockquote><ol start="2"><li>get path watch 监听节点值的变化</li></ol></blockquote><blockquote><ol start="3"><li>监听的有效期只有一次</li></ol></blockquote><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h1><ol><li>配置中心</li></ol><ul><li>把配置信息存在节点中，通过监听来同步</li></ul><ol start="2"><li>负载均衡</li></ol><ul><li>新增服务器，让nginx知道服务器列表的更新。通过监听器监视servers子节点的状态变化。</li></ul><ol start="3"><li>命名服务</li></ol><ul><li>创建顺序节点保证唯一标识</li></ul><ol start="4"><li>DNS服务</li><li>集群管理<ol><li>集群控制：对集群中节点进行操作与控制</li><li>集群监控：对集群节点运行状态的收集</li></ol></li></ol><ul><li>zookeeper集群管理主要利用了watcher机制和创建临时节点来实现。比如机器上下线：<ul><li>新增机器的时候，将Agent部署到新增的机器上，当Agent部署启动时，会向zookeeper指定的节点下创建一个临时子节点，通过监视器，对机器的上下线进行监控。</li><li>当子节点创建完成后，机器会接受到”子节点变更事件”，即上限通知，就可以对新加入的机器开启相应的后台管理逻辑。监控中心同样可以获得到机器的运行状态信息。</li></ul></li></ul><ol start="6"><li>分布式锁<ol><li>数据库实现分布式锁，让不同的服务器操作同一个数据库。使用dblock.lock();添加一条记录，lock_name:db_lock_stock。注意这个lock_name是惟一的，如果已经存在，需要阻塞。</li><li>redis实现分布式锁，基于setnx（set if not exists），设置成功返回1，否则返回0.要注意设置过期时间，防止异常，expire name time。redis为了解决单点问题，官方推出了分布式锁redlock</li><li>zookeeper实现分布式锁<ul><li>原理：创建有序临时节点+watch监听来实现。每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己剩下的临时节点的序号是否是最小的。如果是最小的，将会获取到锁，执行相关操作，释放锁。如果不是最小的，会监听它的前一个节点，当它的前一个节点被删除时，它就会获得锁，依次类推。</li></ul></li></ol></li><li>分布式队列：跟分布式锁相似，监听之前的节点是否出列</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-zookeeper&quot;&gt;&lt;a href=&quot;#1-zookeeper&quot; class=&quot;headerlink&quot; title=&quot;1 zookeeper&quot;&gt;&lt;/a&gt;1 zookeeper&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903490196619272">操作系统内存管理</a></p><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">图解内存管理</a>(重点)</p><h1 id="1-存储区体系"><a href="#1-存储区体系" class="headerlink" title="1 存储区体系"></a>1 存储区体系</h1><p>主存（RAM）是一件非常重要的资源，不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多。</p><h2 id="1-1-分层存储器体系-memory-hierarchy"><a href="#1-1-分层存储器体系-memory-hierarchy" class="headerlink" title="1.1 分层存储器体系(memory hierarchy)"></a>1.1 分层存储器体系(memory hierarchy)</h2><p><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/DCDF99335BF54511A72AC2890C6F17FD/14946" alt="存储层次结构"></p><h2 id="1-2-无存储抽象"><a href="#1-2-无存储抽象" class="headerlink" title="1.2 无存储抽象"></a>1.2 无存储抽象</h2><p>将物理内存暴露给进程的缺点：</p><ol><li>如果用户程序可以寻址内存的每个字节，他们就可以很容易的破坏操作系统，从而使系统停止运行。</li><li>难以运行多个程序（地址冲突）</li></ol><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><blockquote><p>MMU(内存管理单元)：硬件组件负责处理CPU的内存访问请求</p></blockquote><h2 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h2><p>更好的支持多道程序并发执行，提高系统性能。进程之间共享的不仅仅是处理机，还有主存储器。如果不对内存进行管理，容易导致内存数据的混乱。</p><h2 id="2-2-内存管理功能"><a href="#2-2-内存管理功能" class="headerlink" title="2.2 内存管理功能"></a>2.2 内存管理功能</h2><ul><li>内存空间的分配与回收</li><li>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</li><li>内存空间的扩充：虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li><li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li><li>程序装入和链接<h2 id="2-3-逻辑地址空间和物理地址空间"><a href="#2-3-逻辑地址空间和物理地址空间" class="headerlink" title="2.3 逻辑地址空间和物理地址空间"></a>2.3 逻辑地址空间和物理地址空间</h2></li><li>编译后，每个目标模块都是从0号单元开始编址（逻辑地址），链接程序顺序依次按各个模块的相对地址构成从0号单元开始编址的逻辑地址空间。</li><li>物理地址空间指内存中物理单元的集合。通过物理地址在主存中存取数据。</li><li>当装入程序将可执行代码装入内存时，必须通过地址转换讲逻辑地址转换成物理地址，这个过程称为地址重定位<h2 id="2-4-内存保护"><a href="#2-4-内存保护" class="headerlink" title="2.4 内存保护"></a>2.4 内存保护</h2></li></ul><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p><ul><li>设置上下限寄存器存放主存中的上下限地址判断是否越界。</li><li>采用重定位寄存器（基址寄存器，存放最小的物理地址值）和界地址寄存器（限长寄存器，存放逻辑地址的最大值）。<h1 id="3-管理方式"><a href="#3-管理方式" class="headerlink" title="3 管理方式"></a>3 管理方式</h1></li></ul><h2 id="3-0-逻辑地址与物理地址的转换"><a href="#3-0-逻辑地址与物理地址的转换" class="headerlink" title="3.0 逻辑地址与物理地址的转换"></a>3.0 逻辑地址与物理地址的转换</h2><ol><li>ALU需要某个逻辑地址的内存的内容</li><li>内存管理单元（MMU）寻找在逻辑地址和物理地址之间的映射，如果没有就从内存中找。（操作系统完成）</li><li>控制器从总线发送在物理内存内容的请求</li><li>内存发送物理地址给CPU</li></ol><h2 id="3-1-连续分配管理方式"><a href="#3-1-连续分配管理方式" class="headerlink" title="3.1 连续分配管理方式"></a>3.1 连续分配管理方式</h2><ol><li>单一连续分配：分配到内存固定区域，只适合单任务系统</li><li>固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不相等。内部碎片（已经被分配出去（能明确是哪个线程），却不能被利用的内存空间）<ul><li>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</li></ul></li><li>动态分区分配：按程序的需要进程动态划分。外部碎片（还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。）<ul><li>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br><a href="https://www.cnblogs.com/sjlove/archive/2013/06/05/3119683.html">外部碎片和内部碎片</a><h2 id="3-2-空闲内存管理"><a href="#3-2-空闲内存管理" class="headerlink" title="3.2 空闲内存管理"></a>3.2 空闲内存管理</h2>在进行内存动态分配时，操作系统必须对其进行管理。一般来说，有两种监控内存使用的方式</li></ul></li></ol><ul><li>位图（bitmap）（基于表的）：使用位图方法时，内存被划分为分配单元，每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。位图的大小取决于内存和分配单元的大小。</li><li>位图的分配：找到连续的0。</li><li>空闲列表（free lists）（基于链的）：维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点会包含进程或者是两个进程间的空闲区域。</li><li>空闲列表的分配：（动态分区分配算法）<br><br>(如果为进程和空闲区维护各自独立的链表，就能集中精力只检查空闲区而不是进程，但这种分配速度的提高的一个不可避免的代价就是增加复杂度和内存释放速度变慢，因为必须将一个回收的段从进程链表中删除并插入空闲区链表)<ol><li>首次适配：从头开始扫描，直到找到一个足够大的空闲区</li><li>下次适配：从上次结束的地方开始扫描</li><li>最佳适配：从头到尾扫描，找到能容纳进程的最小空闲区。会产生大量无用的小缓冲区。</li><li>最差适配：总是分配最大的内存区域（不会分裂出小缓冲区）</li><li>快速适配：为常用大小的空闲区维护单独的链表。<br>[位图和空闲链表]<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">https://blog.csdn.net/qq_22238021/article/details/80175461</a>)</li></ol></li></ul><h2 id="3-3-非连续分配管理方式"><a href="#3-3-非连续分配管理方式" class="headerlink" title="3.3 非连续分配管理方式"></a>3.3 非连续分配管理方式</h2><p>对于内存的连续分配，总是会有碎片的产生，内存利用率低，而且执行碎片整理的方法也都是有开销的。因此，非连续内存分配就能很好的解决碎片问题，也是操作系统中用的最多的内存分配方法。<br>非连续分配（分页/分段）允许一个程序分散地装入到不相邻的内存分区中去。</p><h3 id="3-3-1-基本分页存储管理方式"><a href="#3-3-1-基本分页存储管理方式" class="headerlink" title="3.3.1 基本分页存储管理方式"></a>3.3.1 基本分页存储管理方式</h3><p><a href="https://zhuanlan.zhihu.com/p/87514615">分页分段解释较好</a></p><p>内存分为固定的块，按物理结构划分，会有内部碎片</p><ol><li>基本概念<ul><li>页<ul><li>一定大小字节数内存单元，属于逻辑单元。进程中所有代码、数据等信息均按页进行存储，属于逻辑组织形式。每个页有页码及其他信息。</li></ul></li><li>页框<ul><li>对应页字节数的物理内存，属于物理单元，是实际存在于物理内存中的可用地址单元。页框相当于页的容器，进程运行过程中，可能会动态加载不同页进入页框，CPU则直接对页框进行存取。</li></ul></li><li>页表<ul><li>既然有页和对应页框，那就必须有映射表将两者联系起来，而页表就是页和页框之间的映射表。换言之，知道页就可以查询到页框，知道页框，也可以查询到对应页。</li></ul></li><li>进程中的块称为页，内存中的块称为页框，外存以同样的单位进行划分，称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框。</li><li>地址结构 页号 + 页内偏移量</li><li>页表 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建3立一张页表，记录页面在内存中对应的物理块号。页表一般放在内存中。</li></ul></li><li>基本地址变换机构<br><br>页式管理中地址空间是一维的<br><br>两个主要问题：<ul><li>每次访问操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低</li><li>每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li></ul></li><li>具有快表的地址变换机构</li></ol><ul><li>若页表全部放在内存中，则存取一条数据或指令至少需要访问两次内存：一次访问页表，确定物理地址，第二次存取数据或指令</li><li>快表/联想寄存器/TLB 在地址变换机构中的一个具有并行查找能力的高速缓冲存储器。用来存放当前访问的若干页表项，以加速地址变换的过程。主存中的页表称为慢表。</li></ul><ol start="4"><li>两级页表<br><br>一级页号+二级页号+页内偏移</li><li>分页和分段的区别<ul><li>页是信息的物理单位，分页是为了减少内存碎片，提高内存利用率。分页仅仅是由于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它包含一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统确定，逻辑地址的划分是由寄存器实现的，因而一个系统只能有一种大小的页面。段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<h3 id="3-3-2-基本分段存储管理模式"><a href="#3-3-2-基本分段存储管理模式" class="headerlink" title="3.3.2 基本分段存储管理模式"></a>3.3.2 基本分段存储管理模式</h3></li></ul></li></ol><p>内存块的大小不固定，按逻辑结构划分，会有外部碎片。</p><h1 id="4-内存扩充"><a href="#4-内存扩充" class="headerlink" title="4 内存扩充"></a>4 内存扩充</h1><h2 id="4-1-覆盖"><a href="#4-1-覆盖" class="headerlink" title="4.1 覆盖"></a>4.1 覆盖</h2><p>在较小的内存中运行较大的内存，将没有调用关系的程序放在一个分区。可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分里即将访问的段放进覆盖区，其他段放在外存。<br><img src="http://note.youdao.com/yws/public/resource/375267987e6a5e59121a79328ccdf2bc/xmlnote/BE6AB4C1E94E42FD8718721D3956E4C3/15170"><br>B，D，E没有调用关系，也就是说，在调用B时，不可能同时调用D或E，所以共享一个覆盖区。早期用这个技术来节约内存。</p><h2 id="4-2-交换"><a href="#4-2-交换" class="headerlink" title="4.2 交换"></a>4.2 交换</h2><p>将暂时不能运行的程序送到外存，从而获得空闲内存空间。粒度是一个程序，需要操作系统支持，对程序员透明。</p><p>把处于等待状态的程序从内存移到辅存，把内存空间腾出来（换出）。把准备好竞争CPU运行的程序从辅存移到内存（换入）</p><ol><li>覆盖与交换的比较<ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间。</li><li>交换技术是在以内存中的程序大小为单位来进行的，一般一页以上。不需要程序员给出各个模块之间的逻辑覆盖结构。</li><li>覆盖和交换都有它的局限性，覆盖过于麻烦，而交换的粒度太大，以程序为单位。所以需要虚拟内存技术。</li></ul></li></ol><h2 id="4-3-虚拟内存"><a href="#4-3-虚拟内存" class="headerlink" title="4.3 虚拟内存"></a>4.3 虚拟内存</h2><p>随着软件的不断增大，需要运行的程序往往大到内存无法容纳。应用交换技术并不是很高效（交换几GB的内存）。</p><p>虚拟内存使用了外存上的空间来扩充内存的空间，通过一定的换入换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，导致平均访存时间下降，如果使用了不合适的替换算法，则会<br>大大降低系统性能。</p><ul><li>虚拟存储器：对物理存储器的抽象，允许程序申请大于实际物理存储的内存，提供一致性的地址空间。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统讲所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放要掉入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</li><li>内存管理单元（Memory Management Unit， MMU），MMU把虚拟地址映射为物理内存地址。</li></ul><h3 id="4-3-1-局部性原理"><a href="#4-3-1-局部性原理" class="headerlink" title="4.3.1 局部性原理"></a>4.3.1 局部性原理</h3><ul><li>时间局部性：如果一条指令被执行或某个数据被访问过，那么不久以后该指令可能再次执行，该数据可能再次被访</li><li>空间局部性：如果某个单元被访问过，那么不久之后它周围的空间也会被访问。<h3 id="4-3-2-特征"><a href="#4-3-2-特征" class="headerlink" title="4.3.2 特征"></a>4.3.2 特征</h3></li></ul><ol><li>多次性， 无需在作业时一次性全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性，无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出</li><li>虚拟性，从逻辑上扩充内存的容量，用户看到的内存容量，远大于实际的内存容量<h3 id="4-3-3-虚拟技术内存的实现"><a href="#4-3-3-虚拟技术内存的实现" class="headerlink" title="4.3.3 虚拟技术内存的实现"></a>4.3.3 虚拟技术内存的实现</h3></li><li>一定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序访问到的部分尚未调入内存，则产生中断</li><li>地址变换机构，逻辑地址到物理地址的变换</li></ol><h3 id="4-3-4-请求分页管理方式"><a href="#4-3-4-请求分页管理方式" class="headerlink" title="4.3.4 请求分页管理方式"></a>4.3.4 请求分页管理方式</h3><ol><li>页表机制</li></ol><ul><li>页号</li><li>物理块号</li><li>保护位：允许对该页做何种类型的访问（只读、可读写、）</li><li>驻留位：指示该页在内存还是在外存</li><li>访问字段A：记录本页在一段时间内被访问的次数，或多长时间未被访问（用于页面置换算法）</li><li>修改位M：标识该页在调入内存后收否被修改过</li><li>外存地址：该页在外存上的地址</li></ul><ol start="2"><li>缺页中断机构</li></ol><ul><li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成时唤醒），如果内存中有空闲块则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页。（若被淘汰页在内存期间被修改过，则要将其写回外存）</li></ul><ol start="3"><li>地址变换机构<br><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/8E649EF21B8F4CDCB559DDDAE97F147E/15122"></li></ol><h3 id="4-3-5-页面置换算法（决定应该换入哪页，换出哪页）"><a href="#4-3-5-页面置换算法（决定应该换入哪页，换出哪页）" class="headerlink" title="4.3.5 页面置换算法（决定应该换入哪页，换出哪页）"></a>4.3.5 页面置换算法（决定应该换入哪页，换出哪页）</h3><ol><li>最佳置换算法（OPT）：选择在最长时间内不在被访问的页面换出。实际上该算法无法使用</li><li>先进先出（FIFO）页面置换算法：淘汰最早进入内存的页面</li><li>最近最久未使用（LRU）置换算法：选择最长时间未访问的页面淘汰需要TLB实现（硬件支持 双向链表+hash</li><li>时钟（CLOCK）（Not Recently Used，NRU）置换算法：循环扫描缓冲区，像时钟的针一样转动。给每一帧关联一个使用位。当缺页错误出现时，首先检查指针指向的页面，如果R位是0就淘汰页面，并把新页面插入，然后表针前移；如果R位是1就清零前移。和第二次算法性能差不多，花费更少时间，实际使用的算法.</li><li>工作集置换算法，一个进程当前使用的页面的集合称为工作集。</li><li>工作集时钟页面置换算法</li><li>LFU（ Least Frequently Used，最不频繁使用）两个双向链表+hash</li><li>第二次机会页面置换算法：在FIFO基础上增加使用位，如果链首使用位是1则清零加入链尾。相比FIFO性能大大提高</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903490196619272&quot;&gt;操作系统内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_29677867/article/details/91038</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统常见问题</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同步和异步的区别"><a href="#1-同步和异步的区别" class="headerlink" title="1 同步和异步的区别"></a>1 同步和异步的区别</h1><p>同步和异步通常用来形容一次方法调用</p><ul><li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li><li>异步方法调用更像一个消息传递，一旦开始，方法调用就回立即返回，调用者就可以继续后续的操作。异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。<h1 id="2-进程和线程的区别，谁调度的进程"><a href="#2-进程和线程的区别，谁调度的进程" class="headerlink" title="2 进程和线程的区别，谁调度的进程"></a>2 进程和线程的区别，谁调度的进程</h1></li></ul><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、数据段和堆栈段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的话费远比进程要小很多，同时创建一个线程的开销也比进程小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。但是如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。<h1 id="3-死锁的条件，如何检查死锁"><a href="#3-死锁的条件，如何检查死锁" class="headerlink" title="3 死锁的条件，如何检查死锁"></a>3 死锁的条件，如何检查死锁</h1></li></ol><ul><li>死锁的定义： 多个进程因为竞争资源而造成一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</li><li>死锁的必要条件：互斥、不剥夺、请求和保持、循环等待</li><li>解决死锁：破坏条件，资源剥夺、撤销进程，进程回退</li><li>用银行家算法预防和避免死锁。</li></ul><h1 id="4-调度算法有哪些"><a href="#4-调度算法有哪些" class="headerlink" title="4 调度算法有哪些"></a>4 调度算法有哪些</h1><p>先来先服务、最短寻道时间、扫描算法、Look算法</p><h1 id="5-进程的状态转换图及转换事件"><a href="#5-进程的状态转换图及转换事件" class="headerlink" title="5 进程的状态转换图及转换事件"></a>5 进程的状态转换图及转换事件</h1><h1 id="6-进程的通信机制"><a href="#6-进程的通信机制" class="headerlink" title="6 进程的通信机制"></a>6 进程的通信机制</h1><p>临界区、互斥量、信号量、事件</p><p>管道、具名管道、消息队列、共享内存、信号量</p><ul><li>管道： 父子进程通过管道通信，管道是一种两个进程间单向通信的机制，因为管道传递数据的单向性，管道又被称为半双工管道，管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。（没有名字、大小受限、没有格式的字节流）</li><li>具名管道：FIFO，提供一个路径名与之关联，存在与文件系统中，这样即使与创建FIFO的进程不存在亲缘关系的进程，只要可以访问路径，就能够通过彼此的FIFO通信。因此，通过FIFO不相关进程也能交换数据</li><li>消息队列：消息队列用与同一机器上的进程间通信，与管道类似，是一个系统内核中保存消息的队列，在内核中以消息链表的形式出现。消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。</li><li>共享内存：共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的程序间共享和传递数据的一种非常有效的方式。不同进程间的内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的内存空间中，所有进程都可以访问共享内存中的地址。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及统一进程内不同线程之间的同步手段。</li></ul><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">内存管理</a></p><p><a href="https://blog.csdn.net/qq_43684985/article/details/109255207">文件管理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-同步和异步的区别&quot;&gt;&lt;a href=&quot;#1-同步和异步的区别&quot; class=&quot;headerlink&quot; title=&quot;1 同步和异步的区别&quot;&gt;&lt;/a&gt;1 同步和异步的区别&lt;/h1&gt;&lt;p&gt;同步和异步通常用来形容一次方法调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步方法调用一</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="http://example.com/2021/02/27/Http/"/>
    <id>http://example.com/2021/02/27/Http/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http1-0和Http1-1"><a href="#Http1-0和Http1-1" class="headerlink" title="Http1.0和Http1.1"></a>Http1.0和Http1.1</h1><ol><li>http1.0</li></ol><ul><li>客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li><li>浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接</li></ul><ol start="2"><li>http1.1</li></ol><ul><li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用：HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来，HTTP1.1在请求头引入range头域，它允许只请求资源的某个部分，即返回码是206.</li><li>错误通知管理：在HTTP1.1中新增了24个错误状态响应码。</li><li>Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。</li><li>长连接</li></ul><ol start="3"><li>HTTPS</li></ol><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><ol start="4"><li>spdy（http1.x改进）</li></ol><ul><li>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。<ol><li>使用多路复用，（多个请求共用一个tcp），降低了延迟</li><li>允许对多个请求设置优先级</li><li>header进行压缩</li><li>基于https</li></ol></li></ul><ol start="2"><li>http2.0<ol><li>http2.0与spdy区别</li></ol><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 HPACK <a href="http://http2.github.io/http2-spec/compression.html%EF%BC%8C%E8%80%8C%E9%9D%9E">http://http2.github.io/http2-spec/compression.html，而非</a> SPDY 采用的 DEFLATE <a href="http://zh.wikipedia.org/wiki/DEFLATE">http://zh.wikipedia.org/wiki/DEFLATE</a></li></ul><ol start="2"><li>其余改进与spdy差别不大</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Http1-0和Http1-1&quot;&gt;&lt;a href=&quot;#Http1-0和Http1-1&quot; class=&quot;headerlink&quot; title=&quot;Http1.0和Http1.1&quot;&gt;&lt;/a&gt;Http1.0和Http1.1&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;http1.0&lt;/li&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据链路层"><a href="#1-数据链路层" class="headerlink" title="1 数据链路层"></a>1 数据链路层</h1><p>数据链路层协议规定了通过信息通信媒介互联的设备之间传输的规范。0，1等计算机二进制 -&gt; 电压高低，光的闪灭以及电波强弱。</p><p>链路层的主体部分是在网络适配器（Network adapter）中实现的，网络适配器有时也称为网络接口卡（Network Interface Card， NIC）</p><ol><li>MAC地址 （Medium Access Control）<br>用于识别数据链路中互连的节点。长48比特。不会重复。</li></ol><h1 id="2-Web页面请求的历程"><a href="#2-Web页面请求的历程" class="headerlink" title="2. Web页面请求的历程"></a>2. Web页面请求的历程</h1><h2 id="2-1-DHCP、UDP、IP和以太网（找本机IP）"><a href="#2-1-DHCP、UDP、IP和以太网（找本机IP）" class="headerlink" title="2.1 DHCP、UDP、IP和以太网（找本机IP）"></a>2.1 DHCP、UDP、IP和以太网（找本机IP）</h2><ol><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67（DHCP服务器）和源端口68（DHCP客户）的UDP报文段中。</li><li>该报文段被放入一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0)的IP数据报中，因为主机还没有一个IP地址。</li><li>该IP数据报被放置在以太网帧中，该MAC帧具有目的MAC地址（FF:FF:FF:FF:FF:FF),将该帧广播到交换机连接的所有设备(顺利的话也包括DHCP服务器)；该帧的源MAC地址时主机的MAC地址。</li><li>该帧是第一个由主机发送到以太网交换机中的帧。该交换机在所有的出端口广播入帧。</li><li>DHCP服务器的接口受到该帧，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址（CIDR分配策略），DNS服务器的IP地址、默认网关路由器的IP地址、子网掩码。将DHCP的ACK报文放入UDP报文段中，UDP报文段被放入IP数据报中，IP数据报在被放入一个以太网帧中。源MAC地址是服务器接口的MAC地址，目的MAC地址是主机MAC地址。</li><li>以太网帧发送到交换机中，由于交换机是自学习的（记录每个接口对应的MAC地址），并且受到过主机的以太网帧，所以交换机仅向主机接口转发该帧。</li><li>主机收到帧后，提取出IP数据报，取出UDP报文段，取出ACK报文。DHCP客户端记录下他的IP地址和他的DNS服务器的IP地址。并在IP转发表中安装默认网关的地址，主机会向网关发送目的地址为其子网以外的所有数据报。</li></ol><h2 id="2-2-DNS、ARP（找网关MAC地址"><a href="#2-2-DNS、ARP（找网关MAC地址" class="headerlink" title="2.2 DNS、ARP（找网关MAC地址)"></a>2.2 DNS、ARP（找网关MAC地址)</h2><ol start="8"><li>主机会通过浏览器生成一个TCP套接字，用于向网站发送HTTP请求，但是需要知道网站的IP地址。</li><li>主机的操作系统生成一个DNS查询报文，将网站的域名放入DNS报文的问题段中。将该报文放入一个目的端口号为53（DNS服务器）的UDP报文段中。该报文段被放入IP目的地址为DNS服务器，源地址为主机IP地址的IP数据报中。</li><li>数据报会放入到以太网帧中。该帧将发送到网关路由器。但是主机通过DHCP过程只知道网关路由器的IP地址，不知道网关路由器的MAC地址。为了获取网关的MAC地址，需要使用ARP协议。</li><li>主机生成一个具有目的IP地址为网关IP的ARP查询报文。放入到一个具有广播地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送这个广播帧，交换机将帧发送给所有连接的设备，包括网关路由器。</li><li>网关在收到该帧后，发现目标IP与自己IP匹配，所以要发送一个ARP回答，指示自己的MAC地址对应自己的IP地址。将ARP回答放入以太网帧中，目的地址为主机的MAC地址，向交换机发送该帧，由交换机发送给主机。</li><li>主机收到该帧并抽取网关路由器的MAC地址，继续DNS解析过程。</li><li>将包含DNS查询报文的数据报放入目的地址为网关MAC地址的以太网帧中，通过交换机发送给网关路由器。主机报文的IP目的地址是DNS服务器，MAC目的地址是网关服务器。</li><li>网关接收到DNS查询的IP数据报后，根据IP数据报的目的地址选择转发给响应的路由器。</li><li>路由器收到IP数据报后，根据目的地址和转发表确定出接口，根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项（路由选择）。</li><li>DNS服务器收到数据报后，抽取DNS查询报文。并在DNS库中查找域名。</li><li>找到包含对应域名的IP地址的DNS源记录后，向主机发送一个包含域名到IP地址映射的DNS回答报文，将该DNS回答报文放入UDP报文段、IP数据报中，通过路由器反转发给网关路由器，经过交换机到主机。</li><li>主机从报文中抽取服务器的IP地址。<h2 id="2-3-TCP、HTTP"><a href="#2-3-TCP、HTTP" class="headerlink" title="2.3 TCP、HTTP"></a>2.3 TCP、HTTP</h2></li><li>有了服务器的IP地址之后，便生成TCP套接字，用该套接字向服务器发送HTTP GET报文。</li><li>建立HTTP连接需要进行TCP连接，进行三次握手</li><li>建立连接后发送HTTP的GET报文，将报文放入TCP报文段的载荷中，然后生成IP数据报送往服务器。</li><li>服务器从TCP套接字中读取报文，生成HTTP响应报文，将页面内容放入HTTP响应体中，发送到主机。</li><li>浏览器收到HTTP响应报文后抽取Web页面内容进行渲染，显示web页面。<h1 id="3-DNS查询顺序"><a href="#3-DNS查询顺序" class="headerlink" title="3. DNS查询顺序"></a>3. DNS查询顺序</h1></li><li>浏览器首先搜索浏览器自身缓存的DNS记录。</li><li>如果浏览器缓存中没有找到需要的记录或记录已经过期，则搜索hosts文件和操作系统缓存。</li><li>如果在hosts文件和操作系统缓存中没有找到需要的记录或记录已经过期，则向域名解析服务器发送解析请求。</li><li>如果域名解析服务器也没有该域名的记录，则开始递归+迭代解析。</li><li>获取域名对应的IP后，一步步向上返回，直到返回给浏览器。<h1 id="4-相关问题"><a href="#4-相关问题" class="headerlink" title="4 相关问题"></a>4 相关问题</h1><h2 id="4-1-为什么有了-MAC-地址还要-IP-地址，IP-地址和-MAC-地址的区别是什么"><a href="#4-1-为什么有了-MAC-地址还要-IP-地址，IP-地址和-MAC-地址的区别是什么" class="headerlink" title="4.1 为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么"></a>4.1 为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么</h2></li><li>整体与局部信息传递时候，需要知道的其实是两个地址：终点地址（Final destination address）下一跳的地址（Next hop address）IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。</li><li>分层实现如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的二层交换机不支持这样做），其实MAC地址并不是必要的。但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。这就像OSI七层模型，TCP/IP五层模型其实也不是必要的，用双层模型甚至单层模型实现网络也不是不可以的，只是那样做很蛋疼罢了。</li><li>早期的『以太网』实现早期的以太网只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。</li><li>MAC地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li></ol><p>区别：</p><ul><li>MAC地址是物理地址，IP地址是逻辑地址。就是说MAC地址是不可改变的，IP地址是可以更改的；</li><li>MAC地址具有唯一性，每个硬件出厂时候的MAC地址是固定的；IP地址不具备唯一性，因此，很多应用软件是围绕MAC地址开发的。</li><li>工作层次不同<ul><li>二层基于MAC地址转发数据帧，三层基于IP地址转发报文。二层交换机基于MAC地址表转发数据，路由器基于路由表（IP地址）转发数据。</li></ul></li><li>长度定义<ul><li>MAC地址是Ethernet网卡上带的地址，长度为48位；IP地址目前主流是32位长。IP地址和MAC地址通过ARP协议联系到一起。<h2 id="4-2-如何理解广播域和冲突域（冲突域和广播域）"><a href="#4-2-如何理解广播域和冲突域（冲突域和广播域）" class="headerlink" title="4.2 如何理解广播域和冲突域（冲突域和广播域）"></a>4.2 如何理解广播域和冲突域（<a href="https://blog.csdn.net/u011228842/article/details/91410867">冲突域和广播域</a>）</h2></li></ul></li></ul><ol><li>冲突域：<ul><li>【定义】在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</li><li>【分层】基于OSI的第一层物理层</li><li>【设备】第二层设备能隔离冲突域，比如Switch。交换机能缩小冲突域的范围，交换接的每一个端口就是一个冲突域。</li></ul></li><li>广播域：<ul><li>【定义】网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</li><li>【分层】基于OSI的第二层数据链路层</li><li>【设备】第三层设备才能隔离广播域，比如Router。路由器能隔离广播域，其每一个端口就是一个广播域。<h2 id="4-3-路由器和交换机有什么区别？"><a href="#4-3-路由器和交换机有什么区别？" class="headerlink" title="4.3 路由器和交换机有什么区别？"></a>4.3 路由器和交换机有什么区别？</h2></li></ul></li><li>工作层次不同：<ul><li>交换机主要工作在数据链路层（第二层）</li><li>路由器工作在网络层（第三层）。</li></ul></li><li>转发依据不同：<ul><li>交换机转发所依据的对象时：MAC地址。（物理地址）</li><li>路由转发所依据的对象是：IP地址。（网络地址）</li></ul></li><li>主要功能不同：<ul><li>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。</li><li>交换机能做的，路由都能做。交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据链路层&quot;&gt;&lt;a href=&quot;#1-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;1 数据链路层&quot;&gt;&lt;/a&gt;1 数据链路层&lt;/h1&gt;&lt;p&gt;数据链路层协议规定了通过信息通信媒介互联的设备之间传输的规范。0，1等计算机二进制 -&amp;gt; 电压</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://example.com/2021/02/27/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/02/27/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_43684985/article/details/109255207">王道操作系统、文件管理</a></p><h1 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1 文件系统"></a>1 文件系统</h1><p>磁盘的0号分区称为主引导记录（Master Boot Record，MBR），用来引导计算机。在MBR的结尾是分区表。每个分区表给出每个分区又开始到结束的地址。<br><img src="http://note.youdao.com/yws/public/resource/375267987e6a5e59121a79328ccdf2bc/xmlnote/98C0270828214E36BD23ECEFF02FA1EF/15185"></p><h2 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h2><p>MBR做的第一件事就是确定活动分区，读入它的第一个块，称为引导块并执行。引导块中的程序将加载分区中的操作系统。</p><ul><li>为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统</li><li>引导块占据文件系统的前4096个字节，从磁盘上的字节偏移量0开始</li><li>引导块可用于启动操作系统</li></ul><blockquote><p>在计算机中，引导就是启动计算机的过程。开机后，CPU还不能执行指令，因为此时没有软件在主存中，所以一些软件必须先被加载到内存中。然后才能让CPU开始执行。</p></blockquote><h2 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h2><p>4096字节，包含文件系统的所有关键参数</p><ul><li>文件系统的大小</li><li>文件系统中的数据块数</li><li>指示文件系统状态的标志</li><li>分配组大小</li></ul><h2 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h2><p>文件系统中的空闲块</p><h2 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h2><p>也叫片段。零散的单个数据称为片段。</p><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>索引节点。每个文件有一个inode。<br>inode主要包括一下信息：</p><ul><li>模式/权限（保护）</li><li>所有者ID</li><li>组ID</li><li>文件大小</li><li>文件的硬链接数</li><li>上次访问时间</li><li>最后修改时间</li><li>inode上次修改时间</li></ul><h1 id="磁盘组织和管理"><a href="#磁盘组织和管理" class="headerlink" title="磁盘组织和管理"></a>磁盘组织和管理</h1><ul><li>磁盘调度算法</li></ul><ol><li>先来先服务（FCFS）</li><li>最短寻道时间优先（SSTF）</li><li>扫描算法</li><li>Look调度算法</li></ol><p><a href="https://blog.csdn.net/qq_40949465/article/details/89035171">磁盘组织和管理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_43684985/article/details/109255207&quot;&gt;王道操作系统、文件管理&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-文件系统&quot;&gt;&lt;a href=&quot;#1-文件系统&quot; class=&quot;header</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://example.com/2021/02/27/%E6%AD%BB%E9%94%81/"/>
    <id>http://example.com/2021/02/27/%E6%AD%BB%E9%94%81/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>多个进程因为竞争资源造成的一种僵局（互相等待）</p><h2 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h2><ul><li>互斥条件： 进程要求对所分配的资源进行排他性控制，在一段时间内资源仅为一个进程所有。</li><li>不可剥夺条件：进程所获得资源未使用完毕之前，不能被其他进程强行夺走，只能等获得资源的进程自己主动释放。</li><li>请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，而该资源已被其他进程占有。此时进程被阻塞，但是对自己资源不释放。</li><li>循环等待条件：存在某一进程的循环等待链，链中每个进程已获得的资源同时被链中下一个进程的请求。</li></ul><h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><p>死锁的处理便是破坏四个必要条件，使得死锁无法发生</p><h3 id="1-鸵鸟策略"><a href="#1-鸵鸟策略" class="headerlink" title="1 鸵鸟策略"></a>1 鸵鸟策略</h3><p>把头埋在沙子里，假装问题没有发生</p><p>由于解决死锁问题的代价往往很高，鸵鸟策略在很多情况下可以取得更高的性能</p><p>大多数操作系统，Unix、Linux、windows处理死锁都是采用鸵鸟策略</p><h3 id="2-死锁预防"><a href="#2-死锁预防" class="headerlink" title="2 死锁预防"></a>2 死锁预防</h3><ol><li>破坏互斥条件：对于可共享的资源竞争，不会发生死锁</li><li>破坏不剥夺条件：当一个进程无法获取其需要的资源时，将之前已获得的资源释放，待需要时在重新申请</li><li>破坏请求和保持条件：预先分配的静态方法，在进程运行前一次申请完它需要的所有资源。在资源不满足前不运行，一旦运行这些资源都归其所有。</li><li>破坏循环等待：资源顺序分配法，为资源编号，每个进程申请分配某个资源后，再之后只能申请该编号以后的资源</li></ol><h3 id="3-死锁避免"><a href="#3-死锁避免" class="headerlink" title="3 死锁避免"></a>3 死锁避免</h3><ol><li>系统的安全状态：所谓安全状态，是系统能按照某种进程推进顺序（P1，P2，，）为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个系统进程都能顺序完成，则（P1，P2，，）称为安全序列，如果无法找到安全序列，则系统处于不安全状态。</li><li>允许进程池动态的申请资源，但是每次分配资源前系统都会计算资源分配的安全性，如果分配资源不会导致系统进入不安全状态，将资源分配给进程；否则进程等待。</li></ol><ul><li>银行家算法是最著名的死锁避免算法。他的思想是把操作系统看成银行家，操作系统管理的资源当成银行家管理的资金，向操作系统请求资源相当于向银行请求贷款 </li><li>进程请求资源时，系统评估该进程的最大需求资源，检查资源分配后系统是否还处于安全状态，由此来决定是否分配该资源。也就是进程需求的资源数《=剩余的资源数才是安全序列。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/59533950">银行家算法死锁避免</a></p><h3 id="4-死锁的检测和接触"><a href="#4-死锁的检测和接触" class="headerlink" title="4 死锁的检测和接触"></a>4 死锁的检测和接触</h3><ol><li>死锁检测</li></ol><ul><li>死锁定理：可以通过资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：<ul><li>在资源分配图中，找到既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的节点。在这里要注意一个问题，判断某种资源是否空闲，应该用它的资源数量减去它在资源分配图中的出度。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可以变为非阻塞进程。根据1中的方法进行一系列简化后，若能消去图中所有的边，则称改图是可完全简化的。</li></ul></li></ul><p>S为死锁的条件是：当且仅当S状态的资源分配图是不可完全简化的，该条件为死锁定理</p><p><a href="https://blog.csdn.net/u011240016/article/details/53305118">详细解释死锁定理</a><br>2. 死锁解除<br>    - 资源剥夺法：挂起死锁进程，抢占其资源分配给其他进程<br>    - 销进程法：强制撤销一些死锁进程<br>    - 进程回退法：借助历史信息使一个或多个进程回退到系统不在死锁的地步</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;p&gt;多个进程因为竞争资源造成的一种僵局（互相等待）&lt;/p&gt;
&lt;h2 id=&quot;死锁的四个必要条件&quot;&gt;&lt;a href=&quot;#死锁的四个必要条件&quot; cl</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>知识点</title>
    <link href="http://example.com/2021/02/27/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2021/02/27/%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-rpc和http的区别"><a href="#1-rpc和http的区别" class="headerlink" title="1 rpc和http的区别"></a>1 rpc和http的区别</h1><blockquote><p>http是指从客户端到服务器端的请求消息，rpc是远程过程调用协议。</p></blockquote><ol><li>rpc和http的区别</li></ol><ul><li>http请求是使用具有标准语义的通用的接口定向到资源，这些语义能够被中间组件和提供服务的来源机器进行解释。</li><li>rpc是根据语言的API来定义的，不是根据基于网络的应用来定义的。</li><li>rpc是基于tcp/ip的，rpc将原来的本地调用转变为调用远端的服务器上的方法。步骤如下：<ul><li>客户端以本地调用方式调用接口</li><li>客户端存根接受到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息对象序列化为二进制）；</li><li>客户端通过sockets将消息发送到服务端</li><li>服务端存根（server stub）收到消息后进行解码（将消息对象反序列化）；</li><li>服务端存根（server stub）根据解码结果调用本地的服务；</li><li>本地服务执行并将结果放回给服务端存根（server stub）；</li><li>服务端存根（server stub）将返回结果打包成消息（将结果消息对象序列化）；</li><li>服务端（server）通过sockets将消息发送到客户端</li><li>客户端存根（client stub）接手到结果消息，并进行解码（将结果消息发序列化）；</li><li>客户端最终得到结果</li></ul></li></ul><ol start="2"><li>传输协议对比</li></ol><ul><li>rpc可以基于tcp协议，也可以基于HTTP协议。基于HTTP协议</li></ul><ol start="3"><li>传输效率</li></ol><ul><li>rpc使用自定义的tcp协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率。</li><li>http:如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用，这时标准RPC框架更多的是服务治理。</li></ul><ol start="4"><li>性能消耗</li></ol><ul><li>RPC：可以基于thrift实现高效的二进制传输</li><li>HTTP：大部分是通过json来实现的，字节大小和序列化耗时都比thrift更消耗性能</li></ul><ol start="5"><li>负载均衡</li></ol><ul><li>RPC: 基本都自带了负载均衡策略</li><li>HTTP：需要配置nginx，HAProxy来实现</li></ul><ol start="6"><li>总结</li></ol><ul><li>RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。</li><li>HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-rpc和http的区别&quot;&gt;&lt;a href=&quot;#1-rpc和http的区别&quot; class=&quot;headerlink&quot; title=&quot;1 rpc和http的区别&quot;&gt;&lt;/a&gt;1 rpc和http的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;http是指从客户端到服务</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安全通信"><a href="#1-安全通信" class="headerlink" title="1 安全通信"></a>1 安全通信</h1><ol><li>机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密</li><li>报文完整性（message integrity） 确保没有被改动</li><li>端点鉴别（end-point authentication） 确定通信双方</li><li>运行安全性（operational security）</li></ol><h1 id="2-对称加密和非对称加密"><a href="#2-对称加密和非对称加密" class="headerlink" title="2 对称加密和非对称加密"></a>2 对称加密和非对称加密</h1><ol><li>对称加密<br><br>加密过程：<br><br> 加密：原文 + 密匙 = 密文<br><br> 解密：密文 - 密匙 = 原文</li><li>非对称加密<br>使用不同的密钥进行加密和解密，对原文使用公钥加密，则只能使用对应的私钥才能解密。</li></ol><h1 id="3-Diffie-Hellman密钥交换算法"><a href="#3-Diffie-Hellman密钥交换算法" class="headerlink" title="3 Diffie-Hellman密钥交换算法"></a>3 Diffie-Hellman密钥交换算法</h1><ol><li>Alice 和 Bob 协商出两个数字 N 和 G 作为生成元</li><li>现在 Alice 和 Bob 心中各自想一个数字出来，分别称为 A 和 B</li><li>现在 Alice 将自己心里的这个数字 A 和 G 通过某些运算得出一个数 AG，然后发给 Bob；Bob 将自己心里的数 B 和 G 通过相同的运算得出一个数 BG，然后发给 Alice</li><li>Alice 可以通过 BG 和自己的 A 通过某些运算得到一个数 ABG，Bob 也可以通过 AG 和自己的 B 通过某些运算得到 ABG，这个数就是 Alice 和 Bob 共有的秘密</li></ol><h1 id="4-公开密钥加密"><a href="#4-公开密钥加密" class="headerlink" title="4 公开密钥加密"></a>4 公开密钥加密</h1><p>公钥用于加密，私钥用于解密。（RSA）</p><p>但是非对称加密算法无法确定通信双方的身份，会遭到中间人的攻击。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。</p><p>也就是你不知道你收到的公钥是不是伪造者发出的</p><h1 id="5-报文完整性和数字签名"><a href="#5-报文完整性和数字签名" class="headerlink" title="5 报文完整性和数字签名"></a>5 报文完整性和数字签名</h1><h2 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h2><p>有两种攻击：1 针对被动攻击 ( 截获 ) : 加密 ;<br>2 针对主动攻击 ( 篡改 , 伪造 ) : 需要使用 鉴别 ;</p><p>密码散列函数的附加性质：找到任意两个不同的报文x和y使得<code>$H(x)=H(y)$</code>,在计算上是不可能的。</p><p>报文鉴别码：</p><ol><li>Alice生成报文m并计算散列<code>$H(m)$</code></li><li>然后Alice将<code>$H(m)$</code>附加到报文m上，生成一个扩展报文（m, H(m)),并将该扩展报文发给Bob</li><li>Bob接收到一个扩展报文（m，h）并计算<code>$H(m)$</code>，如果<code>$H(m)=h$</code>,Bob会认为一切正常。</li></ol><p>缺陷： 其他人可以生成虚假报文（m’, H(m’)),Bob无法发现这种行为。</p><p>为解决这种缺陷，需要鉴别密钥（authentication key），共享秘密s。（也就是对散列值加密）</p><ol><li>Alice生成报文m, 用s级联m以生成m+s，并计算散列<code>$H(m+s)$</code>。<code>$H(m+s)$</code>称为报文鉴别码（Message Authentication Code，MAC）</li><li>然后Alice将MAC附加到报文m上，生成一个扩展报文（m, H(m+s)),并将该扩展报文发给Bob</li><li>Bob接收到一个扩展报文（m，h）并计算<code>$H(m+s)$</code>，如果<code>$H(m+s)=h$</code>,Bob会认为一切正常。</li></ol><h1 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6 数字签名"></a>6 数字签名</h1><p>数字签名是一种在数字领域表明身份的密码技术。</p><p>用私钥加密数据，然后把加密的数据公布出去，这就是数字签名。</p><ol><li>公钥认证<br><br> 证书就是公钥+签名，由第三方认证机构颁发。<br><br> 证书认证的流程：<ol><li>Bob去可信任的认证机构正是本人真实身份，并提供自己的公钥</li><li>Alice想和Bob通信时，先向认证机构请求Bob的公钥，认证机构会将一张证书（bob的公钥以及自己对其公钥的签名）发送给Alice</li><li>Alice检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。</li><li>Alice通过这个公钥加密数据，开始和Bob通信。<blockquote><p>正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份。</p></blockquote></li></ol></li></ol><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7 HTTPS"></a>7 HTTPS</h1><p>HTTPS是身披SSL外壳的HTTP， 当HTTP加上加密处理和认证以及完整性保护后就是HTTPS。HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（secure socket layer）和TLS（transport layer security）协议代替。采用了SSL后，HTTP就有了HTTPS的加密、证书、和完整性保护这些功能。</p><ol><li><p>Https为了兼顾安全与效率，同时使用了对称加密和非对称加密。</p><ul><li>数据是被对称加密传输的</li><li>对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输</li><li>对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</li></ul></li><li><p>HTTPS在传输过程中涉及到三个密钥：服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密</p></li><li><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><ul><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>服务器将自己的公钥发送给客户端。</li><li>客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ul></li></ol><ol start="4"><li>SSL<ul><li>SSL记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。</li><li>SSL握手协议：它建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ul></li></ol><p><a href="https://yqzzxlj.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></p><h1 id="8-CSRF"><a href="#8-CSRF" class="headerlink" title="8 CSRF"></a>8 CSRF</h1><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/BA662715544C491E8EDDB0F6D5038C4B/15384" alt="CSRF"><br>    - 登录受信任网站A，并在本地生成Cookie。<br>    - 在不登出A的情况下，访问危险网站B。</p><ol><li>防止CSRF原理</li></ol><ul><li>用户请求信息的时候，被骇客获取中间请求信息，当然也会获取token信息，但是因为骇客并不能阻止用户请求到目标网站。</li><li>用户请求目标网站之后，token已经被校验。所以骇客获取的token信息依然无用。</li><li>当时骇客如果在用户请求到目标网站之前先去请求到目标网站，token的作用就没有了。</li></ul><ol start="2"><li>现在很多登陆选择基于token的登陆认证方案，一般也是把token缓存在localStorage里<ul><li>会话劫持”是一种常见攻击手段, 攻击者通过XSS注入获取非Http-Only的明文Cookies或者通过网络嗅探直接获取全部请求内容,从而得到Session标识的值</li><li>CSRF利用的是浏览器访问网页会自动携带该网页的cookie的特性来攻击，此攻击不会获取浏览器执行环境、cookie、token，将token加入HTTP头是用户自己的行为，不是浏览器自发行为，所以对于CSRF攻击而言，token是相对安全的；</li><li>对于XSS攻击而言，攻击者已经可以注入脚本，完全获得代码执行环境，这个时候cookie和token都不安全了，相对而言，cookie还可以设置HttpOnly来防止js获取，但是token就完全裸奔了，攻击者就可以完成提问者所说的攻击了；</li></ul></li></ol><h1 id="9-XSS"><a href="#9-XSS" class="headerlink" title="9 XSS"></a>9 XSS</h1><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">美团XSS</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-安全通信&quot;&gt;&lt;a href=&quot;#1-安全通信&quot; class=&quot;headerlink&quot; title=&quot;1 安全通信&quot;&gt;&lt;/a&gt;1 安全通信&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层能够被分解为两个相互作用的部分，即数据平面和控制平面。</p><p>数据平面的主要作用是从其输入链路向其输出链路转发数据报；控制平面的主要作用是协调这些本地的路由器转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传输。</p><p>转发和路由选择：数据平面和控制平面</p><p>转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。（硬件）</p><p>路由选择是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。（软件）</p><p>路由器工作原理</p><p>网际协议：IPv4、寻址、IPv6及其他， IP地址属于网络层地址， IP属于面向无连接型</p><h1 id="1-IPv4"><a href="#1-IPv4" class="headerlink" title="1 IPv4"></a>1 IPv4</h1><h2 id="1-1-IPV4数据报格式"><a href="#1-1-IPV4数据报格式" class="headerlink" title="1.1 IPV4数据报格式"></a>1.1 IPV4数据报格式</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/B1B01B5371E045A6B3AD6EE8730293FF/14238"></p><ul><li>版本号。由4比特构成，表示标识IP首部的版本号。字段值为4。</li><li>首部长度。由4比特构成，表明IP首部的大小。因为IPv4包含一些可变数量的选项。</li><li>服务类型（Tos字段）。由8比特构成，表明服务质量。（优先级、时延、吞吐量）</li><li>数据报长度。由16比特构成，表示IP数据报的总长度。</li><li>标识。由16比特构成。用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。</li><li>标志。由3比特构成。表示包被分片的相关信息。</li><li>片偏移。由13比特构成。用来表示被分片的每一个分段相对于原始数据的位置。</li><li>生存时间（Time To Live，TTL）。由8比特构成。表示可以中转多少个路由器，每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。</li><li>上层协议。由8比特构成，表示IP数据报的数据部分应该交给哪个协议。</li><li>首部检验和。由16比特构成，校验数据报的首部，不校验数据部分。用来确保IP数据报不被破坏。</li><li>源地址。由32比特构成，表示发送端IP地址</li><li>目标地址。由32比特构成，表示接受端IP地址</li><li>可选项。 长度可变，在实验或诊断时使用，包括安全级别、源路径、路径记录、时间戳。</li><li>数据。存入数据。包括IP上层协议的首部<blockquote><p>ipv4首部最小20字节，最大60字节。ipv6固定40字节</p></blockquote><h2 id="1-2-IPv4数据报分片"><a href="#1-2-IPv4数据报分片" class="headerlink" title="1.2 IPv4数据报分片"></a>1.2 IPv4数据报分片</h2></li></ul><p>一个链路层帧能承载的最大数据量叫作最大传送单元（Maximun Transmission Unit， MTU）。每种数据链路的最大传输单元都不近相同。</p><p>路由器将IP数据报分片但不会进行重组，重组只能由目标主机进行。</p><h2 id="1-3-Ipv4编址"><a href="#1-3-Ipv4编址" class="headerlink" title="1.3 Ipv4编址"></a>1.3 Ipv4编址</h2><p>主机与物理链路之间的边界叫接口。一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>IPv4地址由32位比特组成。每8位分成一组，分成4组，以”.”隔开，再将每组数转化为十进制数。</p><p>IPv4地址由网络标识（网络地址）和主机标识（主机地址）两部分组成。</p><p>子网掩码将原网络分为多个物理网络。<a href="https://blog.csdn.net/gatieme/article/details/50989257">子网掩码详解</a></p><p>物件别域间路由选择（Classless Interdomain Routing， CIDR） 和<br>可变长子网掩码（Variable Length Subnet Mask， VLSM）技术采用任意长度分割IP地址的网络标识和主机标识。</p><p>广播地址。把IP地址中的主机地址部分全部设置为1，就成了广播地址。<br>在本网络内的广播叫本地广播，不同网络之间的广播叫直接广播。</p><p>多播。多播用于将包发送给特定组内的所有主机。</p><p>对于没有连接互联网的独立网络中的主机，只要保证在这个网络每地址唯一，可以不用考虑互联网即可配置响应的IP地址。私有网络的IP地址</p><ul><li>A类 10.0.0.0 ~ 10.255.255.255（10/8）</li><li>B类 172.16.0.0 ~ 172.31.255.255（172.16/12）</li><li>C类 192.168.0.0 ~ 192.168.255.255（192.168/16）</li></ul><p>包含在这个范围内的IP地址都属于私有IP，在此之外的IP称为全局IP。</p><h1 id="2-Ipv6"><a href="#2-Ipv6" class="headerlink" title="2 Ipv6"></a>2 Ipv6</h1><h2 id="2-1-IPv6数据报格式"><a href="#2-1-IPv6数据报格式" class="headerlink" title="2.1 IPv6数据报格式"></a>2.1 IPv6数据报格式</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/04C7048AF63C47A8802A06CA5B466098/14240"></p><ul><li>版本。 由4比特构成。6.</li><li>流量类型 由8比特构成。与IPv4中TOS字段含义相似。</li><li>流表签 由20比特构成。用于标识一条数据报的流。</li><li>有效载荷长度 由16比特构成。有效载荷指包的数据部分。</li><li>下一个首部 由8比特构成，相当于IPv4的协议字段</li><li>跳限制 由8比特构成，相当于IPv4的TTL。</li><li>源地址 由128比特构成。表示发送端IP地址</li><li>目的地址 由128比特构成。表示接受端IP地址。</li></ul><ol><li>IPv4数据报的几个字段不复存在：<ul><li>分片/重新组装： IPv6不允许在中间路由器上进行分片与重新组装。这种操作只能在源与目的地执行。</li><li>首部检验和： IP分组关注的重点是快速处理。减轻路由器负荷。</li><li>选项： 选项字段不再是首部的一部分，但他没有消失，可能出现在“下一个首部”指出的位置上。</li></ul></li><li>IPv6的必要性<ul><li>解决IPv4地址耗尽的问题</li><li>弥补IPv4中的大多数缺陷</li></ul></li><li>IPv6的特点<ul><li>IP地址的扩大与路由控制表的聚合</li><li>性能提升：包首部采用固定的值（40字节），不再采用首部检验码，简化首部结构，减轻路由器负荷。路由器不再做分片处理。</li><li>支持即插即用功能：即使没有DHCP服务器也可以实现自动分配IP地址</li><li>采用认证与加密功能：应对伪造IP地址的网络安全功能以及防止线路窃听的功能（IPsec）</li><li>多播、MobileIP称为扩展功能</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;网络层&lt;/h1&gt;&lt;p&gt;网络层能够被分解为两个相互作用的部分，即数据平面和控制平面。&lt;/p&gt;
&lt;p&gt;数据平面的主要作用是从其输入链路向其输出链路转发数据报；</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络相关概念和知识</title>
    <link href="http://example.com/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E7%9F%A5%E8%AF%86/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T11:17:35.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h1><ol><li>因特网</li></ol><ul><li>端系统通过通信链路和分组交换机连接到一起<ul><li>构成因特网的基本硬件和软件组件</li><li>为分布式应用提供服务的联网基础设施</li></ul></li></ul><ol start="2"><li>协议</li></ol><ul><li>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送、接受、或其他事件采取的动作</li></ul><ol start="3"><li>网络边缘</li></ol><ul><li>主机 == 端系统 分为客户(client)和服务器(server)</li></ul><ol start="4"><li>网络核心(互联网端系统分组交换机和通信链路构成的网状网络。)</li></ol><ul><li>分组交换（将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组）<ul><li>存储转发传输</li><li>排队时延和分组丢失</li><li>转发表和路由选择协议</li></ul></li><li>电路交换（由于bai电路交换在通信之前要du在通信双方之间建立一条被zhi双方独占的物理通dao路（由通信双方之间的交换设备和链路逐段连接而成））<ul><li>频分复用（划分为不同频率）</li><li>时分复用（划分为不同时段）</li></ul></li><li>对比<ul><li>分组交换的缺点： 不适合实时服务，因为它端到端的时延是变动的和不可测的（排队时延）</li><li>分组交换的优点：提供了比电路交换更好地带宽共享；比电路交换更简单、更有效、实现成本低</li></ul></li><li>分组交换网中的时延、丢包、和吞吐量（todo）<ul><li>时延： 处理时延、排队时延、传输时延、传播时延</li><li>排队时延和丢包</li><li>端到端时延</li><li>吞吐量<br>关于分组交换详细见<a href="https://www.cnblogs.com/summerday152/p/11876748.html">分组交换网中的时延、丢包和吞吐量</a><h1 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2 计算机网络体系结构"></a>2 计算机网络体系结构</h1></li></ul></li></ul><p>有三种划分说法：OSI七层、五层协议、TCP/IP四层<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/7EA633CF44914DF4B472E6EA30B86A96/13138"></p><h2 id="2-1-五层协议"><a href="#2-1-五层协议" class="headerlink" title="2.1 五层协议"></a>2.1 五层协议</h2><ul><li>应用层：为特定应用程序提供数据传输服务，如HTTP,DNS等。数据单位为报文</li><li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<ul><li>传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；TCP主要提供完整性服务。</li><li>用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。UDP主要提供及时性服务。</li></ul></li><li>网络层：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的节点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感受不到这些差异。<blockquote><p>报文 -&gt; 数据报 -&gt; 分组 -&gt; 帧 -&gt; 比特流</p></blockquote></li></ul><h2 id="2-2-七层协议"><a href="#2-2-七层协议" class="headerlink" title="2.2 七层协议"></a>2.2 七层协议</h2><p>其中表示层和会话层用途如下：</p><ul><li>表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。</li><li>会话层：建立及管理会话<blockquote><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p></blockquote></li></ul><h2 id="2-3-TCP-IP协议"><a href="#2-3-TCP-IP协议" class="headerlink" title="2.3 TCP/IP协议"></a>2.3 TCP/IP协议</h2><p>它只有4层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>现在的TCP/IP体系结构不严格遵循OSI分层概念，应用层可能会直接使用IP层或者网络接口层。</p><p>TCP/IP协议族是一种沙漏形状，中间小两边大，IP协议在其中占有重要地位。<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/17578FC0C091412E9113EFBD546F78A2/13165"></p><h2 id="2-4-数据在各层之间的传递过程"><a href="#2-4-数据在各层之间的传递过程" class="headerlink" title="2.4 数据在各层之间的传递过程"></a>2.4 数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-相关概念&quot;&gt;&lt;a href=&quot;#1-相关概念&quot; class=&quot;headerlink&quot; title=&quot;1 相关概念&quot;&gt;&lt;/a&gt;1 相关概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;因特网&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;端系统通过通信链路和分组交换机连接到一起&lt;ul&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
