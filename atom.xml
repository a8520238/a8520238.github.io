<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lgz_blog</title>
  
  <subtitle>Hey!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T12:29:01.954Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lgz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大话设计模式</title>
    <link href="http://example.com/2021/02/27/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/27/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>设计模式分为三大类：</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="一、简单工厂模式与工厂方法模式（重点可看大话设计模式）-https-blog-csdn-net-qq-34337272-article-details-80472071"><a href="#一、简单工厂模式与工厂方法模式（重点可看大话设计模式）-https-blog-csdn-net-qq-34337272-article-details-80472071" class="headerlink" title="一、简单工厂模式与工厂方法模式（重点可看大话设计模式） https://blog.csdn.net/qq_34337272/article/details/80472071"></a>一、简单工厂模式与工厂方法模式（重点可看大话设计模式） <a href="https://blog.csdn.net/qq_34337272/article/details/80472071">https://blog.csdn.net/qq_34337272/article/details/80472071</a></h1><h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h2><p>简单工厂模式实际上就是创建一个接口，这个接口有相关类的某种抽象功能或者特性，这个接口或父类的对象就是简单工厂中的产品。</p><p>在实际使用中，我们只需要创建某个类实现这个借口，或者继承父类，就可以创建子类对象，投入到简单工厂中。</p><p>再创建一个工厂类，这里可以采用两种办法，第一种使用switch，但就不符合开放封闭原则。第二种使用反射， obj = Class.forName(clazz.getName()).newInstance(); 这种方法可以在增加子类产品时不需要修改工厂类。</p><h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2 工厂方法模式"></a>2 工厂方法模式</h2><p>工厂方法模式是定义一个用于创建对象的接口，由子类对象决定实例化哪一个。</p><p>工厂方法模式与简单工厂的一个区别，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p><p>工厂方法模式，将工厂类进行抽象，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。换句话说，工厂方法模式中的要素有四个：</p><p>抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 </p><p>具体工厂(Concrete Factory)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 </p><p>抽象产品(AbstractProduct)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</p><p>具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应</p><p>这样，我们创建抽象类型的工厂类，其实际对象为具体工厂类（对应具体产品），可以将实现方法剥离。在调用时，我们只需要生成生产具体产品的具体工厂类，调用其中的统一方法即可。</p><h2 id="3-抽象工厂方法"><a href="#3-抽象工厂方法" class="headerlink" title="3 抽象工厂方法"></a>3 抽象工厂方法</h2><p>抽象工厂是生产一整套有产品的方法（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。</p><p>也就是说抽象工厂类中不再只有一抽象种产品，而是多个抽象产品。再创建具体工厂时要对两种产品做出@Override。每种抽象产品又有多个具体产品实现类。</p><p>举个例子，抽象工厂代表某军事工事，其能生产抽象产品枪和子弹，具体的工厂为某品牌工厂，在该具体工厂类中，其所重写的方法即是生产该品牌公司所生产的具体产品枪和子弹。</p><p>这样也有缺点，极有可能会违反抽象封闭原则，比如增加公司，这个问题可用反射解决。</p><h1 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h1><h2 id="1-预加载"><a href="#1-预加载" class="headerlink" title="1 预加载"></a>1 预加载</h2><p>还没有实例化该对象，该对象就已经加载到内存中。这种方法会造成内存的浪费。</p><pre><code>public class PreloadSingleton &#123;   public static PreloadSingleton instance = new PreloadSingleton();   //其他的类无法实例化单例类的对象   private PreloadSingleton() &#123;   &#125;;   public static PreloadSingleton getInstance() &#123;          return instance;   &#125;&#125;</code></pre><h2 id="2-懒加载（这里涉及到线程加锁保证安全问题）"><a href="#2-懒加载（这里涉及到线程加锁保证安全问题）" class="headerlink" title="2 懒加载（这里涉及到线程加锁保证安全问题）"></a>2 懒加载（这里涉及到线程加锁保证安全问题）</h2><p>用到该单例对象时再创建，可避免内存浪费，但不是线程安全的。</p><pre><code>public class Singleton &#123;   private static Singleton instance=null;   private Singleton()&#123;   &#125;;   public static Singleton getInstance()   &#123;          if(instance==null)          &#123;                 instance=new Singleton();          &#125;          return instance;   &#125;&#125;</code></pre><h1 id="三、装饰器模式"><a href="#三、装饰器模式" class="headerlink" title="三、装饰器模式"></a>三、装饰器模式</h1><p>装饰器模式中有四个类很重要。</p><p>1.Component（被装饰对象的基类）<br>   定义一个对象接口，可以给这些对象动态地添加职责。</p><p>2.ConcreteComponent（具体被装饰对象）<br>   定义一个对象，可以给这个对象添加一些职责。</p><p>3.Decorator（装饰者抽象类）<br>   维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。</p><p>4.ConcreteDecorator（具体装饰者）<br>   具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</p><p>以商城为例子，如下：</p><ol><li>Component抽象类</li></ol><pre><code>public abstract class Component &#123;    public abstract void operation();&#125;</code></pre><ol start="2"><li>ConretetComponent类（具体被装饰物类）</li></ol><pre><code>public class ConcreteComponent extends Component &#123;    @Override    public void operation() &#123;        System.out.println(&quot;具体对象的操作&quot;);    &#125;&#125;</code></pre><p>3 Decorator装饰类</p><pre><code>public abstract class Decorator extends Component &#123;    private Component component = null;    //通过构造函数传递给被修饰者    public Decorator(Component component) &#123;        this.component = component;    &#125;    //委托给被修饰者执行    @Override    public void operation() &#123;        if(component != null) &#123;            this.component.operation();        &#125;    &#125;&#125;</code></pre><p>4 ConcreteDecorator类（具体装饰类）</p><pre><code>public class ConcreteDecoratorA extends Decorator &#123;    //定义被修饰者    public ConcreteDecoratorA(Component component) &#123;        super(component);    &#125;    //定义自己的修饰方法    private void method1() &#123;        System.out.println(&quot;method1 修饰&quot;);    &#125;    @Override    public void operation() &#123;        this.method1();        super.operation();    &#125;&#125;public class ConcreteDecoratorB extends Decorator &#123;    //定义被修饰者    public ConcreteDecoratorB(Component component) &#123;        super(component);    &#125;    //定义自己的修饰方法    private void method2() &#123;        System.out.println(&quot;method2 修饰&quot;);    &#125;    @Override    public void operation() &#123;        super.operation();        this.method2();    &#125;&#125;</code></pre><p>5 Client客户端</p><pre><code>public class Client &#123;    public static void main(String[] args) &#123;        Component component = new ConcreteComponent();        //第一次修饰        component = new ConcreteDecoratorA(component);        //第二次修饰        component = new ConcreteDecoratorB(component);        //修饰后运行        component.operation();    &#125;&#125;</code></pre><p>这里说一下装饰过程，首先生成了具体被装饰类component，第一次生成装饰器A，其内部的组件对象为原始的component,然后生成装饰器B，此时其内部组件对应的是componentA,在调用componentB的operation时，会先调用父类decorator的方法operation，该方法会调用当前存储的对象componentA的operation方法，这样实现了一级一级的传递过程。</p><h1 id="四-代理模式"><a href="#四-代理模式" class="headerlink" title="四 代理模式"></a>四 代理模式</h1><p><a href="https://www.cnblogs.com/daniels/p/8242592.html">https://www.cnblogs.com/daniels/p/8242592.html</a> 记录较为清楚</p><p>代理模式分为静态代理和动态代理</p><p>动态代理类如下：</p><pre><code>package main.java.proxy.impl;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxyHandler implements InvocationHandler &#123;private Object object;public DynamicProxyHandler(final Object object) &#123;    this.object = object;&#125;@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;    System.out.println(&quot;买房前准备&quot;);    Object result = method.invoke(object, args);    System.out.println(&quot;买房后装修&quot;);    return result;&#125;&#125;</code></pre><p>测试类如下：</p><pre><code>package main.java.proxy.test;import main.java.proxy.BuyHouse;import main.java.proxy.impl.BuyHouseImpl;import main.java.proxy.impl.DynamicProxyHandler;import java.lang.reflect.Proxy;public class DynamicProxyTest &#123;    public static void main(String[] args) &#123;    BuyHouse buyHouse = new BuyHouseImpl();    BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new            Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));    proxyBuyHouse.buyHosue();&#125;&#125;</code></pre><p>注意Proxy.newProxyInstance()方法接受三个参数：<br>ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法。</p><h1 id="五-原型模式"><a href="#五-原型模式" class="headerlink" title="五 原型模式"></a>五 原型模式</h1><p>这个模式要注意两个地方</p><p>1 深拷贝和浅拷贝，使用clone是深拷贝，但this.MemberwiseClone是拷贝的对象是拷贝的引用为浅拷贝，要一层一层的深拷贝。</p><p>2 要注意实现Cloneable 接口，调用super.Clone方法</p><h1 id="六-外观模式"><a href="#六-外观模式" class="headerlink" title="六 外观模式"></a>六 外观模式</h1><p>spring mvc就是一个外观模式的例子，在维护一个大型系统时。开发外观类与之对接可以降低偶合。</p><h1 id="七-策略模式"><a href="#七-策略模式" class="headerlink" title="七 策略模式"></a>七 策略模式</h1><h1 id="八-模板方法（与策略模式很像）"><a href="#八-模板方法（与策略模式很像）" class="headerlink" title="八 模板方法（与策略模式很像）"></a>八 模板方法（与策略模式很像）</h1><p>模板模式关注统一算法的不同实现，策略模式关注不同算法。</p><p>模板模式将不变的行为放到超类中。</p><p>可看servlet源码</p><h1 id="九-建造者模式（生成器模式）"><a href="#九-建造者模式（生成器模式）" class="headerlink" title="九 建造者模式（生成器模式）"></a>九 建造者模式（生成器模式）</h1><h1 id="十-适配器模式"><a href="#十-适配器模式" class="headerlink" title="十 适配器模式"></a>十 适配器模式</h1><p>模式说明：</p><ul><li>包装类 = 适配器Adapter；</li><li>被包装对象 = 适配者Adaptee = 被适配的类</li></ul><p>作用：</p><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MagaGenericServlet implements Servlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象类继承了Servlet类，对于需要实现的内容进行空实现 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;&#x2F;login&quot;)</span><br><span class="line">public class LoginServlet1 extends MagaGenericServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;我被执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;设计模式分为三大类：&lt;/p&gt;
&lt;p&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。&lt;/p&gt;
&lt;p&gt;结构型模</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://example.com/2021/02/27/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2021/02/27/%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-程序与进程"><a href="#1-程序与进程" class="headerlink" title="1 程序与进程"></a>1 程序与进程</h1><p>进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数据）的真正运行实例。</p><p>进程结构一般由3部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享同一个代码段。数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数的参数，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括了进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及数据在处理机执行时所发生的活动</li><li>进程时系统进行资源分配和调度的独立单位。进程的独立运行由进程控制块PCB控制和管理。进程映像时静态的进程。程序段、相关数据、PCB三部分构成了进程映像。PCB进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。</li></ul><h1 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2 进程状态"></a>2 进程状态</h1><ol><li>运行状态：进程在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态</li><li>就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行</li><li>阻塞状态：又称等待状态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入输出的完成。即使处理机空闲，该进程也不能运行。</li><li>创建状态：进程正在被创建。</li><li>结束状态：进程正从系统中消失。</li></ol><h1 id="3-linux系统进程启动过程"><a href="#3-linux系统进程启动过程" class="headerlink" title="3 linux系统进程启动过程"></a>3 linux系统进程启动过程</h1><p>0号进程–&gt;1号内核进程-&gt;1号内核线程–&gt;1号用户进程–&gt;getty进程–&gt;shell进程</p><p>整个linux系统的所有进程也是一个树结构。树根时系统自动构造的，即在内核态下执行的0号进程，它是所有进程的祖先。由0号进程创建1号进程（内核态），1号负责执行内核的部分初始化工作及进行系统配置，并创建若干个用于告诉缓存和虚拟储存管理的内核线程。</p><p>随后1号进程调用execve（）运行可执行程序init，并演变成用户态1号进程，他按照系统配置文件/etc/initab的要求，完成系统的启动工作，创建编号为1号、2号等若干终端注册进程getty。当getty检测到来自终端的信号时， getty将通过 execve执行注册程序 login， 此时就可以通过用户名、密码登录。如果登录成功，login() 程序执行shell， shell进程接替 getty 进程的pid 取代getty进程。后续进程再通过shell产生。</p><h1 id="4-进程的创建"><a href="#4-进程的创建" class="headerlink" title="4 进程的创建"></a>4 进程的创建</h1><p>创建状态：进程正在创建尚未就绪，经过几个创建步骤：申请空白PCB、向PCB写入控制和管理信息、然后为进程分配所需资源、最后转入就绪状态。</p><h2 id="4-1-引起进程创建的事件"><a href="#4-1-引起进程创建的事件" class="headerlink" title="4.1 引起进程创建的事件"></a>4.1 引起进程创建的事件</h2><ul><li>系统创建<ul><li>用户登录：分时系统中户登录都可以看成一个新的进程。系统为该终端创建一个新的进程并插入就绪队列</li><li>作业调度：批处理作业中，当系统按照一定算法调度作业时，将该作业调入内存为其分配资源，提供服务。</li></ul></li><li>用户请求：用户可以基于自己的需求创建进程</li></ul><h2 id="4-2-进程创建的过程"><a href="#4-2-进程创建的过程" class="headerlink" title="4.2 进程创建的过程"></a>4.2 进程创建的过程</h2><ol><li>为进程申请一个唯一的进程识别号和空白PCB（PCB是有限的，若PCB申请失败则创建失败）</li><li>为进程分配资源、为新进程的程序、数据、用户栈分配内存空间（如果资源不足，并不是创建失败，而是处于等待状态，等待资源。</li><li>初始化PCB，主要包括标志信息、状态信息、处理机信息等。</li><li>如果就绪队列能够接受新进程，就将进程插入就绪队列中</li></ol><h2 id="4-3-Linux下的进程创建"><a href="#4-3-Linux下的进程创建" class="headerlink" title="4.3 Linux下的进程创建"></a>4.3 Linux下的进程创建</h2><p>父进程和子进程：除了0号进程，Linux系统中其他任何一个进程都是由其他进程创建的。而相对的，fork函数的调用方是父进程，创建的新进程是子进程。</p><p>fork函数不需要参数，返回值是一个进程标识符。</p><ol><li>对于父进程，fork函数返回创建子进程的ID</li><li>子进程fork函数返回0</li><li>创建出错的话fork函数返回-1</li></ol><p>fork函数创建了一个新的进程，并从内核中为其分配一个可用的进程标识符PID，之后为其分配进程空间，并将父进程空间的内容复制到子进程空间，包括数据段和堆栈段，与父进程共享代码段。这时候系统中多了一个进程，父进程和子进程都接受系统的调度。由于复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。fork函数返回两次，分别在父进程和子进程中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    if(pid&lt;0)&#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;else if(pid &#x3D;&#x3D;0)&#123;</span><br><span class="line">        printf(&quot;Subprocess, PID: %u&quot;, getpid());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Parentprocess, PID: %u&quot;, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程完全复制了父进程的地址空间，包括堆栈段和数据段。但是子进程并未复制代码段，而是共用代码段。</p><h1 id="5-进程的结束"><a href="#5-进程的结束" class="headerlink" title="5 进程的结束"></a>5 进程的结束</h1><p>结束状态：进程从系统中消失，这可能因为正常结束或其他原因中断退出。进程结束时，系统首先置该进程为结束状态，然后进一步释放和回收资源。</p><h2 id="5-1-进程结束的事件"><a href="#5-1-进程结束的事件" class="headerlink" title="5.1 进程结束的事件"></a>5.1 进程结束的事件</h2><ol><li>正常结束</li><li>异常结束：出现某种错误导致无法运行：越界、非法指令、运行超时等</li><li>外界干预：进程应外界请求而终止。<h2 id="5-2-进程的终止过程"><a href="#5-2-进程的终止过程" class="headerlink" title="5.2 进程的终止过程"></a>5.2 进程的终止过程</h2></li><li>根据被终止的标识符，检索PCB，从中读取进程状态</li><li>若进程处于执行状态，立即终止并置标志为真</li><li>若进程还有子孙进程，则终止子孙进程防止其不可控</li><li>将终止进程的所有资源释放给系统或父进程</li><li>将终止进程移除队列<h2 id="5-3-进程的切换"><a href="#5-3-进程的切换" class="headerlink" title="5.3 进程的切换"></a>5.3 进程的切换</h2></li><li>保留处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li><li>选择另一个进程执行，并更新其PCB</li><li>更新内存管理的数据结构</li><li>恢复处理机上下文。</li></ol><h1 id="6-孤儿进程和僵尸进程"><a href="#6-孤儿进程和僵尸进程" class="headerlink" title="6 孤儿进程和僵尸进程"></a>6 孤儿进程和僵尸进程</h1><p>在linux中，正常情况下子进程是通过父进程创建的，子进程和父进程的运行是一个异步的过程。父进程无法预料子进程在何时结束，于是就产生了孤儿进程和僵尸进程</p><h2 id="6-1-孤儿进程"><a href="#6-1-孤儿进程" class="headerlink" title="6.1 孤儿进程"></a>6.1 孤儿进程</h2><p>指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对他们完成状态收集工作。</p><h2 id="6-2-僵尸进程"><a href="#6-2-僵尸进程" class="headerlink" title="6.2 僵尸进程"></a>6.2 僵尸进程</h2><p>是指一个进程使用fork创建子进程，如果子进程退出，而父进程没有用wait或waitpid调用子进程的状态信息，子进程的进程描述符仍在系统中，这种进程被成为僵尸进程。</p><p>简单理解为，孤儿是父进程已退出而子进程未退出；而僵尸进程是父进程未退出而子进程先退出。</p><p>为了避免僵尸进程，需要父进程通过wait函数来回收子进程。</p><h2 id="6-3-守护进程"><a href="#6-3-守护进程" class="headerlink" title="6.3 守护进程"></a>6.3 守护进程</h2><p>在Linux系统的引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。守护进程是脱离于终端在后台运行的进程，守护进程脱离终端是为了避免进程在执行过程中在终端上显示并且不会被终端的信息打断。</p><p>守护进程是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。守护进程常常在系统引导装入时启动，在系统关闭时终止。Linux系统有很多的守护进程，大多数服务都是通过守护进程实现的。如作业规划进程、打印进程。</p><p>在Linux中每一个与用户交流的界面称为终端，每一个终端开始的进程都会依附于该终端，这个终端就被称为进程的控制终端，当控制终端被关闭时，相应的进程都会被关闭。但是守护进程可以突破这种限制，他从被执行是开始运转，整个系统关闭时才退出。如果想让某个进程不因为用户或终端等变化受到影响，那么就需要把一个进程变成一个守护进程。</p><h1 id="7-进程通信"><a href="#7-进程通信" class="headerlink" title="7 进程通信"></a>7 进程通信</h1><p>进程间通信就是不同进程间传播或交换信息。首先进程间可以通过传送、打开文件来实现，不同的进程通过一个或多个文件来传递信息。一般来说进程间通信不包括这种低级的通信方式。Linux操作系统几乎支持所有的UNIX系统进程通信方法：管道、消息队列、共享内存、信号量、套接字。</p><h2 id="7-1-管道"><a href="#7-1-管道" class="headerlink" title="7.1 管道"></a>7.1 管道</h2><p>父子进程通过管道通信，管道是一种两个进程间单向通信的机制。因为管道传递数据的单向性，管道又被称为半双工管道。管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。</p><p>无名管道的特点：</p><ol><li>数据只能由一个进程流向另一个进程（一个读管道和一个写管道）；如果要进行双工通信，则需要建立两个管道。</li><li>管道只能用于父子通信或兄弟进程通信（有亲缘关系的进程）。</li></ol><p>除了上述局限性，管道还有一些不足，比如管道没有名字（匿名管道）；管道的缓冲区大小受限（Linux下一般是4kb）；管道传输的是无格式的字节流等。这就需要管道输入方和输出方事先约定好数据格式。使用管道通信时，两端的进程向管道读写数据是通过创建管道时，系统设置的文件描述符进行的。本质上说管道也是一种文件，但它又和一般的文件不同，可以克服文件通信的一些问题。</p><p>通过管道通信的两个进程，一个向管道写数据，一个从中读数据。写入的数据每次都添加到管道缓冲区的末尾，读数据都是从缓冲区的头部读出。</p><h2 id="7-2-具名管道"><a href="#7-2-具名管道" class="headerlink" title="7.2 具名管道"></a>7.2 具名管道</h2><p>还有一种管道叫具名管道（FIFO）它的不同之处是它提供一个路径名与之关联，以FIFO的形式存在于文件系统中。这样即使与FIFO创建不存在亲缘关系的进程，只要可以访问路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程和创建FIFO的进程之间），因此通过FIFO不相关的进程也能交换数据。</p><p>有名管道的特点：</p><ol><li>它可以使互不相关的两个进程实现通信</li><li>该管道可以通过路径名来指明，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当作普通文件一样读写，使用很方便。</li><li>FIFO严格遵守先进先出的规则，对于管道与FIFO，总是从开始处返回数据，而把数据添加到末尾。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/54BB3B539E804E7997F19381159A517F/14746" alt="有名管道和无名管道的区别"></p><h2 id="7-3-消息队列"><a href="#7-3-消息队列" class="headerlink" title="7.3 消息队列"></a>7.3 消息队列</h2><p>消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现。</p><p>消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。</p><p>与命名管道相比，消息队列的优势在于：</p><ol><li>消息队列可以独立于发送和接受进程存在，从而消除了同步命名管道打开和关闭时可能产生的的困难。</li><li>可以同时通过发送消息以避免命名管道的同步和阻塞问题，而不需要由进程自己来提供同步方法</li><li>接受程序可以通过消息类型有选择的接受数据，而不是向命名管道中那样，只能默认地接受。</li></ol><p>事实上它是一种正在被淘汰的通信方式，完全可以用流管道和套接口的方式取代。</p><h2 id="7-4-共享内存"><a href="#7-4-共享内存" class="headerlink" title="7.4 共享内存"></a>7.4 共享内存</h2><p>共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据一种非常有效的方式。不同进程间的共享内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的地址空间中，所有进程都可以访问共享内存中的地址。</p><p>不过，共享内存未提供同步机制，需要进程自行进行同步操作。</p><p>共享内存的优缺点：</p><ol><li>优点：使用共享内存通信非常方便，而且函数接口简单，数据共享还使用进程间的数据不用传送，而是直接访问内存，加快了效率，并没有亲缘关系的要求。</li><li>缺点：共享内存没有提供同步机制，这使得共享内存的通信往往要借助其他手段来完成。</li></ol><h2 id="7-5-信号量"><a href="#7-5-信号量" class="headerlink" title="7.5 信号量"></a>7.5 信号量</h2><p>共享内存是进程间通信的最快的方式，但是共享内存的同步问题自身无法解决（即进程该何时去共享内存取得数据，而何时不能取），但用信号量可以轻易解决这个问题。</p><h1 id="8-进程调度"><a href="#8-进程调度" class="headerlink" title="8 进程调度"></a>8 进程调度</h1><h2 id="8-1-调度层次"><a href="#8-1-调度层次" class="headerlink" title="8.1 调度层次"></a>8.1 调度层次</h2><p>进程调度分为三级调度，作业调度，中级调度，进程调度</p><ol><li>作业调度（高级调度）：主要任务是按照一定原则从外存中将处于后备状态的作业挑选一个或多个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度），每个作业只调入一次，调出一次。具体过程：选择作业→bai分配资源→建立进程du（建立进程：申请空zhi白PCB → 分配资源 → 初始化PCB →插入进程就绪队列）</li><li>内存调度。 进程的挂起与就绪。提高内存利用率和系统吞吐量。</li><li>低级调度，按某种方法和策略从就绪队列中选取一个进程，为期分配处理机。<h2 id="8-2-调度算法"><a href="#8-2-调度算法" class="headerlink" title="8.2 调度算法"></a>8.2 调度算法</h2></li><li>先来先服务算法（FCFS）<ul><li>FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度</li><li>FCFS是不可剥夺算法，长作业会使后到的短作业长期等待</li><li>算法简单，效率低，对长作业有利，有利于CPU繁忙性工作</li></ul></li><li>短作业优先（SJF，Short Job First）算法<ul><li>从后备队列中选择一个或若干个估计运行时间最短的作业掉入内存运行</li><li>对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态</li></ul></li><li>优先级调度算法<ul><li>优先级调度算法每次从后备队列中选取优先级最高的一个或几个作业</li><li>优先级调度可以剥夺时占有，也可以非剥夺式占有</li></ul></li><li>高响应比优先<ul><li>高响应比优先是对FCFS和SJF算法的一种平衡，计算每个作业的响应比</li><li>响应比的计算为（等待时间 + 要求服务时间）/要求服务时间</li></ul></li><li>时间片轮转调度算法<ul><li>时间片轮转算法适用于分时系统，系统讲所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms</li><li>受系统响应时间影响，队列进程数目，进程长短影响较大</li></ul></li><li>多级反馈队列调度算法<ul><li>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展</li></ul><ol><li>设置多个就绪队列，为各个队列赋予优先级，1，2，3等</li><li>赋予各个队列中时间片大小不同，优先级高时间片越小</li><li>一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行。</li><li>仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推<h1 id="9-进程同步"><a href="#9-进程同步" class="headerlink" title="9 进程同步"></a>9 进程同步</h1></li></ol></li><li>临界区<ul><li>虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源</li></ul></li><li>同步<ul><li>进程之间具有直接制约关系，进程之间需要按照一定的次序进行</li></ul></li><li>互斥<ul><li>进程之间的间接制约关系，不能同时访问临界区</li></ul></li><li>信号量<ul><li>信号量是一个整形变量，可以被定义为两个标准的原语wait(S),signal(S)即P，V操作<ul><li>P操作 如果信号量大于0， 执行-1操作，如果等于0，执行等待信号量大于0</li><li>V操作 对信号量完成加1操作，唤醒睡眠的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore mutex &#x3D; 1 </span><br><span class="line">void P1()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">void P2()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>管程</li></ol><ul><li>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块<ul><li>使用信号量机制时，进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。</li><li>管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用</li><li>引入管程的目的：1. 把分散在各进程中的临界区集中起来进行管理；2. 防止进程有意无意的违反同步操作;3. 便于高级语言程序书写和验证。</li></ul></li></ul><ol start="6"><li>生产者-消费者问题<br><br> 问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品<br>由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问<br>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># define N 100</span><br><span class="line">typedef int semahpore</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">semaphore empty &#x3D; N;</span><br><span class="line">semaphore full &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void producer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        int item &#x3D; produceItem();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Item.push(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        int item &#x3D; Item.top();</span><br><span class="line">        Item.pop();</span><br><span class="line">        consume(item);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(&amp;empty())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>读写者问题<br><br>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行</li></ol><p>用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore count &#x3D; 0;</span><br><span class="line">semaphore read_mutex &#x3D; 1;</span><br><span class="line">semaphore write_mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void read()&#123;</span><br><span class="line">    P(&amp;read_mutex);</span><br><span class="line">    count++;</span><br><span class="line">    if(count&#x3D;&#x3D;1) P(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">    read();</span><br><span class="line">    p(&amp;read_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    if(count&#x3D;&#x3D;0) V(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write()&#123;</span><br><span class="line">    P(&amp;write_mutex);</span><br><span class="line">    write();</span><br><span class="line">    V(&amp;write_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>哲学家进餐问题<br><br>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根<br><br>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore chop[5] &#x3D; &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void process()&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        P(chop[i]);</span><br><span class="line">        P(chop[(i+1)%5]);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chop[i]);</span><br><span class="line">        V(chop[(i+1)%5]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-程序与进程&quot;&gt;&lt;a href=&quot;#1-程序与进程&quot; class=&quot;headerlink&quot; title=&quot;1 程序与进程&quot;&gt;&lt;/a&gt;1 程序与进程&lt;/h1&gt;&lt;p&gt;进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB.MyISAM</title>
    <link href="http://example.com/2021/02/27/InnoDB.MyISAM/"/>
    <id>http://example.com/2021/02/27/InnoDB.MyISAM/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常见的两种存储引擎：MyISAM与InnoDB"><a href="#MySQL常见的两种存储引擎：MyISAM与InnoDB" class="headerlink" title="MySQL常见的两种存储引擎：MyISAM与InnoDB"></a>MySQL常见的两种存储引擎：MyISAM与InnoDB</h1><h2 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1  MyISAM"></a>1  MyISAM</h2><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）</p><ul><li>不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁；</li><li>不支持事务</li><li>不支持外键</li><li>不支持崩溃后的安全恢复</li><li>在表有读取查询的同时，支持往表中插入新纪录</li><li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li><li>支持延迟更新索引，极大地提升了写入性能</li><li>对于不会进行修改的表，支持 压缩表 ，极大地减少了磁盘空间的占用</li></ul><h2 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2 InnoDB"></a>2 InnoDB</h2><p>InnoDB是MySQL的默认数据库引擎（5.5版之后）</p><ul><li>支持行锁，采用MVCC来支持高并发，有可能死锁</li><li>支持事务</li><li>支持外键</li><li>支持崩溃后的安全恢复</li><li>不支持全文索引（5.6.4后支持）</li></ul><h2 id="3-二者对比"><a href="#3-二者对比" class="headerlink" title="3 二者对比"></a>3 二者对比</h2><ol><li><p>count运算上的区别： 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。</p></li><li><p>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p></li><li><p>是否支持外键： MyISAM不支持，而InnoDB支持。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL常见的两种存储引擎：MyISAM与InnoDB&quot;&gt;&lt;a href=&quot;#MySQL常见的两种存储引擎：MyISAM与InnoDB&quot; class=&quot;headerlink&quot; title=&quot;MySQL常见的两种存储引擎：MyISAM与InnoDB&quot;&gt;&lt;/a&gt;My</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>运输层协议</title>
    <link href="http://example.com/2021/02/27/%E8%BF%90%E8%BE%93%E5%B1%82TCP/"/>
    <id>http://example.com/2021/02/27/%E8%BF%90%E8%BE%93%E5%B1%82TCP/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h1><ul><li>网络层提供了<strong>主机</strong>之间的逻辑通信，运输层协议为不同主机上的<strong>应用进程</strong>之间提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直相连一样。</li><li>运输层协议实在端系统而不是路由器中实现的。在发送端，运输层将从发送应用程序进程接受到的报文转换成运输层分组，称为报文段（segment）</li><li>UDP（User Datagram Protocol，用户数据报协议）为调用他的应用程序提供了一种不可靠、无连接的服务。</li><li>TCP（Transmission Control Protocol， 传输控制协议） 为调用它的应用程序提供了一种可靠的、面向连接的服务。</li><li>将主机间交付拓展到进程间交付被称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）</li><li>UDP流量是不可调节的，使用UDP的应用程序可以根据需要以其愿意的任何速率发送数据。</li><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接受进程。</li><li>TCP还提供拥塞控制（congestion control）。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务。TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</li></ul><h1 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2 多路复用和多路分解"></a>2 多路复用和多路分解</h1><p>一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据地门户。在接受主机地运输层实际上并没有将数据直接交付给进程，而是将数据交给一个中间地套接字。每个套接字都有一个标识符，标识符的格式取决于他是UDP还是TCP套接字。</p><p>将运输层报文段中地数据交付到正确地套接字（通过端口号）的工作称为多路分解（demultiplexing）<br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层称为多路复用。</p><h1 id="3-UDP、无连接运输"><a href="#3-UDP、无连接运输" class="headerlink" title="3 UDP、无连接运输"></a>3 UDP、无连接运输</h1><ol><li>应用场景</li></ol><ul><li>包总量较少的通信（DNS，SNMP等）</li><li>视频、音频等多媒体通信（及时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信</li></ul><ol start="2"><li>UDP特点</li></ol><ul><li>UDP只做传输协议能做的最少工作，只在IP数据服务上增加了两个最基本的服务：复用和分用 以及差错检测</li><li>UDP没有拥塞控制，采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层；TCP有拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制TCP发送方。TCP仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要多长时间。而实时应用通常要求及时性，能够容忍一些数据丢失。</li><li>无需建立连接：TCP开始数据传输之前需要三次握手。UDP不需要任何准备即可进行数据传输。</li><li>无状态连接：TCP需要在端系统中维护连接状态。包括接受和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不维护连接状态，也不跟踪这些参数。</li><li>分组首部开销小 ：TCP40字节，UDP8字节。UDP首部只有8个字节，分为四个字段：源端口、目的端口、UDP长度、UDP校验和<ul><li>端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。</li><li>长度为UDP报文段中的字节数(首部+数据)</li><li>检验和：检验和提供了差错检测功能。因为不能保证源和目的之间的所有链路都提供差错检测。虽然提供差错检测，但他对差错恢复无能为力。</li></ul></li></ul><ol start="3"><li>TCP和UDP的区别<br><br>主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小来讲</li></ol><ul><li>TCP面向连接，UDP无连接。TCP3次握手建立连接，UDP发送前不需要建立连接</li><li>TCP可靠，UDP不可靠，TCP丢包有确认重传机制，UDP不会</li><li>TCP有序，会对报文进行重排；而UDP无序，后发送信息可能先到达</li><li>TCP必须进行数据验校，UDP的校验可选</li><li>TCP有流量控制（滑动窗口）和拥塞控制，UDP没有</li><li>TCP传输慢，UDP传输快，因为TCP要建立连接、保证可靠有序，还有流量、拥塞控制</li><li>TCP包头较大（20字节）UDP较小（8字节）<h1 id="4-TCP"><a href="#4-TCP" class="headerlink" title="4 TCP"></a>4 TCP</h1><h2 id="4-1-TCP报文结构"><a href="#4-1-TCP报文结构" class="headerlink" title="4.1 TCP报文结构"></a>4.1 TCP报文结构</h2>TCP提供全双工服务<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/DF87911636F94317A7FDB929EA21815A/13972" alt="TCP报文结构"></li></ul><ol><li>源端口和目的端口：唯一确定一条TCP连接，TCP在发送数据前必须在彼此间建立连接，意思是：双方需要保存对方的信息。</li><li>序列号seq：占4个字节，用于标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号，确保TCP传输有序。</li><li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li><li>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。用于确认不丢包。</li><li>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li><li>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li><li>其他标志位的含义：<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/C232A5EDEF7348EBACB6E426C08571E6/13974" alt="其他标志位含义"></li><li>数据偏移(首部长度)：4比特。指示以32比特的字为单位的TCP首部长度，因为有选项字段，作为一个4比特的字节，TCP被限制为只能带60字节的头部。</li><li>接受窗口。16比特。用于流量控制，限制窗口大小到65535字节。</li><li>选项。可选与变长。在发送方与接收方协商最大报文段长度（MSS）时使用，或者在高速网络环境下用作窗口调节因子时使用、时间戳、ASCK（选择确认)。</li></ol><h2 id="4-2-三次握手"><a href="#4-2-三次握手" class="headerlink" title="4.2 三次握手"></a>4.2 三次握手</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/F59FF5FC9B48486092B2D9E035539503/13976"></p><ol><li>第一次握手：客户端发送初始序号seq = x和SYN=1的请求标志。此时服务器得知客户端发送正常，自己接收正常。</li><li>第二次握手：服务器发送请求标志SYN=1,确认标志ACK=1，自己的序号seq=y，发送客户端的确认信号x+1。客户端知道自己发送、接收正常，服务器接收、发送正常。</li><li>第三次握手：客户端发送确认信号ACK=1，发送自己的序号seq=x+1，发送对方的确认号ACK=y+1。服务器知道客户端发送、接收正常，自己接收、发送也正常。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/CACA11D7C63E4F118D6CFC5A862D6334/13978"></p><ol><li>第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态，是客户端的请求断开。</li><li>第二次挥手：服务器收到客户端的请求后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态，服务器确认客户端的断开请求。</li><li>第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态），服务器请求断开。</li><li>第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态，客户端确认服务器断开。<h2 id="4-3-常见问题"><a href="#4-3-常见问题" class="headerlink" title="4.3 常见问题"></a>4.3 常见问题</h2></li><li>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</li></ol><ul><li>连接时，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，对应用于同步+应答。</li><li>连接关闭时，当服务端收到FIN报文时，也许还有话要说，并不会立即关闭SOCKET，所以不会立即返回一个FIN，而是先回复一个ACK报文，告诉客户端自己已经收到了FIN，而只有等服务端把要说的话说完，才能发送FIN，因此需要四步。</li></ul><ol start="2"><li>为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</li></ol><ul><li>我们需要假想网络传输是不可靠的，有可能最后一个ACK将会丢失，TIME_WAIT状态可以用来重发可能丢失的ACK报文。在客户端发出最后的ACK回复时，如果服务端没有收到ACK，它将不断重复发送FIN片段，所以客户端不能立即关闭，它必须确认服务端收到了该ACK。</li><li>客户端会在发出ACK之后进入TIME_WAIT的状态，并等待两倍的MSL的时间，Maximum Segment Lifetime，片段在网络中的最大生存时间，两倍的MSL就是一个发送和一个回复所需要的最大时间，如果超出该时间，客户端还没有再次收到FIN，那么客户端就会推断ACK已经被成功接收，此时TCP连接结束。</li></ul><ol start="3"><li>为什么不能用两次握手进行连接？</li></ol><ul><li>三次握手完成了两个重要的功能：<ul><li>双方做好发送数据的准备工作。</li><li>允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</li></ul></li><li>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</li></ul><ol start="4"><li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li></ol><ul><li>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<h2 id="4-4-注意事项"><a href="#4-4-注意事项" class="headerlink" title="4.4 注意事项"></a>4.4 注意事项</h2></li></ul><ol><li>当主机接收到TCP报文段与进行中的进程都不匹配的情况时，发送重置报文段。当主机发送一个重置报文段时，他告诉该源“我没有那个报文段的套接字，请不要发送该报文段了”。当UDP套接字不匹配时，主机发送特殊的ICMP数据报。</li><li>TCP的半打开状态<ul><li>如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双方就无法获悉异常</li><li>半打开的一个常见原因是一方程序的非正常结束（断电、断网）如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了。而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST)处理</li></ul></li><li>同时打开与同时关闭<ul><li>两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2发送SYN同步信息的同时，B:port2也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。</li><li>而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段</li></ul></li><li>重置报文段 RST字段<ul><li>针对不存在端口的连接请求</li><li>终止一条连接：重置报文段会被立即发送，任何排队的数据都将被抛弃；接收方会说明通信另一端采用了终止的方式而不是一次正常关闭。</li><li>半开连接：服务器主机被切断连接重启后，留给客户端一个半开的连接。当再次从这条连接上接收到数据时，服务器对其一无所知，并回复一个重置报文段关闭连接。</li><li>一个重置报文段能破坏TIME_WAIT状态并强制连接关闭。</li></ul></li><li>TCP保活机制<br><br>若某个连接长时间处于空闲状态，在该连接地一端会发送一个探测数据包（可以不含任何数据，但一般会包含垃圾字节）从而实现保活功能。<ul><li>对方主机正在工作且可以到达。正常响应，保活计时器重置</li><li>对方主机崩溃。没有响应，请求段会保活时间间隔指定地时间后超时断开连接。</li><li>对方主机崩溃已重启。重置报文段，断开连接</li><li>对方主机正在工作但无法到达。同2</li></ul></li><li>TCP 连接的本质是什么，真的是“链接”吗<br><br>状态和序列号，以及错误校验（可以查看TCP和UDP的请求头，就会发现两者之间的差距了），其实所谓的TCP三次握手请求连接，无非就是初始化一个序列号，保证后面的数据有序到达，同时TCP还支持重传，错误校验，保证数据的可靠性，当然UDP也提供校验。<ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul></li><li>大量的Time-wait怎么办<ul><li>Time-wait 状态不能消除，只能快速的回收或重用</li><li>reuse 处于Time-wait状态可以被后续连接重用</li><li>recycle 开启服务器对于time-wait的快速回收</li><li>time-out 修改系统默认的TIMEOUT时间<h2 id="4-5-TCP超时重传"><a href="#4-5-TCP超时重传" class="headerlink" title="4.5 TCP超时重传"></a>4.5 TCP超时重传</h2>异常网络，会出现如下网络状况</li></ul></li><li>数据顺利到对端，对端顺利响应ACK</li><li>数据包中途丢失</li><li>数据包顺利达到，但是ACK报文丢失</li><li>数据报数据达到，但是对异常未响应</li></ol><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/DA957EFC9E6F4DACAE0E8F0698937C1E/14096" alt="超时重传"></p><p>出现异常情况时，TCP就会超时重传。TCP每发送一个报文段，就对这个报文段，就对这个报文段设一个计时器，如果确认的时间到了而没有收到确认，就会重传报文段。这就是超时重传。</p><p>客户端一直没有得到ACK报文，客户端会一直重传，影响重传效率的是RTO（Retransmission Timeout）。RTO指发送数据后，传送数据等待ACK的时间。RTO(重传超时时间)非常重要。</p><ol><li>设长了，重发慢，没有效率</li><li>设短了，重发快，网络拥塞。</li></ol><p>如果底层传输特性已知，则重传相对简单，但是TCP体层完全异构，所以必须适应适应时延差异。</p><p>经典的自适应算法：</p><p><code>$SRTT = \alpha * SRTT + (1 - \alpha) * RTT$</code></p><p><code>$RTO = min(UBOUND, max(LBOUND, \beta * SRTT)$</code></p><p>UBOUND是最大的timeout时间，上限值，LBOUND是最小的timeout<br>时间，下限值。但这样会因为ACK传输导致RTT多义性问题。</p><p>carn算法，忽略重传，不采样重传的RTT，一旦发生重传，就对现有的RTO翻倍。<br>当不发生重传时，才根据上式计算平均往返时间RTT和重传时间。</p><p>处理差错的两种主要方法是差错校正码和数据重传。</p><p>当RTT测量值小于连接地实际值，就可能发生伪重传。在这种情况下，若TCP地等待时间稍长，不必要地重传就可能不发生。</p><h2 id="4-6-TCP滑动窗口"><a href="#4-6-TCP滑动窗口" class="headerlink" title="4.6 TCP滑动窗口"></a>4.6 TCP滑动窗口</h2><p>TCP的滑动窗口主要有两个作用：一是提供TCP的可靠性；二是提供TCP的流控特性。同时滑动 窗口机制还体现了TCP面向字节流的设计思路。解决乱序和流量控制。</p><blockquote><p>发送端叫拥塞窗口，为了解决拥堵，接收端是滑动窗口，为了解决流量控制。发送量取二者最小值。</p></blockquote><p>对于TCP会话的的发送方，任何时候器缓存数据可以分为四类:</p><ol><li>已经发送并受到对方的ACK</li><li>已经发送但未收到ACK</li><li>未发送但对方允许发送</li><li>对方不允许发送</li></ol><p>其中， 已经发送还未收到ACK和未发生但是对方允许发送的部分称为发送窗口<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/3D6CFB3A7E6E4B4B8C14674EC3FBEEFE/14115"><br>当接收到ACK后续的确认字节时，窗口便会滑动<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/489CF3079D0B43B185721DA291A2F29E/14117"><br>对于TCP会话的接收方，缓存数据可以分为三类</p><ol><li>已接收</li><li>未接受准备接收</li><li>未准备接收</li></ol><p>其中未接受准备接收称为接收窗口。</p><p>TCP是双工的协议，会话的双方可以同时接收、发送数据。TCP会话双方都各自维护一个发送窗口和接收窗口。滑动窗口实现面向流的可靠性来源于“确认重传机制”，TCP滑动窗口的可靠性也来源与确认重传。发送窗口只有受到对方对于本段ACK的确认，才会移动左边界。前面还有字节未接收的情况下，窗口不会移动。</p><p>滑动窗口功能的建立与序列号(seq)和确认号(ack)有关<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/14431655D304484BBE6BFCCA8C002539/14203"></p><h3 id="4-6-1-延时确认"><a href="#4-6-1-延时确认" class="headerlink" title="4.6.1 延时确认"></a>4.6.1 延时确认</h3><p>在许多情况下，TCP并不对每个到来的数据包都反回ACK，利用TCP的累积ACK字段就能实现该功能。累积确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传的数据结合发送。这种捎带传输的方法经常用于批量数据传输。</p><h3 id="4-6-2-Nagle算法"><a href="#4-6-2-Nagle算法" class="headerlink" title="4.6.2 Nagle算法"></a>4.6.2 Nagle算法</h3><p>当一个TCP连接中有在传数据（已发送还未经确认的数据）时，小的报文段（长度小于SMSS（发送发最大报文段））就不能被发送，直到所有的在传数据都收到ACK。在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。</p><h3 id="4-6-3-零窗口与TCP持续计时器"><a href="#4-6-3-零窗口与TCP持续计时器" class="headerlink" title="4.6.3 零窗口与TCP持续计时器"></a>4.6.3 零窗口与TCP持续计时器</h3><p>TCP通过接受端的通告窗口来实现流量控制。通告窗口指示了接受端可接受的数据量。当窗口值变为0时，可以阻止发送端继续发送，直到窗口大小恢复非零值。</p><p>当接收端重新获得可用空间时，会给发送端传输一个窗口更新，告知其可以继续发送数据。这样的窗口更新不包含数据，且没有可靠性，如果丢失，双方就一直处于等待状态。</p><p>为防止这种死锁发生，发送方会采用一个持续计时器间歇性地查询接收端，看其窗口是否增长。持续计时器会触发窗口探测地传输，强制要求接受端返回ACK（包含窗口大小）。</p><h3 id="4-6-4-糊涂窗口综合征"><a href="#4-6-4-糊涂窗口综合征" class="headerlink" title="4.6.4 糊涂窗口综合征"></a>4.6.4 糊涂窗口综合征</h3><p>通告窗口较小时，发送端会立即发送数据填满该窗口，这样在连接中就会出现大量高耗费地小数据包。对发送端来说，通告窗口较小应该避免发送小数据包；接受端应该尽量避免通告小窗口。</p><h2 id="4-7-TCP拥塞控制"><a href="#4-7-TCP拥塞控制" class="headerlink" title="4.7 TCP拥塞控制"></a>4.7 TCP拥塞控制</h2><p>计算机网络中的带宽、交换节点中的缓存和处理机等都是网络的资源。某段时间，网络需求超过了可用部分，网络性能就会变坏，这被称为拥塞。拥塞控制就是防止过多的网络流量注入到网络中。TCP拥塞控制由四个核心算法组成：满开始、拥塞避免、快速重传和快速恢复。</p><h3 id="4-7-1-慢开始和拥塞避免"><a href="#4-7-1-慢开始和拥塞避免" class="headerlink" title="4.7.1 慢开始和拥塞避免"></a>4.7.1 慢开始和拥塞避免</h3><p>发送发维持一个拥塞窗口的状态变量，拥塞窗口取决于网络的拥塞程度。发送方让自己的发送窗口等于拥塞窗口。考虑到接收方的接受能力，发送窗口可能小于拥塞窗口.</p><p>慢开始的思路就是一开始不发送大量的数据，先探测网络的拥塞程度。由小到大增加拥塞窗口。</p><ol><li>当主机发送数据时，如果将较大的发送窗口全部注入到网络中，可能引起拥塞</li><li>可以试探一下，由小到大增大拥塞窗口的数量</li><li>慢开始从1个MSS开始指数增长，为了防止其增长过大，设置一个门限ssthresh，当其达到门限时，变为拥塞避免算法。</li></ol><p>拥塞避免算法是使拥塞窗口缓慢增长，每经过一个RTT就将拥塞窗口加一。</p><ol><li>TCP连接初始化，拥塞窗口为1</li><li>执行慢开始算法，cwind指数增长，指导cwind=ssthresh时，开始拥塞避免算法.</li><li>当网络拥塞时（超时的丢包事件）将ssthresh设为当前的一半，cwind设为1重新开始。<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/4F66217AA2F845A78641437C306527C2/14119"><br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/EDC9663545AF4AD6A45CB43613576031/14121"></li></ol><h3 id="4-7-2-快重传和快恢复"><a href="#4-7-2-快重传和快恢复" class="headerlink" title="4.7.2 快重传和快恢复"></a>4.7.2 快重传和快恢复</h3><p>快重传要求接收方受到一个失序的报文段后立即发送重复确认（为使发送方尽早知道报文段为传到对方）。快重传规定只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必继续等待。</p><p>快重传还配合有快恢复，主要思想包括：</p><ol><li>一旦受到三个重复确认，执行乘法减小，ssthresh门限减半，但是并不执行慢开始</li><li>将cwind（拥塞窗口）设为ssthresh，执行拥塞避免算法。</li></ol><p>整体上，TCP拥塞窗口的原则时加法增大、乘法减小。可以看出TCP较好的保证了流之间的公平性，一旦丢包就减半退让。</p><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/2C6EDD14FA124DAB8595CC1BD14B186D/14123"><br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/8BFF5B63C99D44619D066B60F7409CBE/14125"></p><p>ACK号与接收端缓存中的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为失序数据，因为这些数据和之前接收的序列号不连续。合理采用SACK信息能更快地实现空缺填补，且能减少不必要地重传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-相关概念&quot;&gt;&lt;a href=&quot;#1-相关概念&quot; class=&quot;headerlink&quot; title=&quot;1 相关概念&quot;&gt;&lt;/a&gt;1 相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;网络层提供了&lt;strong&gt;主机&lt;/strong&gt;之间的逻辑通信，运输层协议为不同主机上的&lt;st</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql底层架构</title>
    <link href="http://example.com/2021/02/27/Mysql%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2021/02/27/Mysql%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL架构"><a href="#1-MySQL架构" class="headerlink" title="1 MySQL架构"></a>1 MySQL架构</h1><p><a href="https://www.itzhai.com/articles/insight-into-the-underlying-architecture-of-mysql-buffer-and-disk.html">Mysql底层架构</a></p><p><a href="https://www.jb51.net/article/101062.htm">函数sync、fsync与fdatasync的总结整理</a></p><p><a href="https://www.jianshu.com/p/8991cbca3854">覆盖索引与回表</a></p><p><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">Doublewrite Buffer与redo log</a></p><p><a href="https://www.cnblogs.com/better-farther-world2099/p/9290966.html">InnoDB事务日志（redo log 和 undo log）详解</a></p><ol><li><p>相关概念：</p><ul><li>内存结构： buffer pool、log buffer、change buffer, buffer pool的页淘汰机制是怎样的</li><li>磁盘结构：系统表结构、独立表空间、通用表空间、undo表空间、redo log;</li></ul></li><li><p>为什么MySQL使用B+树？</p><ul><li>哈希表虽然可以提供O(1)的单行数据操作性能，但却不能很好的支持排序和范围查找，会导致全表扫描；</li><li>B树可以再非叶子节点存储数据，但是这可能会导致查询连续数据的时候增加更多的I/O操作；</li><li>而B+树数据都存放在叶子节点，叶子节点通过指针相互连接，可以减少顺序遍历时产生的额外随机I/O</li></ul></li><li><p>为什么使用自增主键</p><ul><li>自增主键的插入是递增顺序插入的，每次添加记录都是追加的，不涉及到记录的挪动，不会触发叶子节点的分裂，而一般业务字段做主键，往往都不是有序插入的，写成本比较高，所以我们更倾向于使用自增字段作为主键。</li></ul></li><li><p>聚集索引</p><ul><li>当在表上面定义了PRIMARY KEY之后，InnoDB会把它作为聚集索引。</li><li>如果您没有为表定义PRIMARY KEY，则MySQL会找到第一个不带null值的UNIQUE索引，并其用作聚集索引；</li><li>如果表没有PRIMARY KEY或没有合适的UNIQUE索引，则InnoDB 内部会生成一个隐藏的聚集索引GEN_CLUST_INDEX，作为行ID，行ID是一个6字节的字段，随着数据的插入而自增。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MySQL架构&quot;&gt;&lt;a href=&quot;#1-MySQL架构&quot; class=&quot;headerlink&quot; title=&quot;1 MySQL架构&quot;&gt;&lt;/a&gt;1 MySQL架构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.itzhai.com/articles/i</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://example.com/2021/02/27/Mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/02/27/Mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><p>Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。</p><p>哈希索引对应哈希表，InnoDB BTree 对应 B+ Tree</p><p><a href="https://www.cnblogs.com/l199616j/p/11232392.html">Mysql索引详解</a></p><h2 id="1-MyISAM-与-InnoDB-Index的区别"><a href="#1-MyISAM-与-InnoDB-Index的区别" class="headerlink" title="1 MyISAM 与 InnoDB Index的区别"></a>1 MyISAM 与 InnoDB Index的区别</h2><ul><li>MyISAMl（非聚集索引）: B+ 树叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li><li>InnoDB(聚集索引), 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></li><li>聚集索引适用的场合：<ul><li>包含大量非重复值的列。</li><li>使用下列运算符返回一个范围值的查询：BETWEEN、&gt;、&gt;=、&lt; 和 &lt;=。</li><li>被连续访问的列。</li><li>返回大型结果集的查询。</li><li>经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。</li><li>OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。</li></ul></li></ul><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/3D230F580DE94664934DB386CE5D48C8/3566" alt="应用场景"></p><p><a href="https://blog.csdn.net/alexdamiao/article/details/51934917">MYSQL索引：对聚簇索引和非聚簇索引的认识</a></p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2 索引"></a>2 索引</h2><ul><li>索引：索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li></ul><h3 id="2-1-索引的优点"><a href="#2-1-索引的优点" class="headerlink" title="2.1 索引的优点"></a>2.1 索引的优点</h3><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><blockquote><p>使用索引的原因：访问磁盘块时，若访问非键字段，需要遍历表空间 On。添加所用可以使用二分查找，降低到logN</p></blockquote><h3 id="2-2-索引的缺点"><a href="#2-2-索引的缺点" class="headerlink" title="2.2 索引的缺点"></a>2.2 索引的缺点</h3><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h3 id="2-3-索引的使用"><a href="#2-3-索引的使用" class="headerlink" title="2.3 索引的使用"></a>2.3 索引的使用</h3><p>添加：</p><ol><li>INDEX indexName (Field_name(length))</li><li>ALTER TABLE table_name ADD INDEX index_name (column_list) (普通索引)</li><li>CREATE INDEX index_name ON table_name (column_list)</li><li>CREATE UNIQUE INDEX index_name ON table_name (column_list) (UNIQUE索引)</li></ol><p>删除：</p><ol><li>DROP INDEX [indexName] ON [table_name];</li><li>alter table [table_name] drop index [index_name] ;</li><li>alter table [table_name] drop primary key ;</li></ol><blockquote><p>如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p></blockquote><p>查看：</p><ol><li>SHOW INDEX FROM [table_name];</li><li>show keys from [table_name];</li></ol><h1 id="2-4-针对存储性质的讲解"><a href="#2-4-针对存储性质的讲解" class="headerlink" title="2.4 针对存储性质的讲解"></a>2.4 针对存储性质的讲解</h1><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2 id="3-索引的数据结构B-Tree和B-Tree"><a href="#3-索引的数据结构B-Tree和B-Tree" class="headerlink" title="3 索引的数据结构B-Tree和B+Tree"></a>3 索引的数据结构B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.</p><h3 id="3-1-B树"><a href="#3-1-B树" class="headerlink" title="3.1 B树"></a>3.1 B树</h3><p>B树也就是二叉搜索树，也有说法是B树与B-树等价</p><p><a href="https://www.jianshu.com/p/1775b4ff123a">B树和B-树的剖析（建树过程）</a></p><h3 id="3-2-B-Tree"><a href="#3-2-B-Tree" class="headerlink" title="3.2 B-Tree"></a>3.2 B-Tree</h3><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/8F052C172C834AFC8BFF711812E724BE/3601" alt="B-树存储"><br><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606" alt="B-树键结构"></p><p>B-树的键区间为开区间，非叶子节点可结束</p><h3 id="3-3-B-Tree-Mysql"><a href="#3-3-B-Tree-Mysql" class="headerlink" title="3.3 B+Tree(Mysql)"></a>3.3 B+Tree(Mysql)</h3><ol><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的K个关键字。</li><li>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/DB87125DAF1E40B8B1FFFDD842163FD3/3597" alt="B+树存储"><br><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606" alt="B+树键结构"></p><h4 id="3-3-1-B-树的搜索方法"><a href="#3-3-1-B-树的搜索方法" class="headerlink" title="3.3.1 B+树的搜索方法"></a>3.3.1 B+树的搜索方法</h4><ul><li>一种是按叶节点自己拉起的链表顺序搜索。</li><li>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</li></ul><h3 id="3-4-B树和B-树的区别"><a href="#3-4-B树和B-树的区别" class="headerlink" title="3.4 B树和B+树的区别"></a>3.4 B树和B+树的区别</h3><ol><li><p>B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。</p><p> 而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。</p></li><li><p>因为B树键位置不定，且在整个树结构中只出现一次。虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。</p></li><li><p>B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</p></li><li><p>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。 </p></li><li><p>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</p></li></ol><h3 id="3-5-B-树的优点和缺点"><a href="#3-5-B-树的优点和缺点" class="headerlink" title="3.5 B+树的优点和缺点"></a>3.5 B+树的优点和缺点</h3><ol><li>优点</li></ol><ul><li>单次请求涉及的磁盘IO次数少（出度d大， 且非叶子节点不包含表数据，树的高度小）</li><li>查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）；</li><li>遍历效率高（从符合条件的某个叶子节点开始遍历即可）；</li></ul><ol start="2"><li>缺点</li></ol><ul><li>主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片；</li><li>即使主键是有序递增的，大量写请求的分布仍是随机的；</li></ul><ol start="3"><li>解释缺点</li></ol><ul><li>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</li><li>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）</li></ul><p>作者：奈文摩尔ST<br>链接：<a href="https://www.jianshu.com/p/06f9f7f41fdb">https://www.jianshu.com/p/06f9f7f41fdb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><blockquote><p>聚簇优点：物理存储的顺序导致磁盘读取的次数减少</p></blockquote><blockquote><p>B/B+优点：相比二叉搜索树，一个盘块存储的key多，一个读取多个key。读取总的盘块次数减少，时间减少。</p></blockquote><h2 id="4-索引分类"><a href="#4-索引分类" class="headerlink" title="4 索引分类"></a>4 索引分类</h2><ol><li>普通索引</li><li>唯一索引：与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：</li><li>全文索引：（FULLTEXT）： <strong>TODO</strong><ul><li>定义：全文检索是对大数据文本进行索引，在建立的索引中对要查找的单词进行进行搜索，定位哪些文本数据包括要搜索的单词。因此，全文检索的全部工作就是建立索引和在索引中搜索定位，所有的工作都是围绕这两个来进行的。<blockquote><p>如果可能，请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。</p></blockquote></li></ul></li><li>多列索引（组合索引：<br> MySQL能在多个列上创建索引。一个索引可以由最多15个列组成。（在CHAR和VARCHAR列上，你也可以使用列的前缀作为一个索引的部分)。<ul><li>一个多重列索引可以认为是包含通过合并(concatenate)索引列值创建的值的一个排序数组。</li><li>多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格（获得结果集记录数最少）的索引。</li><li>在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li></ul></li></ol><blockquote><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引。</p></blockquote><h3 id="4-1-hash索引和B-树索引区别"><a href="#4-1-hash索引和B-树索引区别" class="headerlink" title="4.1 hash索引和B+树索引区别"></a>4.1 hash索引和B+树索引区别</h3><p><a href="https://blog.csdn.net/qq_44590469/article/details/97877397">Hash索引和B+树索引有什么区别或者说优劣势</a></p><h3 id="4-2-最左匹配原则（针对联合索引）"><a href="#4-2-最左匹配原则（针对联合索引）" class="headerlink" title="4.2 最左匹配原则（针对联合索引）"></a>4.2 最左匹配原则（针对联合索引）</h3><p><a href="https://blog.csdn.net/sinat_41917109/article/details/88944290">讲得不错的最左匹配原则</a></p><h2 id="4-3-索引建立的注意事项"><a href="#4-3-索引建立的注意事项" class="headerlink" title="4.3 索引建立的注意事项"></a>4.3 索引建立的注意事项</h2><ol><li>最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</li><li>尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。</li><li>索引列不能参与计算，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = ‘2016-06-06’ 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP(‘2016-06-06’)。</li><li>尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</li><li>单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。</li></ol><p><a href="https://blog.csdn.net/ss123mlk/article/details/106902596">sql优化：explain关键字</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql索引&quot;&gt;&lt;a href=&quot;#Mysql索引&quot; class=&quot;headerlink&quot; title=&quot;Mysql索引&quot;&gt;&lt;/a&gt;Mysql索引&lt;/h1&gt;&lt;p&gt;Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。&lt;/p&gt;
&lt;p&gt;哈希索引对应哈希表，</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql难点语法</title>
    <link href="http://example.com/2021/02/27/Mysql%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2021/02/27/Mysql%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql难点语法"><a href="#Mysql难点语法" class="headerlink" title="Mysql难点语法"></a>Mysql难点语法</h1><h2 id="1-group-by"><a href="#1-group-by" class="headerlink" title="1 group by"></a>1 group by</h2><p>group by 要与having共用， 不能与where，因为where中不能有聚集函数做为条件表达式</p><p>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数</p><h2 id="2-数据库中的union与union-all的区别"><a href="#2-数据库中的union与union-all的区别" class="headerlink" title="2 数据库中的union与union all的区别"></a>2 数据库中的union与union all的区别</h2><p>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All</p><p> 两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</p><p> union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 </p><p> Union All：对两个结果集进行并集操作，包括重复行，不进行排序； </p><h2 id="3-连表查询比子查询快"><a href="#3-连表查询比子查询快" class="headerlink" title="3 连表查询比子查询快"></a>3 连表查询比子查询快</h2><h2 id="4-按某一属性排序并生成行号序列"><a href="#4-按某一属性排序并生成行号序列" class="headerlink" title="4 按某一属性排序并生成行号序列"></a>4 按某一属性排序并生成行号序列</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row_number() over(partition by customer_id </span><br><span class="line">order by order_date desc)</span><br></pre></td></tr></table></figure><h2 id="5-using连接查询"><a href="#5-using连接查询" class="headerlink" title="5 using连接查询"></a>5 using连接查询</h2><p> sql/92标准可以使用using关键字来简化连接查询，但是只是在查询满足下面两个条件时，才能使</p><p>用using关键字进行简化。</p><ul><li>1.查询必须是等值连接。</li><li>2.等值连接中的列必须具有相同的名称和数据类型。</li></ul><h2 id="6-case-when"><a href="#6-case-when" class="headerlink" title="6 case when"></a>6 case when</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">    when ...</span><br><span class="line">    whem ...</span><br><span class="line">    else ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql难点语法&quot;&gt;&lt;a href=&quot;#Mysql难点语法&quot; class=&quot;headerlink&quot; title=&quot;Mysql难点语法&quot;&gt;&lt;/a&gt;Mysql难点语法&lt;/h1&gt;&lt;h2 id=&quot;1-group-by&quot;&gt;&lt;a href=&quot;#1-group-by&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://example.com/2021/02/27/RabbitMQ/"/>
    <id>http://example.com/2021/02/27/RabbitMQ/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MQ的三个作用"><a href="#1-MQ的三个作用" class="headerlink" title="1 MQ的三个作用"></a>1 MQ的三个作用</h1><ol><li>异步</li><li>解耦，消息统一分发</li><li>流量削峰</li></ol><h1 id="2-AMQP事物机制控制"><a href="#2-AMQP事物机制控制" class="headerlink" title="2 AMQP事物机制控制"></a>2 AMQP事物机制控制</h1><ol><li>txSelect, txCommit, txRollback</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MQ的三个作用&quot;&gt;&lt;a href=&quot;#1-MQ的三个作用&quot; class=&quot;headerlink&quot; title=&quot;1 MQ的三个作用&quot;&gt;&lt;/a&gt;1 MQ的三个作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;解耦，消息统一分发&lt;/li&gt;
&lt;li&gt;流量削峰&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="http://example.com/2021/02/27/dubbo/"/>
    <id>http://example.com/2021/02/27/dubbo/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo是一款高性能的Java RPC框架</p><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=72">ZooKeeper+Dubbo分布式架构基础教程</a></p><ol><li>面向接口的的远程方法调用，智能容错和负载均衡，服务自动注册和发现<h1 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1 RPC"></a>1 RPC</h1></li></ol><ul><li>A服务器的方法调用B服务器的方法，不在同一个内存空间。<ol><li>客户端调用</li><li>序列化</li><li>发送消息</li><li>发序列化</li><li>调用本地服务</li><li>服务处理</li><li>返回结果</li><li>将结果序列化</li><li>返回消息</li><li>反序列化</li><li>返回调用结果<h1 id="2-RMI"><a href="#2-RMI" class="headerlink" title="2 RMI"></a>2 RMI</h1></li></ol></li><li>java原生支持的远程调用，采用JRMP作为通信协议</li><li>client、server、registy注册中心</li></ul><ol><li>大致原理：服务端在注册中心注册服务，客户端从注册中心获取服务具体信息，客户端调用服务端执行服务。</li><li>步骤<ol><li>创建远程接口，继承Remote</li><li>实现远程接口，并且继承UnicastRemoteObject</li><li>启动RMI注册服务，指定端口号</li><li>创建要被访问的远程对象的实例</li><li>把远程对象实例注册到RMI注册服务器上</li></ol></li></ol><h1 id="3-dubbo高可用"><a href="#3-dubbo高可用" class="headerlink" title="3 dubbo高可用"></a>3 dubbo高可用</h1><ol><li>服务路由（包含一条路由规则）<ul><li>dubbo提供了三种服务路由实现（条件路由ConditionRouter、脚本路由ScriptRouter、标签路由TagRouter）</li></ul></li><li>条件路由规则的格式：<ul><li>服务消费者匹配条件 =&gt; 服务提供者匹配条件</li><li>host = 10.20.153.10 =&gt; host = 10.20.153.11</li><li>该条规则表示IP为10.20.153.10的服务消费者止咳调用IP为10.20.153.11机器上的服务，不可调用其他机器上的服务。</li><li>如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。</li><li>包括黑名单、白名单、读写分离、前后天分离</li></ul></li><li>集群容错<ul><li>FailoverCluster,某个服务器产生异常，重试其他服务器，可以设置重试次数。</li><li>Failfast Cluter快速失败，只调用一次，立即报错。通常用于非幂等性的写操作</li></ul></li><li>负载均衡（面试题）<ul><li>随机权重分配，无状态</li><li>轮训服务器，有状态</li><li>活跃计数器随机</li><li>一致性哈希，为IP分配固定的服务器</li></ul></li><li>dubbo降级服务<ul><li>服务降级就是指在由于非主业务异常导致的服务不可用时（服务器宕机/网络超时/并发数太高等），可以返回默认值，避免异常影响主业务的处理</li></ul></li></ol><blockquote><p>zookeeper 和 redis 用于消息中心的很重要的原因是知道断开</p></blockquote><p>Dubbo SPI流程：名字–&gt;文件–&gt;实现类–&gt;对象–&gt;依赖注入–&gt;AOP–&gt;完整的一个对象</p><blockquote><p>Dubbo的依赖注入与spring的区别，注入的是一个属性的代理对象，根据实际要用时传入的url中的实际对象赋真正的值，也就是set的时候并没有确定最终的对象。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dubbo是一款高性能的Java RPC框架&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BA411q7ia?p=72&quot;&gt;ZooKeeper+Dubbo分布式架构基础教程&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向接口的的</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql初学笔记</title>
    <link href="http://example.com/2021/02/27/mysql%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/27/mysql%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql笔记-（关系型数据库）"><a href="#mysql笔记-（关系型数据库）" class="headerlink" title="mysql笔记 （关系型数据库）"></a>mysql笔记 （关系型数据库）</h1><h2 id="一-使用终端操纵数据库"><a href="#一-使用终端操纵数据库" class="headerlink" title="一 使用终端操纵数据库"></a>一 使用终端操纵数据库</h2><h3 id="1-登录数据库"><a href="#1-登录数据库" class="headerlink" title="1. 登录数据库"></a>1. 登录数据库</h3><p>mysql -uroot -p</p><h3 id="2-查询所有数据库"><a href="#2-查询所有数据库" class="headerlink" title="2. 查询所有数据库"></a>2. 查询所有数据库</h3><p>show database;</p><h3 id="3-选中某一数据库操作"><a href="#3-选中某一数据库操作" class="headerlink" title="3. 选中某一数据库操作"></a>3. 选中某一数据库操作</h3><p>use database;</p><h3 id="4-查询"><a href="#4-查询" class="headerlink" title="4.查询"></a>4.查询</h3><p>select * from admin where admin_Id = 1</p><h3 id="5-退出"><a href="#5-退出" class="headerlink" title="5.退出"></a>5.退出</h3><p>exit;或quit;</p><h3 id="6-创建数据库"><a href="#6-创建数据库" class="headerlink" title="6.创建数据库"></a>6.创建数据库</h3><p>create database name;</p><h3 id="7-查看数据库中的数据表"><a href="#7-查看数据库中的数据表" class="headerlink" title="7.查看数据库中的数据表"></a>7.查看数据库中的数据表</h3><p>show tables;</p><h3 id="8-创建数据表"><a href="#8-创建数据表" class="headerlink" title="8.创建数据表"></a>8.创建数据表</h3><p>创建宠物数据表</p><pre><code>CREATE TABLE pet (name VARCHAR(20),owner VARCHAR(20),sex CHAR(1),birth DATE);</code></pre><h3 id="9-查看创建好的数据表"><a href="#9-查看创建好的数据表" class="headerlink" title="9. 查看创建好的数据表"></a>9. 查看创建好的数据表</h3><p>decribe pet;</p><h3 id="10-查看表中记录"><a href="#10-查看表中记录" class="headerlink" title="10 查看表中记录"></a>10 查看表中记录</h3><p>select * from pet;</p><h3 id="11-插入记录"><a href="#11-插入记录" class="headerlink" title="11.插入记录"></a>11.插入记录</h3><pre><code>INSERT INFO petVALUES (&#39;pp&#39;,&#39;mm&#39;,&#39;f&#39;,&#39;1999-03-26&#39;);</code></pre><h3 id="12-mysql-常用数据类型"><a href="#12-mysql-常用数据类型" class="headerlink" title="12.mysql 常用数据类型"></a>12.mysql 常用数据类型</h3><p>数值<br>类型|大小|范围（有符号|范围(无符号)|用途<br>-|:-:|:-:|:-:|:-:|-</p><p>日期/时间</p><p>字符串</p><p>数据类型选择 日期按照格式 数值和字符串按照大小</p><h3 id="13-删除数据"><a href="#13-删除数据" class="headerlink" title="13. 删除数据"></a>13. 删除数据</h3><p>delete from pet where name =’pp’;</p><h3 id="14-修改数据"><a href="#14-修改数据" class="headerlink" title="14.修改数据"></a>14.修改数据</h3><p>update pet set name=’旺财’ where owner = ‘mm’;</p><h3 id="15-mysql建表约束条件"><a href="#15-mysql建表约束条件" class="headerlink" title="15.mysql建表约束条件"></a>15.mysql建表约束条件</h3><p>1.主键约束</p><pre><code>id int(11) primary key</code></pre><p>它能够唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束就可以使该字段不重复且不为空。</p><p>可以有多个主键，主键联合约束。只要联合的主键值加起来不同即可。但联合主键每一个都不能为空。</p><ol start="2"><li><p>自增约束</p><p> primary key auto_increment<br>与主键约束搭配起来进行自增</p></li></ol><p>忘记添加主键，创建后添加</p><pre><code>alter table user4 add primary key(id);</code></pre><p>输出表结构主键</p><pre><code>alter table user4 drop primary key;</code></pre><p>修改字段主键约束</p><pre><code>alter table user4 modify id int primary key;</code></pre><ol start="3"><li>外键约束</li></ol><p><a href="https://blog.csdn.net/wdd199801140310/article/details/102984378">有主从表|主外键关系时删除表和删除数据</a></p><p>涉及到两个表，一个是主表，一个是副标，或父表，子表，外键设置在副表上</p><pre><code>create table classes(    id int primary key,    name varchar(20));create table students(    id int primary key,    name varchar(20),    class_id int,    foreign key(class_id) references classes(id));</code></pre><p>副表中的外键值要参照主表， 1.主表中没有的数据值，副表不能使用。2.被副表引用的主表值不允许被删除。</p><ol start="4"><li>唯一约束</li></ol><p>约束修饰的字段的值不可以重复</p><pre><code>name carchar(20) uniquealter table user add unique(name); </code></pre><p>可以unique(name, id)<br>这两个件在一起不重复就可以。</p><p>删除唯一约束</p><pre><code>alter table user drop index name</code></pre><p>modify 添加</p><pre><code>alter table user modify name varchar(20 unique);</code></pre><ol start="5"><li>非空约束</li></ol><p>修饰的字段不能为空</p><pre><code>create table user (    id int,    name varchar(20) not null);</code></pre><p>单独插入会报错</p><pre><code>insert into user (name) values &#39;list&#39;;</code></pre><ol start="6"><li>默认约束</li></ol><p>插入字段时，如果没有传值，使用默认值</p><pre><code>age int default 20</code></pre><h3 id="16-数据库设计三大设计范式"><a href="#16-数据库设计三大设计范式" class="headerlink" title="16.数据库设计三大设计范式"></a>16.数据库设计三大设计范式</h3><p>1.第一范式 1NF</p><p>数据表中的所有字段都是不可分割的原子值</p><pre><code>create table user (    id int primary key,    name varchar(20),    address varchar(30));</code></pre><p>字段值还可以继续拆分， 就不满足第一范式, 上表不满足第一范式</p><pre><code>create table user (    id int primary key,    name varchar(20),    cuntry varchar(30),    province varchar(30),    city varchar(30));</code></pre><p>上表拆分比较详细，满足第一范式。</p><p>范式设计一般来说越详细越好，但还是要根据具体工程。</p><ol start="2"><li>第二范式</li></ol><p>必须是满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖主键</p><p>如果出现不完全依赖，只可能发生在联合主键的情况下。某字段只依赖其中一个主键。</p><p>如果实在要这样，设计成外键关联，拆分表。</p><p>3.第三范式 3NF</p><p>必须先满足第二范式，除开主键列的其他列之间不能有传递依赖。不能有冗余依赖。需要拆分。</p><h3 id="17-查询联系"><a href="#17-查询联系" class="headerlink" title="17.查询联系"></a>17.查询联系</h3><p>学生表<br>Student<br>学号<br>姓名<br>性别<br>出生年月日<br>所在班级</p><pre><code>create table student &#123;    sno varchar(20) primary key,    sname varcher(20) not null,    ssex varchar(10) not null,    sbirthday datatime,    class varchar(20)&#125;</code></pre><p>成绩表<br>Score<br>学号<br>课程号<br>成绩</p><pre><code>create table score(    sno varchar(20) not null,    cno varchar(20) not null,    degree decimal,    foreign key(sno) references student(sno),    foreign key(cno) references course(cno),    primary key(sno, cno));</code></pre><p>查询所有记录 select * from student;</p><p>查询指定记录，（某些字段）， select sname, ssex, class from student;</p><p>查询不重复的depart列<br>select distinct depart from teacher;</p><p>查询区间<br>select * from score where degree between 60 and 80;<br>或者运算符比较<br>select * from score where degree &gt; 60 and degree &lt; 80;</p><p>查询或关系<br>select * from score where degree in (85, 86, 88);</p><p>查询表中性别为女的同学记录<br>select * from student where class=’95031’ or ssex=’女’;</p><p>以class降序查询<br>select * from student order by class desc;<br>默认升序或者arc</p><p>以cno升序，degree 降序查询所有记录<br>select * from score order by cno asc, degree desc;</p><p>查询总人数 count<br>select count(*) from student where class=’95031’;</p><p>查询最高分<br>select sno,cno from score where degree=(selectmax(degree) from score);</p><p>查询每门课的平均成绩</p><p>select avg(degree) from score where cno=’3-105’</p><p>select cno,avg(degree) from score group by cno;</p><p>查询score表中至少有两名学生选修的并以3开头的课程</p><p>select cno, avg(degree),count(*)) from score group by  cno having count(cno)&gt;=2 and cno like ‘3%’;</p><p>查询分数大于70小于90的sno列</p><p>select sno,degree from score where degree&gt;70 and degree &lt; 90;<br>或者用between and</p><p>多表查询</p><p>查询所有学生的sname, cno和degree</p><p>select sname,con,degree from student,score where student.sno=score.sno;</p><p>三表关联查询(重点)<br>通过字段相等联查</p><p>select sname,cname,degree from student,course,score where student.sno=score.sno and course.cno=score.cno;</p><p>查询’95031’班学生每门课的平均分</p><p>select cno,avg(degree) from score where sno in (select sno from student where class=’95031’) group by cno;</p><ol start="18"><li>查询”3-105”课程的成绩高于”109”号同学 “3-105”成绩的所有同学的记录。</li></ol><p>select * from score where cno= ‘3-105’ and degree &gt; (select degree from score where sno=’109’ and cno=’3-105’);</p><p>查询和学号为108、101的同学同年出生的所有学生的sno\sname和sbirthday列</p><p>select * from student where year(sbirthday) in (select year(sbirthday) from student where sno in (108, 101));</p><p>查询 “张旭” 教师任课的学生成绩</p><p>select * from score where cno =(select cno from course where tno= (select * from teacger where tname= ‘张旭’));</p><p>查询选修某课程的同学人数多于5人的教师姓名。</p><p>select tname from teacher where tno = (select tno from course where cno = (select cno from score groupby cno having count(*) &gt; 5;));</p><p>查询95033班和95031班全体学生的记录。</p><p>select * from student where class in (‘95031’, ‘95033’);</p><p>查询存在成绩在85分以上的课程的cno</p><p>select * from score where degree&gt;85;</p><p>查询出 “计算机系” 教师所有课程的成绩表</p><p>select * from score where cno in (select cno from course where tno in (select tno from teacher where depart= ‘计算机系’;));</p><p>查询 “计算机系” 与 “电子工程系”不同职称的教师的tnam和prof</p><p>union 求并集</p><p>select * from teacher where depart = ‘计算机系’ and prof not in (select prof from teacher where depart = ‘电子工程系’)<br>union<br>select * from teacher where depart = ‘电子工程系’ and prof not in (select prof from teacher where depart = ‘计算机系’)</p><p>查询选修编号为 “3-105”课程且成绩至少高于选修课程 “3-245”的同学的cno,sno和degree,并且按degree从高到低排序</p><p>select * from score where cno = ‘3-105’ and degree &gt; any(select degree from score where cno = ‘3-245’) order by degree desc;</p><p>查询选修编号为 “3-105”<br>且成绩高于选修编号为 “3-245” 的同学的 cnp\sno 和 degree</p><p>select * from score where cno= ‘3-105’ and degree&gt;all(select degree from score where cno=’3-245’);</p><p>查询所有教师和同学的name,sex和birthday</p><p>select tname as name,tsex as sex,tbirthday as birthday from teacher<br>union<br>select sname,ssex,sbirthday from student</p><p>查询成绩比该课程平均成绩低的同学的成绩表</p><p>select * from score a where degree &lt; (select avg(degree) from score b where a.cno=b.cno);</p><p>查询至少有两名男生的班号</p><p>select class from student where ssex= ‘男’ group by class having count(*)&gt;1;</p><p>查询student 表中最大值和最小sbirthday日期值</p><p>select max(sbirthday) as ‘最大’，min(sbirthday) as ‘最小’ from student;</p><h3 id="18-SQL的四中连接查询"><a href="#18-SQL的四中连接查询" class="headerlink" title="18 SQL的四中连接查询"></a>18 SQL的四中连接查询</h3><p>内连接<br>inner join 或者 join</p><p>外连接<br>1.左连接 left join 或者 left outer join</p><p>2.右连接 right join 或 outer join</p><p>3.完全外连接 full join 或者 full outer join</p><pre><code>create table person(    id int,    name varchar(20),    cardId int);create table card(    id int,    name varchar(20),);</code></pre><p>insert into person values();</p><p>inner join查询<br>select * from person inner join card on person.cardId = card.id;</p><p>内联查询，就是两章表中的数据，通过某个字段相对，查询出相关记录数据。</p><p>left join（左外连接）</p><p>select * from person left join card on person.cardId=card.id;</p><p>左外连接吧左边表里的所有数据取出来，右边表有相等显示出来，没有就会补null</p><p>right join（右外连接）</p><p>select * from person right (outer) join card on person.cardId=card.id;</p><p>同左外连接，左右互换</p><p>full join(全外链接)</p><p>select * from person full join card on person.cardId=card.id;</p><p>mysql不支持full join<br>求出两边表的并集</p><p>mysql通过union实现</p><p>select * from person left join card on person.cardId=card.id<br>union<br>select * from person right join card on person.cardId=card.id;</p><h3 id="20-mysql-事务"><a href="#20-mysql-事务" class="headerlink" title="20.mysql 事务"></a>20.mysql 事务</h3><p>mysql中，事务湿气重一个最小的不可分割的单元，事务能够保证一个业务的完整性。</p><p>多条mysql同时成功或者同时失败的要求。</p><p>mysql是默认开起事务的</p><p>默认事务开启的作用</p><p>当我们去执行一个sql语句时，效果立刻体现，不会回滚。</p><p>回滚是rollback；</p><p>设置自动提交为false<br>set autocommit=0;</p><p>begin或者start transaction 开启一个事务，之后可以回滚<br>直到commit</p><p>事务的四大特征</p><p>A.原子性：事务是最小单位，不可以分割</p><p>C.一致性：事务要求，同一事物中的sql语句必须同时成功或失败</p><p>I。隔离性：事务1和事务2之间具有隔离性。</p><p>D.持久性：事物一旦结束（commit,rollback），就不可以返回。</p><p>事务开启</p><p>1.修改默认提交 set autocommit=0;</p><p>2.begin</p><p>3.start transaction</p><p>事务的隔离性</p><p>1.read uncommited (读未提交)</p><p>事务对数据进行操作，在操作过程中，事务没有被提交，但是b可以看见a操作的结果。</p><p>查看隔离级别mysql8.0</p><p>系统级别</p><p>select @@global.transaction_isolation;</p><p>会话级别</p><p>select @@transaction_isolation</p><p>设置</p><p>set global transaction isolation level read uncommited;</p><p>这种读未提交的叫做脏读</p><p>2.read commited<br>(读已经提交)</p><p>3.repeatable read<br>(可以重复读)</p><p>4.serializable<br>(串行化)</p><h2 id="二-使用可视化工具操纵数据库"><a href="#二-使用可视化工具操纵数据库" class="headerlink" title="二 使用可视化工具操纵数据库"></a>二 使用可视化工具操纵数据库</h2><h2 id="三-在编程语言中使用数据库"><a href="#三-在编程语言中使用数据库" class="headerlink" title="三 在编程语言中使用数据库"></a>三 在编程语言中使用数据库</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql笔记-（关系型数据库）&quot;&gt;&lt;a href=&quot;#mysql笔记-（关系型数据库）&quot; class=&quot;headerlink&quot; title=&quot;mysql笔记 （关系型数据库）&quot;&gt;&lt;/a&gt;mysql笔记 （关系型数据库）&lt;/h1&gt;&lt;h2 id=&quot;一-使用终端操纵数</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库事务并发锁</title>
    <link href="http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%94%81/"/>
    <id>http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%94%81/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务并发锁"><a href="#数据库事务并发锁" class="headerlink" title="数据库事务并发锁"></a>数据库事务并发锁</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h2><h3 id="1-1-事务的特性"><a href="#1-1-事务的特性" class="headerlink" title="1.1 事务的特性"></a>1.1 事务的特性</h3><ul><li><p>A(Atomicity)原子性</p><p>  一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>C（Consistency）一致性</p><p>  (consistency)事务在完成时，必须使所有的数据都保持一致状态。事务结束时，所有的内部数据结构（如B树索引或双向链表）都必须是正确的。</p></li><li><p>I（Isolation）隔离性</p><p>  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。    </p></li><li><p>D（Durability）持续性</p><p>  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><blockquote><p>一致性和原子性的区别：原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。</p></blockquote><blockquote><p>而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见</p></blockquote><h3 id="1-2-一致性、原子性举例"><a href="#1-2-一致性、原子性举例" class="headerlink" title="1.2 一致性、原子性举例"></a>1.2 一致性、原子性举例</h3><p>举个例子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。</p><p>那么反驳的声音来了：</p><p>要么转账操作全部成功，要么全部失败，这是原子性。从例子上看全部成功，那么一致性就是原子性的一部分咯，为什么还要单独说一致性和原子性</p><p>你说的不对。在未提交读的隔离级别下是事务内部操作是可见的，明显违背了一致性</p><h2 id="2-并发（锁相关）"><a href="#2-并发（锁相关）" class="headerlink" title="2 并发（锁相关）"></a>2 并发（锁相关）</h2><h3 id="6-1-并发基础"><a href="#6-1-并发基础" class="headerlink" title="6.1 并发基础"></a>6.1 并发基础</h3><blockquote><p>并发控制的解决方式<br>    - 封锁（锁） - 时间戳 - 乐观控制法</p></blockquote><p><a href="https://www.cnblogs.com/3013218061shang/p/5573476.html">https://www.cnblogs.com/3013218061shang/p/5573476.html</a></p><p>这里要注意意向锁<br><a href="https://blog.csdn.net/u010841296/article/details/87909468">https://blog.csdn.net/u010841296/article/details/87909468</a></p><p>多版本并发控制（mvcc）</p><p>而解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。</p><p>理论上可重复读由加悲观锁实现，实际上mysql由MVCC控制（不是第三级别封锁协议）。<br>MVCC解决了不可重复读，间隙锁（当前读）/MVCC（快照读）解决了幻读。</p><h3 id="2-1-四种隔离级别："><a href="#2-1-四种隔离级别：" class="headerlink" title="2.1 四种隔离级别："></a>2.1 四种隔离级别：</h3><ol><li><p>读未提交ReadUncommitted:（对于数据而言，写之前加X锁，直到事务结束释放X锁，对应一级封锁协议，但没有锁读，不能解决脏读、不可重复读，幻读）</p><p> 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读。</p></li><li><p>读取提交内容ReadCommitted：（一级封锁协议+读之前加S锁，读完数据释放S锁，对应二级封锁协议，不能解决不可重复读，幻读）</p><p> 这是大多数数据库系统的默认隔离级别（比如SQLSever，Oracle，但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p></li><li><p>可重复读RepeatableRead（可以使用二级封锁协议+MVCC使得当前事务只能读取不高于其事务版本的数据，也可以使用三级封锁协议（一级封锁协议+读之前加S锁，直到事务结束释放S锁），不能解决幻读）</p><p> RepeatableRead（可重读）这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致幻读。</p></li><li><p>可串行Serializable</p><blockquote><p>可重复读与幻读的区别是：可重复读是更改表中行级数据，而幻读是增加表中行级数据，可串行化使得所有的事务必须串行化执行，解决了一切并发问题，但会造成大量的等待、阻塞甚至死锁，使系统性能降低</p></blockquote><p> 这是最高的隔离级别，它通过强制事务排序，使之不可能相互 冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p></li></ol><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/317E94A12F594FF0B1B8FFC24376F003/3017"></p><blockquote><p>并发导致的问题<br>丢失修改：第一级别解决（写锁）<br>脏读：第二级别解决（读锁）<br>不可重复读：第三级别解决（读锁到事务结束）或者MVCC（Mysql）<br>幻读：表锁、MVCC、间隙锁</p></blockquote><h3 id="2-2-InnoDB存储引擎中的实现"><a href="#2-2-InnoDB存储引擎中的实现" class="headerlink" title="2.2 InnoDB存储引擎中的实现"></a>2.2 InnoDB存储引擎中的实现</h3><ol><li>与 SQL 标准不同的地方在于InnoDB 存储引擎在 **REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)**隔离级别。</li><li>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</li><li>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</li></ol><h3 id="2-3-幻读和不可重复读"><a href="#2-3-幻读和不可重复读" class="headerlink" title="2.3 幻读和不可重复读"></a>2.3 幻读和不可重复读</h3><ul><li><p>幻读定义：事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 称为幻读。</p></li><li><p>不可重复读：如果事务A 按一定条件搜索， 期间事务B 删除或修改了符合条件的某一条数据，导致事务A 再次读取时数据少了一条。这种情况归为 不可重复读。</p></li></ul><ol><li><p>在快照读（snapshot read）的情况下，MySQL通过MVCC（多版本并发控制）来避免幻读。</p><blockquote><p>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。主要应用于无需加锁的普通查询（select）操作。</p></blockquote></li><li><p>在当前读（current read）的情况下，MySQL通过next-key lock来避免幻读。</p><blockquote><p>当前读，读取的是记录的最新版本，并且会对当前记录加锁，防止其他事务发修改这条记录。加行共享锁（SELECT … LOCK IN SHARE MODE ）、加行排他锁（SELECT … FOR UPDATE / INSERT / UPDATE / DELETE）的操作都会用到当前度。</p></blockquote></li></ol><h3 id="2-4-innoDB的间隙锁-Next-Key-Lock"><a href="#2-4-innoDB的间隙锁-Next-Key-Lock" class="headerlink" title="2.4 innoDB的间隙锁/Next-Key Lock"></a>2.4 innoDB的间隙锁/Next-Key Lock</h3><ol><li><p>前提条件</p><ul><li>innoDB的间隙锁只存在于 RR 隔离级别（可重复读）</li><li>所以希望禁用间隙锁，提升系统性能的时候，可以考虑将隔离级别降为 RC。（读已提交）</li></ul></li><li><p>间隙锁/Next-Key Lock</p><p> 间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生：</p><ul><li><p>防止间隙内有新数据被插入。</p></li><li><p>防止已存在的数据，更新成间隙内的数据。</p><p>innoDB支持三种行锁定方式：</p></li><li><p>行锁（Record Lock）：锁直接加在索引记录上面（无索引项时演变成表锁）。</p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别的。</p></li><li><p>Next-Key Lock ：行锁和间隙锁组合起来就是 Next-Key Lock。</p><p>innoDB默认的隔离级别是可重复读(Repeatable Read)，并且会以Next-Key Lock的方式对数据行进行加锁。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><p>当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围。</p></li></ul></li><li><p>何时使用行锁，何时产生间隙锁</p><p> 对何时使用Next-Key Lock 做出说明：</p><ol><li>只使用唯一索引查询，并且只锁定一条记录时，innoDB会使用行锁。</li><li>只使用唯一索引查询，但是检索条件是范围检索，或者是唯一检索然而检索结果不存在（试图锁住不存在的数据）时，会产生 Next-Key Lock。</li><li>使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁。</li><li>同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁。</li></ol></li></ol><h3 id="2-5-MVCC"><a href="#2-5-MVCC" class="headerlink" title="2.5 MVCC"></a>2.5 MVCC</h3><p><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc</a></p><p>MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p><ol><li><p>ReadView(快照)</p><p> 已提交读和可重复读的区别就在于它们生成ReadView的策略不同。<br> 已提交读：每次读生成一个新的快照<br> 可重复读: 读的是之前生成的快照</p><p> ReadView中保存着当前系统中活跃着的读写事务， 也就是begin了还未提交的事务。假设当前列表中的id为[80, 100]。</p><ul><li>如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</li><li>如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。</li><li>如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。</li></ul></li><li><p>MVCC 如何实现可重复读</p><p> 如果一个事务p修改字段A为A0，但为提交。读A的时候，获得快照1，最新的A值为A1。此时提交了事务p，再新建事务，修改A的值为A2。此时读select。</p><p> 如果是读已提交，会创建新快照2，最新的值为A0。</p><p> 如果是可重复读，会读之前的快照1，最新值仍未A1。实现了可重复读。</p><blockquote><p>若要按照数据库第三级别封锁协议，则需要在事务结束前，一直保持读锁，没有其他事务修改，也就不会出现不可重复读的现象。</p></blockquote></li><li><p>MVCC如何解决幻读</p><p> 事务会读取版本号&lt;=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。</p></li></ol><h2 id="3-体现隔离级别（封锁技术）（锁相环）"><a href="#3-体现隔离级别（封锁技术）（锁相环）" class="headerlink" title="3 体现隔离级别（封锁技术）（锁相环）"></a>3 体现隔离级别（封锁技术）（锁相环）</h2><h3 id="3-1-读写锁"><a href="#3-1-读写锁" class="headerlink" title="3.1 读写锁"></a>3.1 读写锁</h3><ul><li>S 锁： 共享锁，读锁，被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加s锁，不可以加x锁。</li><li>X锁，Exclusive Locks，排他锁，写锁，被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能<strong>读取和修改</strong>该对象。</li></ul><h3 id="3-2-解决死锁"><a href="#3-2-解决死锁" class="headerlink" title="3.2 解决死锁"></a>3.2 解决死锁</h3><blockquote><p>两段锁协议（会出现死锁）：<br>两段锁协议是为了保证事务并发调度的正确性，简称 2PL 协议。第一阶段是获得锁：扩展阶段：只允许加锁；第二阶段是释放封锁：收缩阶段：只允许解锁；</p></blockquote><ul><li><p>预防法</p><ul><li>一次封锁法（不发生死锁）： 每个事务必须将所用到的数据全部加锁，否则不能执行</li><li>顺序封锁法：对用到的数据按照预先设定的顺序加锁</li></ul></li><li><p>诊断解除法</p><ul><li>超时法：<br>一事务超过规定时间则判定发生死锁</li><li>等待图法：<br>事务等待图是一个有向图G=(T,U)，T为结点的集合，每个结点表示正在运行的事务；U为边的集合，每条边表示事务等待的情况。若事务T1等待事务T2，则T1，T2之间有一条有向边，从 T1 指向 T2。如果发现图中存在回路，则表示系统中出现了死锁。</li></ul></li></ul><h3 id="3-3-封锁协议"><a href="#3-3-封锁协议" class="headerlink" title="3.3 封锁协议"></a>3.3 封锁协议</h3><h4 id="3-3-1-保证数据一致性的封锁协议的三级封锁协议"><a href="#3-3-1-保证数据一致性的封锁协议的三级封锁协议" class="headerlink" title="3.3.1 保证数据一致性的封锁协议的三级封锁协议"></a>3.3.1 保证数据一致性的封锁协议的三级封锁协议</h4><p>对并发操作的不正确调度可能会带来的三种数据不一致性：丢失修改（同时修改导致的）、不可重复读（读的时候有人修改）和读“脏”数据。三级封锁协议分别在不同程度上解决了这一问题。</p><ul><li><p>1级封锁协议：事务T修改数据R之前必须先对其X加锁，直到事务结束才释放。事务结束包括正常结束和非正常结束。1级封锁协议可防止丢失修改，并保证事务T是可恢复的。在1级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。</p></li><li><p>2级封锁协议：1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。2级封锁协议除防止了丢失修改，还可进一步防止读”脏”数据。（防止读的时候有人修改）</p></li><li><p>3级封锁协议：1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结果才释放。3级封锁协议除防止丢失修改和不读“脏”数据外，还进一步防止了不可重复读。 </p><blockquote><p>事务结束释放S锁，意味着读的时候，谁都不能改（并发低）。</p></blockquote></li></ul><p>总结：</p><p>一级封锁协议：</p><pre><code>   要求修改数据时必须加X锁，直到事务结束才释放锁</code></pre><p>二级封锁协议：</p><pre><code>   要求修改数据时必须加X锁，直到事务结束才释放锁    要求读取数据时必须加S锁，读取完马上释放S锁(无需等待事务结束)</code></pre><p>三级封锁协议：</p><pre><code>   要求修改数据时必须加X锁，直到事务结束才释放锁   要求读取数据时必须加S锁，直到事务结束才释放S锁</code></pre><h4 id="3-3-2-为什么二级封锁协议可以解决脏读？"><a href="#3-3-2-为什么二级封锁协议可以解决脏读？" class="headerlink" title="3.3.2 为什么二级封锁协议可以解决脏读？"></a>3.3.2 为什么二级封锁协议可以解决脏读？</h4><p>前面我们说过脏读产生的原因：因为B事务读取到了A事务修改过尚未提交的数据，根据二级封锁协议要求：读数据的时候必<br>须加S锁，但因为A事务在修改的时候已经加了X锁，在X锁的基础上是不能加S锁的，所以B事务无法获取S锁，就会导致B事务无法读取A事务中正在操作的数据，从而避免了脏读的发生。</p><h4 id="3-3-3-为什么三级封锁协议可以解决不可重复读？"><a href="#3-3-3-为什么三级封锁协议可以解决不可重复读？" class="headerlink" title="3.3.3 为什么三级封锁协议可以解决不可重复读？"></a>3.3.3 为什么三级封锁协议可以解决不可重复读？</h4><p>前面我们也说过了不可重复读产生的原因：是因为B事务读取到了A事务已经修改过的数据，导致前后两次读取的数据不一致。现根据三级封锁协议的要求：读取数据时必须加S锁，在S锁的基础上只能加S锁，不能加X锁，所以在B事务读取数据期间，A事务无法对数据进行修改，从而避免了不可重复读问题的发生。</p><h3 id="3-4-意向锁-表锁，相互兼容，表明“某个事务持有了锁、或准备去持有锁”"><a href="#3-4-意向锁-表锁，相互兼容，表明“某个事务持有了锁、或准备去持有锁”" class="headerlink" title="3.4 意向锁 表锁，相互兼容，表明“某个事务持有了锁、或准备去持有锁”"></a>3.4 意向锁 表锁，相互兼容，表明“某个事务持有了锁、或准备去持有锁”</h3><ul><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</li><li>意向共享锁（IS锁）：事务在请求S锁前，要先获得IS锁</li><li>意向排他锁（IX锁）：事务在请求X锁前，要先获得IX锁</li><li>例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。</li></ul><h4 id="3-4-1-为什么意向锁是表级锁"><a href="#3-4-1-为什么意向锁是表级锁" class="headerlink" title="3.4.1 为什么意向锁是表级锁"></a>3.4.1 为什么意向锁是表级锁</h4><p>当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）；</p><ol><li>如果意向锁是行锁，则需要遍历每一行数据去确认；</li><li>如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</li></ol><h4 id="3-4-2-意向锁怎么支持表锁和行锁并存"><a href="#3-4-2-意向锁怎么支持表锁和行锁并存" class="headerlink" title="3.4.2 意向锁怎么支持表锁和行锁并存"></a>3.4.2 意向锁怎么支持表锁和行锁并存</h4><ol><li>首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。</li><li>如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如q1的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。</li><li>也就是说，在加表锁前要保证表中没有行锁，这也是意向锁出现的原因。</li></ol><h4 id="3-4-3-意向锁和共享锁、排他锁的兼容关系。"><a href="#3-4-3-意向锁和共享锁、排他锁的兼容关系。" class="headerlink" title="3.4.3 意向锁和共享锁、排他锁的兼容关系。"></a>3.4.3 意向锁和共享锁、排他锁的兼容关系。</h4><blockquote><p>上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行</p></blockquote><p>意向锁可以理解为通知该级别范围的上级范围，其内部有读锁或者写锁。</p><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/C9ED4BA3CD45421EB1620CFB5033B596/3159"></p><blockquote><p>关于S与IX不兼容可以这样理解：当对表加读锁时，不允许修改内部文件，故与IX不兼容。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库事务并发锁&quot;&gt;&lt;a href=&quot;#数据库事务并发锁&quot; class=&quot;headerlink&quot; title=&quot;数据库事务并发锁&quot;&gt;&lt;/a&gt;数据库事务并发锁&lt;/h1&gt;&lt;h2 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloud_netflix</title>
    <link href="http://example.com/2021/02/27/springcloud_netflix/"/>
    <id>http://example.com/2021/02/27/springcloud_netflix/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springcloud生态"><a href="#springcloud生态" class="headerlink" title="springcloud生态"></a>springcloud生态</h1><p><a href="https://www.bilibili.com/video/BV1jJ411S7xr?p=15">springcloud</a></p><h2 id="1-4-个问题"><a href="#1-4-个问题" class="headerlink" title="1 4 个问题"></a>1 4 个问题</h2><ol><li>API （解决网关）</li><li>HTTP， RPC（解决分布式通讯）</li><li>注册和发现（解决高可用）</li><li>熔断机制（进行服务降级）</li></ol><p>微服务：将单一的应用程序划分成一组小的服务</p><blockquote><p>mycat 数据库读写分离  elastic search</p></blockquote><p>spring cloud netflix</p><p>spring cloud 中国社区·</p><p>eureca是对应zookeeper的</p><h2 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2 Eureka"></a>2 Eureka</h2><p>是Netflix的一个子模块，是一个机遇rest的服务</p><ol><li>导入依赖</li><li>编写配置文件</li><li>开启这个功能@Enable</li><li>配置类</li></ol><p>eureka好死不如赖活着</p><p>eureka与zookeeper区别</p><p>CAP三选二<br>C 强一致性<br>A 可用性<br>P 分区容错性</p><p>zookeeper保证的是CP，enreka保证的是AP</p><blockquote><p>面试题，两者的区别</p></blockquote><h2 id="3-ribbon"><a href="#3-ribbon" class="headerlink" title="3 ribbon"></a>3 ribbon</h2><ol><li>spring cloud ribbon 是基于netflix实现的一套客户端负载均衡工具</li></ol><p>nginx是集中时，由nginx决定分发给谁</p><p>ribbon是进程时，由消费方通过注册中心获取所有可用，通过算法决定如何选择。</p><blockquote><p>feign是面向接口版本的ribbon, 也是负载均衡的</p></blockquote><h2 id="4-Hystrix"><a href="#4-Hystrix" class="headerlink" title="4 Hystrix"></a>4 Hystrix</h2><p>Hystrix 可以提供服务熔断和服务降级</p><p>服务熔断机制是对应雪崩效应的一种微服务链路保护机制</p><p>相关概念，备份，服务降级</p><p>服务熔断是提供者，服务降级是消费者</p><p>降级是客户端的，因为后台为了释放资源已经关闭了，可以用feign配合hystrix来进行</p><p>服务熔断：服务端，某个服务超时或者异常，引起熔断，保险丝</p><p>服务降级：客户端，从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再会被调用，不走服务器。此时在客户端，我们可以准备一个FallbackFactory，返回一个默认的值，但整体服务水平下降了。</p><h1 id="5-路由网关-zuul"><a href="#5-路由网关-zuul" class="headerlink" title="5 路由网关 zuul"></a>5 路由网关 zuul</h1><ol><li>身份验证和安全性</li><li>监控</li><li>动态路由</li><li>压力测试</li><li>减载</li><li>静态响应处理</li><li>多区域弹性</li></ol><blockquote><p>统一路由，统一权限认证</p></blockquote><p>通过配置文件对请求进行路由和过滤</p><h1 id="6-spring-cloud-config"><a href="#6-spring-cloud-config" class="headerlink" title="6 spring cloud config"></a>6 spring cloud config</h1><p>config为微服务架构中的微服务提供集中化的外部配置支持 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springcloud生态&quot;&gt;&lt;a href=&quot;#springcloud生态&quot; class=&quot;headerlink&quot; title=&quot;springcloud生态&quot;&gt;&lt;/a&gt;springcloud生态&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilib</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloudalibaba</title>
    <link href="http://example.com/2021/02/27/springcloudalibaba/"/>
    <id>http://example.com/2021/02/27/springcloudalibaba/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-nacos实时QPS"><a href="#1-nacos实时QPS" class="headerlink" title="1 nacos实时QPS"></a>1 nacos实时QPS</h1><p>服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户端，由客户端进行服务限流降级等操作。客户端的操作行为也会被推送到服务端，从而形成QPS</p><h1 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h1><ol><li>服务发现组件nacos</li><li>配置中心组件nacos</li><li>断路保护组件sentinel</li><li>远程组件dubbo,而原来是Openfeign</li><li>seata分布式事务</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-nacos实时QPS&quot;&gt;&lt;a href=&quot;#1-nacos实时QPS&quot; class=&quot;headerlink&quot; title=&quot;1 nacos实时QPS&quot;&gt;&lt;/a&gt;1 nacos实时QPS&lt;/h1&gt;&lt;p&gt;服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://example.com/2021/02/27/zookeeper/"/>
    <id>http://example.com/2021/02/27/zookeeper/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1 zookeeper"></a>1 zookeeper</h1><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=31">zookeeper+Dubbo</a></p><p>包括数据发布订阅、负载均衡、命名服务、集群管理分布式锁、分布式队列等功能。</p><ol><li>zookeeper提供了分布式数据一致性解决方案</li></ol><p>一致性：</p><ul><li>强一致性：锁机制、如果数据不一致，不提供服务</li><li>最终一致性：数据最终同步即可，没有实时性要求</li></ul><ol start="2"><li>CAP原则（一致性、可用性和分区容错性）</li></ol><ul><li>一致性：指的是强一致性 (C)</li><li>可用性：服务一直处于可用状态 (A)</li><li>分区容错性：在遇到任何网络分区故障，仍需要对外提供一致性和可用性服务。(P)<br>3选2， 要么AP 要么CP</li></ul><ol start="2"><li><p>一致性协议</p><ul><li><p>2PC二阶段提交</p><ul><li>阶段一预执行，但事务没有提交</li><li>阶段二执行事务提交或者中断事务，如果所有参与者都返回ack，则执行事务，否则中断<blockquote><p>这一个过程需要协调者</p><br></blockquote></li></ul></li><li><p>二阶段提交的问题</p><ul><li>同步阻塞：协调者发送消息后需要阻塞</li><li>单点：如果协调者挂了，就完了</li><li>脑裂导致数据不一致：如果协调者与某个节点断开，有些节点提交了，有些没有不一致</li></ul></li><li><p>3PC阶段提交</p><ul><li>阶段1，协调者向所有参与者发送canCommit询问，能否响应事务请求，相当于网络测试</li><li>阶段2，如果阶段1所有节点都能通讯，所有都执行预提交，也就是preCommit操作预提交，如果某个节点返回no或等待超时，则则中断事务。</li><li>阶段3，doCommit，如果所有阶段2都成功，执行提交，发送提交请求，否则中断事务。</li></ul></li><li><p>3PC解决了同步阻塞和单点问题，一个是超时时间解决同步阻塞，一个是如果协调者在三阶段挂了，其他节点没收到commit会自动提交</p></li></ul></li><li><p>paxos算法</p><ul><li>基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题的最有效的算法。</li><li>解决问题，在分布式系统中，如果产生宕机或网络异常，快速的正确的在集群内部解决数据一致性问题（过半理念）zookeeper基于 fast paxos版本</li><li>paxos中的四个角色<ul><li>client：产生提案者</li><li>peoposer：提案者</li><li>acceptor：决策者</li><li>learners: 学习者（只遵循最后的结果）</li></ul></li><li>paxos分为两个阶段<ul><li>阶段1：prepare阶段：准备解决</li><li>阶段2：accept阶段：同意阶段</li></ul></li><li>prepare阶段<ul><li>proposer做出一个提案，编号为n发送给所有acceptor。</li><li>第一次接受prepare请求：maxN被保存，同时响应</li><li>不是第一次，每个决策者保存一个最大提案号maxN,如果n小于maxN，证明提案已过时，拒绝。如果大于maxN，更新maxN，进行响应。</li><li>如果收到的响应过半，立刻进入第二阶段。</li></ul></li><li>accept阶段<ul><li>传递编号n和value， (n, value)，如果n大于等于maxN,同意提案，进行响应。如果小于，那么拒绝提案，不会响应。</li></ul></li></ul><ol><li> 活锁问题（解决办法，执行时间稍稍错开）</li></ol></li><li><p>zookeeper 使用的是ZAB（Fast Paxos），因为Paxos存在活锁和全序的问题</p></li></ol><ul><li>ZAB（zookeeper atomic broadcast）：是一种支持崩溃恢复的原子广播协议</li><li>Zookeeper使用单一主进程Leader处理客户端发送过来的所有事务请求（写清求）。当服务器数据发生变更后，会把请求包装成提案，发送给所有follower，只要follower达到半数，同意请求，之后leader通知所有follower，进行同步数据。读请求的话，leader会自己响应。</li><li>如果客户端发送到follower上的话，如果是读请求，follwer自己响应，否则是写清求的话，会将请求转发给leader，走leader的流程。</li></ul><ol start="5"><li>zookeeper的三种角色</li></ol><ul><li>leader：主要负责处理集群的写清求，并发起投票，只有超过半数的节点同意后才会提交该写请求</li><li>follower：处理读请求，响应结果。转发写清求得到leader,并在选举leader过程中参与投票。</li><li>observer：可以理解为没有投票权的follower，主要职责是协助follower处理读请求，当整个zk集群读请求负载很高时，增加。如果增加follower会增加写请求负载，因为follower也要投票。</li></ul><ol start="5"><li>zookeeper两种模式</li></ol><ul><li>恢复模式：当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，完成leader和其他机器的同步，当大多数server完成和leader的同步后，恢复模式结束。</li><li>广播模式：一旦leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li><li>在ZAB的事务的二阶段提交中，移除了事务的中断，要么ack，要么放弃，leader无需等待所有的follower的ack.</li></ul><ol start="6"><li>zxid</li></ol><ul><li>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid</li></ul><ol start="7"><li>leader选举原则<ol><li>zookeeper集群只有超过了半数以上的服务器启动，集群才能正常工作</li><li>在集群正常工作之前，myid小的服务器会给myid大服务器进行投票，持续到集群正常工作，选出leader</li><li>选出leader之后，之前的服务器的状态由looking改变为following,之后的服务器都是follower</li></ol></li><li>zab解决全序问题，因为事务执行顺序不同，导致结果不同，leader会创建一个队列，保证最终结果。</li></ol><blockquote><p>相关操作</p></blockquote><blockquote><ol><li>ls path watch 监听节点子节点的变化</li></ol></blockquote><blockquote><ol start="2"><li>get path watch 监听节点值的变化</li></ol></blockquote><blockquote><ol start="3"><li>监听的有效期只有一次</li></ol></blockquote><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h1><ol><li>配置中心</li></ol><ul><li>把配置信息存在节点中，通过监听来同步</li></ul><ol start="2"><li>负载均衡</li></ol><ul><li>新增服务器，让nginx知道服务器列表的更新。通过监听器监视servers子节点的状态变化。</li></ul><ol start="3"><li>命名服务</li></ol><ul><li>创建顺序节点保证唯一标识</li></ul><ol start="4"><li>DNS服务</li><li>集群管理<ol><li>集群控制：对集群中节点进行操作与控制</li><li>集群监控：对集群节点运行状态的收集</li></ol></li></ol><ul><li>zookeeper集群管理主要利用了watcher机制和创建临时节点来实现。比如机器上下线：<ul><li>新增机器的时候，将Agent部署到新增的机器上，当Agent部署启动时，会向zookeeper指定的节点下创建一个临时子节点，通过监视器，对机器的上下线进行监控。</li><li>当子节点创建完成后，机器会接受到”子节点变更事件”，即上限通知，就可以对新加入的机器开启相应的后台管理逻辑。监控中心同样可以获得到机器的运行状态信息。</li></ul></li></ul><ol start="6"><li>分布式锁<ol><li>数据库实现分布式锁，让不同的服务器操作同一个数据库。使用dblock.lock();添加一条记录，lock_name:db_lock_stock。注意这个lock_name是惟一的，如果已经存在，需要阻塞。</li><li>redis实现分布式锁，基于setnx（set if not exists），设置成功返回1，否则返回0.要注意设置过期时间，防止异常，expire name time。redis为了解决单点问题，官方推出了分布式锁redlock</li><li>zookeeper实现分布式锁<ul><li>原理：创建有序临时节点+watch监听来实现。每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己剩下的临时节点的序号是否是最小的。如果是最小的，将会获取到锁，执行相关操作，释放锁。如果不是最小的，会监听它的前一个节点，当它的前一个节点被删除时，它就会获得锁，依次类推。</li></ul></li></ol></li><li>分布式队列：跟分布式锁相似，监听之前的节点是否出列</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-zookeeper&quot;&gt;&lt;a href=&quot;#1-zookeeper&quot; class=&quot;headerlink&quot; title=&quot;1 zookeeper&quot;&gt;&lt;/a&gt;1 zookeeper&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903490196619272">操作系统内存管理</a></p><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">图解内存管理</a>(重点)</p><h1 id="1-存储区体系"><a href="#1-存储区体系" class="headerlink" title="1 存储区体系"></a>1 存储区体系</h1><p>主存（RAM）是一件非常重要的资源，不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多。</p><h2 id="1-1-分层存储器体系-memory-hierarchy"><a href="#1-1-分层存储器体系-memory-hierarchy" class="headerlink" title="1.1 分层存储器体系(memory hierarchy)"></a>1.1 分层存储器体系(memory hierarchy)</h2><p><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/DCDF99335BF54511A72AC2890C6F17FD/14946" alt="存储层次结构"></p><h2 id="1-2-无存储抽象"><a href="#1-2-无存储抽象" class="headerlink" title="1.2 无存储抽象"></a>1.2 无存储抽象</h2><p>将物理内存暴露给进程的缺点：</p><ol><li>如果用户程序可以寻址内存的每个字节，他们就可以很容易的破坏操作系统，从而使系统停止运行。</li><li>难以运行多个程序（地址冲突）</li></ol><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><blockquote><p>MMU(内存管理单元)：硬件组件负责处理CPU的内存访问请求</p></blockquote><h2 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h2><p>更好的支持多道程序并发执行，提高系统性能。进程之间共享的不仅仅是处理机，还有主存储器。如果不对内存进行管理，容易导致内存数据的混乱。</p><h2 id="2-2-内存管理功能"><a href="#2-2-内存管理功能" class="headerlink" title="2.2 内存管理功能"></a>2.2 内存管理功能</h2><ul><li>内存空间的分配与回收</li><li>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</li><li>内存空间的扩充：虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li><li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li><li>程序装入和链接<h2 id="2-3-逻辑地址空间和物理地址空间"><a href="#2-3-逻辑地址空间和物理地址空间" class="headerlink" title="2.3 逻辑地址空间和物理地址空间"></a>2.3 逻辑地址空间和物理地址空间</h2></li><li>编译后，每个目标模块都是从0号单元开始编址（逻辑地址），链接程序顺序依次按各个模块的相对地址构成从0号单元开始编址的逻辑地址空间。</li><li>物理地址空间指内存中物理单元的集合。通过物理地址在主存中存取数据。</li><li>当装入程序将可执行代码装入内存时，必须通过地址转换讲逻辑地址转换成物理地址，这个过程称为地址重定位<h2 id="2-4-内存保护"><a href="#2-4-内存保护" class="headerlink" title="2.4 内存保护"></a>2.4 内存保护</h2></li></ul><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p><ul><li>设置上下限寄存器存放主存中的上下限地址判断是否越界。</li><li>采用重定位寄存器（基址寄存器，存放最小的物理地址值）和界地址寄存器（限长寄存器，存放逻辑地址的最大值）。<h1 id="3-管理方式"><a href="#3-管理方式" class="headerlink" title="3 管理方式"></a>3 管理方式</h1></li></ul><h2 id="3-0-逻辑地址与物理地址的转换"><a href="#3-0-逻辑地址与物理地址的转换" class="headerlink" title="3.0 逻辑地址与物理地址的转换"></a>3.0 逻辑地址与物理地址的转换</h2><ol><li>ALU需要某个逻辑地址的内存的内容</li><li>内存管理单元（MMU）寻找在逻辑地址和物理地址之间的映射，如果没有就从内存中找。（操作系统完成）</li><li>控制器从总线发送在物理内存内容的请求</li><li>内存发送物理地址给CPU</li></ol><h2 id="3-1-连续分配管理方式"><a href="#3-1-连续分配管理方式" class="headerlink" title="3.1 连续分配管理方式"></a>3.1 连续分配管理方式</h2><ol><li>单一连续分配：分配到内存固定区域，只适合单任务系统</li><li>固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不相等。内部碎片（已经被分配出去（能明确是哪个线程），却不能被利用的内存空间）<ul><li>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</li></ul></li><li>动态分区分配：按程序的需要进程动态划分。外部碎片（还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。）<ul><li>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br><a href="https://www.cnblogs.com/sjlove/archive/2013/06/05/3119683.html">外部碎片和内部碎片</a><h2 id="3-2-空闲内存管理"><a href="#3-2-空闲内存管理" class="headerlink" title="3.2 空闲内存管理"></a>3.2 空闲内存管理</h2>在进行内存动态分配时，操作系统必须对其进行管理。一般来说，有两种监控内存使用的方式</li></ul></li></ol><ul><li>位图（bitmap）（基于表的）：使用位图方法时，内存被划分为分配单元，每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。位图的大小取决于内存和分配单元的大小。</li><li>位图的分配：找到连续的0。</li><li>空闲列表（free lists）（基于链的）：维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点会包含进程或者是两个进程间的空闲区域。</li><li>空闲列表的分配：（动态分区分配算法）<br><br>(如果为进程和空闲区维护各自独立的链表，就能集中精力只检查空闲区而不是进程，但这种分配速度的提高的一个不可避免的代价就是增加复杂度和内存释放速度变慢，因为必须将一个回收的段从进程链表中删除并插入空闲区链表)<ol><li>首次适配：从头开始扫描，直到找到一个足够大的空闲区</li><li>下次适配：从上次结束的地方开始扫描</li><li>最佳适配：从头到尾扫描，找到能容纳进程的最小空闲区。会产生大量无用的小缓冲区。</li><li>最差适配：总是分配最大的内存区域（不会分裂出小缓冲区）</li><li>快速适配：为常用大小的空闲区维护单独的链表。<br>[位图和空闲链表]<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">https://blog.csdn.net/qq_22238021/article/details/80175461</a>)</li></ol></li></ul><h2 id="3-3-非连续分配管理方式"><a href="#3-3-非连续分配管理方式" class="headerlink" title="3.3 非连续分配管理方式"></a>3.3 非连续分配管理方式</h2><p>对于内存的连续分配，总是会有碎片的产生，内存利用率低，而且执行碎片整理的方法也都是有开销的。因此，非连续内存分配就能很好的解决碎片问题，也是操作系统中用的最多的内存分配方法。<br>非连续分配（分页/分段）允许一个程序分散地装入到不相邻的内存分区中去。</p><h3 id="3-3-1-基本分页存储管理方式"><a href="#3-3-1-基本分页存储管理方式" class="headerlink" title="3.3.1 基本分页存储管理方式"></a>3.3.1 基本分页存储管理方式</h3><p><a href="https://zhuanlan.zhihu.com/p/87514615">分页分段解释较好</a></p><p>内存分为固定的块，按物理结构划分，会有内部碎片</p><ol><li>基本概念<ul><li>页<ul><li>一定大小字节数内存单元，属于逻辑单元。进程中所有代码、数据等信息均按页进行存储，属于逻辑组织形式。每个页有页码及其他信息。</li></ul></li><li>页框<ul><li>对应页字节数的物理内存，属于物理单元，是实际存在于物理内存中的可用地址单元。页框相当于页的容器，进程运行过程中，可能会动态加载不同页进入页框，CPU则直接对页框进行存取。</li></ul></li><li>页表<ul><li>既然有页和对应页框，那就必须有映射表将两者联系起来，而页表就是页和页框之间的映射表。换言之，知道页就可以查询到页框，知道页框，也可以查询到对应页。</li></ul></li><li>进程中的块称为页，内存中的块称为页框，外存以同样的单位进行划分，称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框。</li><li>地址结构 页号 + 页内偏移量</li><li>页表 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建3立一张页表，记录页面在内存中对应的物理块号。页表一般放在内存中。</li></ul></li><li>基本地址变换机构<br><br>页式管理中地址空间是一维的<br><br>两个主要问题：<ul><li>每次访问操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低</li><li>每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li></ul></li><li>具有快表的地址变换机构</li></ol><ul><li>若页表全部放在内存中，则存取一条数据或指令至少需要访问两次内存：一次访问页表，确定物理地址，第二次存取数据或指令</li><li>快表/联想寄存器/TLB 在地址变换机构中的一个具有并行查找能力的高速缓冲存储器。用来存放当前访问的若干页表项，以加速地址变换的过程。主存中的页表称为慢表。</li></ul><ol start="4"><li>两级页表<br><br>一级页号+二级页号+页内偏移</li><li>分页和分段的区别<ul><li>页是信息的物理单位，分页是为了减少内存碎片，提高内存利用率。分页仅仅是由于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它包含一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统确定，逻辑地址的划分是由寄存器实现的，因而一个系统只能有一种大小的页面。段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<h3 id="3-3-2-基本分段存储管理模式"><a href="#3-3-2-基本分段存储管理模式" class="headerlink" title="3.3.2 基本分段存储管理模式"></a>3.3.2 基本分段存储管理模式</h3></li></ul></li></ol><p>内存块的大小不固定，按逻辑结构划分，会有外部碎片。</p><h1 id="4-内存扩充"><a href="#4-内存扩充" class="headerlink" title="4 内存扩充"></a>4 内存扩充</h1><h2 id="4-1-覆盖"><a href="#4-1-覆盖" class="headerlink" title="4.1 覆盖"></a>4.1 覆盖</h2><p>在较小的内存中运行较大的内存，将没有调用关系的程序放在一个分区。可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分里即将访问的段放进覆盖区，其他段放在外存。<br><img src="http://note.youdao.com/yws/public/resource/375267987e6a5e59121a79328ccdf2bc/xmlnote/BE6AB4C1E94E42FD8718721D3956E4C3/15170"><br>B，D，E没有调用关系，也就是说，在调用B时，不可能同时调用D或E，所以共享一个覆盖区。早期用这个技术来节约内存。</p><h2 id="4-2-交换"><a href="#4-2-交换" class="headerlink" title="4.2 交换"></a>4.2 交换</h2><p>将暂时不能运行的程序送到外存，从而获得空闲内存空间。粒度是一个程序，需要操作系统支持，对程序员透明。</p><p>把处于等待状态的程序从内存移到辅存，把内存空间腾出来（换出）。把准备好竞争CPU运行的程序从辅存移到内存（换入）</p><ol><li>覆盖与交换的比较<ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间。</li><li>交换技术是在以内存中的程序大小为单位来进行的，一般一页以上。不需要程序员给出各个模块之间的逻辑覆盖结构。</li><li>覆盖和交换都有它的局限性，覆盖过于麻烦，而交换的粒度太大，以程序为单位。所以需要虚拟内存技术。</li></ul></li></ol><h2 id="4-3-虚拟内存"><a href="#4-3-虚拟内存" class="headerlink" title="4.3 虚拟内存"></a>4.3 虚拟内存</h2><p>随着软件的不断增大，需要运行的程序往往大到内存无法容纳。应用交换技术并不是很高效（交换几GB的内存）。</p><p>虚拟内存使用了外存上的空间来扩充内存的空间，通过一定的换入换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，导致平均访存时间下降，如果使用了不合适的替换算法，则会<br>大大降低系统性能。</p><ul><li>虚拟存储器：对物理存储器的抽象，允许程序申请大于实际物理存储的内存，提供一致性的地址空间。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统讲所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放要掉入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</li><li>内存管理单元（Memory Management Unit， MMU），MMU把虚拟地址映射为物理内存地址。</li></ul><h3 id="4-3-1-局部性原理"><a href="#4-3-1-局部性原理" class="headerlink" title="4.3.1 局部性原理"></a>4.3.1 局部性原理</h3><ul><li>时间局部性：如果一条指令被执行或某个数据被访问过，那么不久以后该指令可能再次执行，该数据可能再次被访</li><li>空间局部性：如果某个单元被访问过，那么不久之后它周围的空间也会被访问。<h3 id="4-3-2-特征"><a href="#4-3-2-特征" class="headerlink" title="4.3.2 特征"></a>4.3.2 特征</h3></li></ul><ol><li>多次性， 无需在作业时一次性全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性，无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出</li><li>虚拟性，从逻辑上扩充内存的容量，用户看到的内存容量，远大于实际的内存容量<h3 id="4-3-3-虚拟技术内存的实现"><a href="#4-3-3-虚拟技术内存的实现" class="headerlink" title="4.3.3 虚拟技术内存的实现"></a>4.3.3 虚拟技术内存的实现</h3></li><li>一定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序访问到的部分尚未调入内存，则产生中断</li><li>地址变换机构，逻辑地址到物理地址的变换</li></ol><h3 id="4-3-4-请求分页管理方式"><a href="#4-3-4-请求分页管理方式" class="headerlink" title="4.3.4 请求分页管理方式"></a>4.3.4 请求分页管理方式</h3><ol><li>页表机制</li></ol><ul><li>页号</li><li>物理块号</li><li>保护位：允许对该页做何种类型的访问（只读、可读写、）</li><li>驻留位：指示该页在内存还是在外存</li><li>访问字段A：记录本页在一段时间内被访问的次数，或多长时间未被访问（用于页面置换算法）</li><li>修改位M：标识该页在调入内存后收否被修改过</li><li>外存地址：该页在外存上的地址</li></ul><ol start="2"><li>缺页中断机构</li></ol><ul><li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成时唤醒），如果内存中有空闲块则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页。（若被淘汰页在内存期间被修改过，则要将其写回外存）</li></ul><ol start="3"><li>地址变换机构<br><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/8E649EF21B8F4CDCB559DDDAE97F147E/15122"></li></ol><h3 id="4-3-5-页面置换算法（决定应该换入哪页，换出哪页）"><a href="#4-3-5-页面置换算法（决定应该换入哪页，换出哪页）" class="headerlink" title="4.3.5 页面置换算法（决定应该换入哪页，换出哪页）"></a>4.3.5 页面置换算法（决定应该换入哪页，换出哪页）</h3><ol><li>最佳置换算法（OPT）：选择在最长时间内不在被访问的页面换出。实际上该算法无法使用</li><li>先进先出（FIFO）页面置换算法：淘汰最早进入内存的页面</li><li>最近最久未使用（LRU）置换算法：选择最长时间未访问的页面淘汰需要TLB实现（硬件支持 双向链表+hash</li><li>时钟（CLOCK）（Not Recently Used，NRU）置换算法：循环扫描缓冲区，像时钟的针一样转动。给每一帧关联一个使用位。当缺页错误出现时，首先检查指针指向的页面，如果R位是0就淘汰页面，并把新页面插入，然后表针前移；如果R位是1就清零前移。和第二次算法性能差不多，花费更少时间，实际使用的算法.</li><li>工作集置换算法，一个进程当前使用的页面的集合称为工作集。</li><li>工作集时钟页面置换算法</li><li>LFU（ Least Frequently Used，最不频繁使用）两个双向链表+hash</li><li>第二次机会页面置换算法：在FIFO基础上增加使用位，如果链首使用位是1则清零加入链尾。相比FIFO性能大大提高</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903490196619272&quot;&gt;操作系统内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_29677867/article/details/91038</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>创建型模式</title>
    <link href="http://example.com/2021/02/27/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/27/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;noodle&quot;)) &#123;</span><br><span class="line">            Food noodle &#x3D; new LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(&quot;more&quot;);</span><br><span class="line">            return noodle;</span><br><span class="line">        &#125; else if (name.equals(&quot;chicken&quot;)) &#123;</span><br><span class="line">            Food chicken &#x3D; new HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(&quot;potato&quot;);</span><br><span class="line">            return chicken;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单工厂模式可以理解为根据类名，通过if else创建不同的类。一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><h1 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 工厂模式</h1><p>定义一个接口，接口中有方法，不同的实际类会实现这个接口，这个方法会创建对象，这样通过多态就可以创建对象。每个工厂可以生产多个产品。</p><h1 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3 抽象工厂模式"></a>3 抽象工厂模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简单工厂模式&quot;&gt;&lt;a href=&quot;#1-简单工厂模式&quot; class=&quot;headerlink&quot; title=&quot;1 简单工厂模式&quot;&gt;&lt;/a&gt;1 简单工厂模式&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="http://example.com/2021/02/27/Http/"/>
    <id>http://example.com/2021/02/27/Http/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http1-0和Http1-1"><a href="#Http1-0和Http1-1" class="headerlink" title="Http1.0和Http1.1"></a>Http1.0和Http1.1</h1><ol><li>http1.0</li></ol><ul><li>客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li><li>浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接</li></ul><ol start="2"><li>http1.1</li></ol><ul><li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用：HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来，HTTP1.1在请求头引入range头域，它允许只请求资源的某个部分，即返回码是206.</li><li>错误通知管理：在HTTP1.1中新增了24个错误状态响应码。</li><li>Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。</li><li>长连接</li></ul><ol start="3"><li>HTTPS</li></ol><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><ol start="4"><li>spdy（http1.x改进）</li></ol><ul><li>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。<ol><li>使用多路复用，（多个请求共用一个tcp），降低了延迟</li><li>允许对多个请求设置优先级</li><li>header进行压缩</li><li>基于https</li></ol></li></ul><ol start="2"><li>http2.0<ol><li>http2.0与spdy区别</li></ol><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 HPACK <a href="http://http2.github.io/http2-spec/compression.html%EF%BC%8C%E8%80%8C%E9%9D%9E">http://http2.github.io/http2-spec/compression.html，而非</a> SPDY 采用的 DEFLATE <a href="http://zh.wikipedia.org/wiki/DEFLATE">http://zh.wikipedia.org/wiki/DEFLATE</a></li></ul><ol start="2"><li>其余改进与spdy差别不大</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Http1-0和Http1-1&quot;&gt;&lt;a href=&quot;#Http1-0和Http1-1&quot; class=&quot;headerlink&quot; title=&quot;Http1.0和Http1.1&quot;&gt;&lt;/a&gt;Http1.0和Http1.1&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;http1.0&lt;/li&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统常见问题</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同步和异步的区别"><a href="#1-同步和异步的区别" class="headerlink" title="1 同步和异步的区别"></a>1 同步和异步的区别</h1><p>同步和异步通常用来形容一次方法调用</p><ul><li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li><li>异步方法调用更像一个消息传递，一旦开始，方法调用就回立即返回，调用者就可以继续后续的操作。异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。<h1 id="2-进程和线程的区别，谁调度的进程"><a href="#2-进程和线程的区别，谁调度的进程" class="headerlink" title="2 进程和线程的区别，谁调度的进程"></a>2 进程和线程的区别，谁调度的进程</h1></li></ul><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、数据段和堆栈段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的话费远比进程要小很多，同时创建一个线程的开销也比进程小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。但是如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。<h1 id="3-死锁的条件，如何检查死锁"><a href="#3-死锁的条件，如何检查死锁" class="headerlink" title="3 死锁的条件，如何检查死锁"></a>3 死锁的条件，如何检查死锁</h1></li></ol><ul><li>死锁的定义： 多个进程因为竞争资源而造成一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</li><li>死锁的必要条件：互斥、不剥夺、请求和保持、循环等待</li><li>解决死锁：破坏条件，资源剥夺、撤销进程，进程回退</li><li>用银行家算法预防和避免死锁。</li></ul><h1 id="4-调度算法有哪些"><a href="#4-调度算法有哪些" class="headerlink" title="4 调度算法有哪些"></a>4 调度算法有哪些</h1><p>先来先服务、最短寻道时间、扫描算法、Look算法</p><h1 id="5-进程的状态转换图及转换事件"><a href="#5-进程的状态转换图及转换事件" class="headerlink" title="5 进程的状态转换图及转换事件"></a>5 进程的状态转换图及转换事件</h1><h1 id="6-进程的通信机制"><a href="#6-进程的通信机制" class="headerlink" title="6 进程的通信机制"></a>6 进程的通信机制</h1><p>临界区、互斥量、信号量、事件</p><p>管道、具名管道、消息队列、共享内存、信号量</p><ul><li>管道： 父子进程通过管道通信，管道是一种两个进程间单向通信的机制，因为管道传递数据的单向性，管道又被称为半双工管道，管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。（没有名字、大小受限、没有格式的字节流）</li><li>具名管道：FIFO，提供一个路径名与之关联，存在与文件系统中，这样即使与创建FIFO的进程不存在亲缘关系的进程，只要可以访问路径，就能够通过彼此的FIFO通信。因此，通过FIFO不相关进程也能交换数据</li><li>消息队列：消息队列用与同一机器上的进程间通信，与管道类似，是一个系统内核中保存消息的队列，在内核中以消息链表的形式出现。消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。</li><li>共享内存：共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的程序间共享和传递数据的一种非常有效的方式。不同进程间的内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的内存空间中，所有进程都可以访问共享内存中的地址。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及统一进程内不同线程之间的同步手段。</li></ul><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">内存管理</a></p><p><a href="https://blog.csdn.net/qq_43684985/article/details/109255207">文件管理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-同步和异步的区别&quot;&gt;&lt;a href=&quot;#1-同步和异步的区别&quot; class=&quot;headerlink&quot; title=&quot;1 同步和异步的区别&quot;&gt;&lt;/a&gt;1 同步和异步的区别&lt;/h1&gt;&lt;p&gt;同步和异步通常用来形容一次方法调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步方法调用一</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统相关概念</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统（operating-System，-OS）"><a href="#1-操作系统（operating-System，-OS）" class="headerlink" title="1 操作系统（operating System， OS）"></a>1 操作系统（operating System， OS）</h1><p>操作系统是计算机系统中最基本的系统软件</p><h2 id="1-1-操作系统作用"><a href="#1-1-操作系统作用" class="headerlink" title="1.1 操作系统作用"></a>1.1 操作系统作用</h2><ol><li>管理分配资源，组织调度计算机的工作<ul><li>处理机管理（进程管理）</li><li>存储器管理（内存）</li><li>文件管理（文件系统）</li><li>设备管理（I/O）</li></ul></li><li>为用户和其他软件提供接口和环境。<ul><li>命令接口：用户利用这些命令来组织和控制作业的运行<ul><li>交互式命令接口（联机）</li><li>批处理命令接口（脱机）</li></ul></li><li>程序接口：系统调用，请求操作系统服务。<h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2 操作系统特征"></a>1.2 操作系统特征</h2></li></ul></li><li>并发：两个或多个事件在同一时间间隔内发生。通过分时实现。</li><li>共享：指系统中的资源可供内存中多个并发的进程共同使用。<ul><li>互斥共享方式</li><li>同时访问方式</li></ul></li><li>虚拟： 把一个物理上的实体变为若干个逻辑上的对应物。</li><li>异步：并发执行时，由于资源有限，进程的执行不是一贯到底而是走走停停，以不可预知的速度向前推进。<h2 id="1-3-操作系统的运行机制"><a href="#1-3-操作系统的运行机制" class="headerlink" title="1.3 操作系统的运行机制"></a>1.3 操作系统的运行机制</h2></li><li>内核态：操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。内核态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令,包括：<ul><li>时钟管理：计时中断实现进程切换</li><li>中断机制</li><li>原语：<ul><li>处于操作系统的最底层，是最接近硬件的部分</li><li>操作不可中断（关闭中断，让其所有动作执行完在打开中断）</li><li>运行时间较短且调用频繁。</li></ul></li><li>系统控制的数据结构及处理：<ul><li>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理： 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理：缓冲区管理、设备分配和回收等<blockquote><p>系统调用运行在系统的内核态，为了获取操作系统的服务，用户程序必须使用系统调用，系统调用会转换为内核态并且调用操作系统。</p></blockquote></li></ul></li></ul></li><li>用户态：只使用了机器指令中的一个子集，将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</li><li>中断：<ul><li>中断，外中断，来自CPU执行指令以外的事件的发生。（外设请求、人为干预）</li><li>异常，内中断，源自CPU执行指令内部的事件。（指令中断、硬件故障、软件中断）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统（operating-System，-OS）&quot;&gt;&lt;a href=&quot;#1-操作系统（operating-System，-OS）&quot; class=&quot;headerlink&quot; title=&quot;1 操作系统（operating System， OS）&quot;&gt;&lt;/a&gt;1 </summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:29:01.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="1-查询优化"><a href="#1-查询优化" class="headerlink" title="1 查询优化"></a>1 查询优化</h2><p>查询优化分为代数优化和物理优化</p><p>简单来说，代数优化是优化查询的次数，尽可能将选择操作先做。</p><p>物理优化，可以理解为建立索引。</p><h2 id="2-字符集"><a href="#2-字符集" class="headerlink" title="2 字符集"></a>2 字符集</h2><ol><li><p>查看字符集编码设置</p><p> <code>mysql&gt; show variables like &#39;%character%&#39;;</code></p></li><li><p>设置字符集编码</p><p> <code>mysql&gt; set names &#39;utf8&#39;;</code></p></li></ol><h2 id="3-大表优化"><a href="#3-大表优化" class="headerlink" title="3 大表优化"></a>3 大表优化</h2><p><a href="https://segmentfault.com/a/1190000006158186">https://segmentfault.com/a/1190000006158186</a></p><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><p>限定数据的范围</p><p> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p></li><li><p>读/写分离</p><p> 经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p>分区</p><ul><li><p>垂直分区</p><p>  根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>  简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p><p>  垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>  垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p></li><li><p>水平分区</p><p>  保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>  水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p>  水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p><p>  水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p>  下面补充一下数据库分片的两种常见方案：</p><ul><li>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库优化&quot;&gt;&lt;a href=&quot;#数据库优化&quot; class=&quot;headerlink&quot; title=&quot;数据库优化&quot;&gt;&lt;/a&gt;数据库优化&lt;/h1&gt;&lt;h2 id=&quot;1-查询优化&quot;&gt;&lt;a href=&quot;#1-查询优化&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
