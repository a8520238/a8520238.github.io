<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lgz_blog</title>
  
  <subtitle>Hey!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T10:16:29.948Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lgz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/02/28/hello-world/"/>
    <id>http://example.com/2021/02/28/hello-world/</id>
    <published>2021-02-28T10:16:29.948Z</published>
    <updated>2021-02-28T10:16:29.948Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据链路层"><a href="#1-数据链路层" class="headerlink" title="1 数据链路层"></a>1 数据链路层</h1><p>数据链路层协议规定了通过信息通信媒介互联的设备之间传输的规范。0，1等计算机二进制 -&gt; 电压高低，光的闪灭以及电波强弱。</p><p>链路层的主体部分是在网络适配器（Network adapter）中实现的，网络适配器有时也称为网络接口卡（Network Interface Card， NIC）</p><ol><li>MAC地址 （Medium Access Control）<br>用于识别数据链路中互连的节点。长48比特。不会重复。</li></ol><h1 id="2-Web页面请求的历程"><a href="#2-Web页面请求的历程" class="headerlink" title="2. Web页面请求的历程"></a>2. Web页面请求的历程</h1><h2 id="2-1-DHCP、UDP、IP和以太网（找本机IP）"><a href="#2-1-DHCP、UDP、IP和以太网（找本机IP）" class="headerlink" title="2.1 DHCP、UDP、IP和以太网（找本机IP）"></a>2.1 DHCP、UDP、IP和以太网（找本机IP）</h2><ol><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67（DHCP服务器）和源端口68（DHCP客户）的UDP报文段中。</li><li>该报文段被放入一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0)的IP数据报中，因为主机还没有一个IP地址。</li><li>该IP数据报被放置在以太网帧中，该MAC帧具有目的MAC地址（FF:FF:FF:FF:FF:FF),将该帧广播到交换机连接的所有设备(顺利的话也包括DHCP服务器)；该帧的源MAC地址时主机的MAC地址。</li><li>该帧是第一个由主机发送到以太网交换机中的帧。该交换机在所有的出端口广播入帧。</li><li>DHCP服务器的接口受到该帧，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址（CIDR分配策略），DNS服务器的IP地址、默认网关路由器的IP地址、子网掩码。将DHCP的ACK报文放入UDP报文段中，UDP报文段被放入IP数据报中，IP数据报在被放入一个以太网帧中。源MAC地址是服务器接口的MAC地址，目的MAC地址是主机MAC地址。</li><li>以太网帧发送到交换机中，由于交换机是自学习的（记录每个接口对应的MAC地址），并且受到过主机的以太网帧，所以交换机仅向主机接口转发该帧。</li><li>主机收到帧后，提取出IP数据报，取出UDP报文段，取出ACK报文。DHCP客户端记录下他的IP地址和他的DNS服务器的IP地址。并在IP转发表中安装默认网关的地址，主机会向网关发送目的地址为其子网以外的所有数据报。</li></ol><h2 id="2-2-DNS、ARP（找网关MAC地址"><a href="#2-2-DNS、ARP（找网关MAC地址" class="headerlink" title="2.2 DNS、ARP（找网关MAC地址)"></a>2.2 DNS、ARP（找网关MAC地址)</h2><ol start="8"><li>主机会通过浏览器生成一个TCP套接字，用于向网站发送HTTP请求，但是需要知道网站的IP地址。</li><li>主机的操作系统生成一个DNS查询报文，将网站的域名放入DNS报文的问题段中。将该报文放入一个目的端口号为53（DNS服务器）的UDP报文段中。该报文段被放入IP目的地址为DNS服务器，源地址为主机IP地址的IP数据报中。</li><li>数据报会放入到以太网帧中。该帧将发送到网关路由器。但是主机通过DHCP过程只知道网关路由器的IP地址，不知道网关路由器的MAC地址。为了获取网关的MAC地址，需要使用ARP协议。</li><li>主机生成一个具有目的IP地址为网关IP的ARP查询报文。放入到一个具有广播地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送这个广播帧，交换机将帧发送给所有连接的设备，包括网关路由器。</li><li>网关在收到该帧后，发现目标IP与自己IP匹配，所以要发送一个ARP回答，指示自己的MAC地址对应自己的IP地址。将ARP回答放入以太网帧中，目的地址为主机的MAC地址，向交换机发送该帧，由交换机发送给主机。</li><li>主机收到该帧并抽取网关路由器的MAC地址，继续DNS解析过程。</li><li>将包含DNS查询报文的数据报放入目的地址为网关MAC地址的以太网帧中，通过交换机发送给网关路由器。主机报文的IP目的地址是DNS服务器，MAC目的地址是网关服务器。</li><li>网关接收到DNS查询的IP数据报后，根据IP数据报的目的地址选择转发给响应的路由器。</li><li>路由器收到IP数据报后，根据目的地址和转发表确定出接口，根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项（路由选择）。</li><li>DNS服务器收到数据报后，抽取DNS查询报文。并在DNS库中查找域名。</li><li>找到包含对应域名的IP地址的DNS源记录后，向主机发送一个包含域名到IP地址映射的DNS回答报文，将该DNS回答报文放入UDP报文段、IP数据报中，通过路由器反转发给网关路由器，经过交换机到主机。</li><li>主机从报文中抽取服务器的IP地址。<h2 id="2-3-TCP、HTTP"><a href="#2-3-TCP、HTTP" class="headerlink" title="2.3 TCP、HTTP"></a>2.3 TCP、HTTP</h2></li><li>有了服务器的IP地址之后，便生成TCP套接字，用该套接字向服务器发送HTTP GET报文。</li><li>建立HTTP连接需要进行TCP连接，进行三次握手</li><li>建立连接后发送HTTP的GET报文，将报文放入TCP报文段的载荷中，然后生成IP数据报送往服务器。</li><li>服务器从TCP套接字中读取报文，生成HTTP响应报文，将页面内容放入HTTP响应体中，发送到主机。</li><li>浏览器收到HTTP响应报文后抽取Web页面内容进行渲染，显示web页面。<h1 id="3-DNS查询顺序"><a href="#3-DNS查询顺序" class="headerlink" title="3. DNS查询顺序"></a>3. DNS查询顺序</h1></li><li>浏览器首先搜索浏览器自身缓存的DNS记录。</li><li>如果浏览器缓存中没有找到需要的记录或记录已经过期，则搜索hosts文件和操作系统缓存。</li><li>如果在hosts文件和操作系统缓存中没有找到需要的记录或记录已经过期，则向域名解析服务器发送解析请求。</li><li>如果域名解析服务器也没有该域名的记录，则开始递归+迭代解析。</li><li>获取域名对应的IP后，一步步向上返回，直到返回给浏览器。<h1 id="4-相关问题"><a href="#4-相关问题" class="headerlink" title="4 相关问题"></a>4 相关问题</h1><h2 id="4-1-为什么有了-MAC-地址还要-IP-地址，IP-地址和-MAC-地址的区别是什么"><a href="#4-1-为什么有了-MAC-地址还要-IP-地址，IP-地址和-MAC-地址的区别是什么" class="headerlink" title="4.1 为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么"></a>4.1 为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么</h2></li><li>整体与局部信息传递时候，需要知道的其实是两个地址：终点地址（Final destination address）下一跳的地址（Next hop address）IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。</li><li>分层实现如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的二层交换机不支持这样做），其实MAC地址并不是必要的。但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。这就像OSI七层模型，TCP/IP五层模型其实也不是必要的，用双层模型甚至单层模型实现网络也不是不可以的，只是那样做很蛋疼罢了。</li><li>早期的『以太网』实现早期的以太网只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。</li><li>MAC地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li></ol><p>区别：</p><ul><li>MAC地址是物理地址，IP地址是逻辑地址。就是说MAC地址是不可改变的，IP地址是可以更改的；</li><li>MAC地址具有唯一性，每个硬件出厂时候的MAC地址是固定的；IP地址不具备唯一性，因此，很多应用软件是围绕MAC地址开发的。</li><li>工作层次不同<ul><li>二层基于MAC地址转发数据帧，三层基于IP地址转发报文。二层交换机基于MAC地址表转发数据，路由器基于路由表（IP地址）转发数据。</li></ul></li><li>长度定义<ul><li>MAC地址是Ethernet网卡上带的地址，长度为48位；IP地址目前主流是32位长。IP地址和MAC地址通过ARP协议联系到一起。<h2 id="4-2-如何理解广播域和冲突域（冲突域和广播域）"><a href="#4-2-如何理解广播域和冲突域（冲突域和广播域）" class="headerlink" title="4.2 如何理解广播域和冲突域（冲突域和广播域）"></a>4.2 如何理解广播域和冲突域（<a href="https://blog.csdn.net/u011228842/article/details/91410867">冲突域和广播域</a>）</h2></li></ul></li></ul><ol><li>冲突域：<ul><li>【定义】在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</li><li>【分层】基于OSI的第一层物理层</li><li>【设备】第二层设备能隔离冲突域，比如Switch。交换机能缩小冲突域的范围，交换接的每一个端口就是一个冲突域。</li></ul></li><li>广播域：<ul><li>【定义】网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</li><li>【分层】基于OSI的第二层数据链路层</li><li>【设备】第三层设备才能隔离广播域，比如Router。路由器能隔离广播域，其每一个端口就是一个广播域。<h2 id="4-3-路由器和交换机有什么区别？"><a href="#4-3-路由器和交换机有什么区别？" class="headerlink" title="4.3 路由器和交换机有什么区别？"></a>4.3 路由器和交换机有什么区别？</h2></li></ul></li><li>工作层次不同：<ul><li>交换机主要工作在数据链路层（第二层）</li><li>路由器工作在网络层（第三层）。</li></ul></li><li>转发依据不同：<ul><li>交换机转发所依据的对象时：MAC地址。（物理地址）</li><li>路由转发所依据的对象是：IP地址。（网络地址）</li></ul></li><li>主要功能不同：<ul><li>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。</li><li>交换机能做的，路由都能做。交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据链路层&quot;&gt;&lt;a href=&quot;#1-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;1 数据链路层&quot;&gt;&lt;/a&gt;1 数据链路层&lt;/h1&gt;&lt;p&gt;数据链路层协议规定了通过信息通信媒介互联的设备之间传输的规范。0，1等计算机二进制 -&amp;gt; 电压</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>应用层协议</title>
    <link href="http://example.com/2021/02/27/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AEHTTP/"/>
    <id>http://example.com/2021/02/27/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AEHTTP/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1 网络应用程序体系结构"></a>1 网络应用程序体系结构</h1><p>两种主流应用体系结构</p><ol><li>客户-服务器体系结构</li></ol><ul><li>服务器具有固定周知的地址，且总是打开</li><li>客户之间不直接通信，客户只通过服务器的IP地址与服务器通信</li><li>解决一服务器对多用户的问题：配备大量的数据中心，创建强大的虚拟服务器</li><li>举例：Web, FTP, telnet, 电子邮件</li></ul><ol start="2"><li>P2P体系结构</li></ol><ul><li>不通过专门的服务器，是对等方和对等方之间的通信。</li><li>应用程序对位于数据中心的专用服务器有很小的依赖，甚至没有</li><li>举例：共享文件（迅雷等）</li></ul><ol start="3"><li>混合结构，比如许多即时讯息应用</li></ol><ul><li>服务器跟踪用户的IP地址—-&gt;客户-服务器体系结构</li><li>用户与用户之间的报文在主机之间直接发送—-&gt;P2P体系结构<h1 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2 进程通信"></a>2 进程通信</h1>进行通信实际上就是进程(process)，而不是程序。一个进程可以被认为是运行在端系统上的一个程序。</li><li>多个进程在同一个端系统上时，直接使用进程间通信机制进行通信，且通信规则由操作系统来决定。</li><li>当进程在不同的端系统上，相互之间进行通信，需要发送端生成报文并向网络中发送，接收端接受报文并可能通过回送报文进行响应。</li></ul><ol><li>客户和服务器进程</li></ol><ul><li>进程与计算机网络之间的接口：套接字<ul><li>套接字是应用层和运输层之间的接口</li><li>由于套接字是建立网络应用程序的可编程接口，所以套接字也被称为应用程序编程接口（Application Programming Inteface）</li></ul></li><li>应用程序开发者可以控制套接字在应用层端的一切，但是对运输层几乎没有控制权，对运输层的控制仅限于<ul><li>选择传输协议</li><li>设定几个运输层参数（最大缓存和最大报文长度等）</li><li>一旦选择了一个运输层协议，应用程序就建立在由该协议提供的运输层服务之上。</li></ul></li></ul><ol start="2"><li>进程寻址<br><br>从一台主机将分组发到另外一台主机，需要标识接受进程的地址<ul><li>目的地主机（由IP地址唯一标识）</li><li>指定运行在接受主机上的接收进程，具体地说，是接收套接字（通过端口号标识）<h1 id="3-可供应用程序使用的运输服务"><a href="#3-可供应用程序使用的运输服务" class="headerlink" title="3. 可供应用程序使用的运输服务"></a>3. 可供应用程序使用的运输服务</h1></li></ul></li><li>可靠数据传输：只要运输协议提供了这种服务，发送进程只要将数据传递进套接字，就可以完全信任数据能够无差错地到达接收进程<ul><li>不提供可靠地数据传输服务：容忍丢失的应用</li></ul></li><li>吞吐量：发送进程能够向接收进程交付比特的速率<ul><li>带宽敏感应用希望能够提供特定速率</li><li>弹性应用可以根据当前可用带宽的多少提供吞吐量，例如电子邮件、文件传输和Web传送</li></ul></li><li>定时<br><br> 类似于对吞吐量的保证，运输层协议可以提供定时保证，比如保证发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms.<ul><li>交互式实时应用对数据交付有严格的时间限制</li></ul></li><li>安全性<h1 id="4-因特网提供的运输服务"><a href="#4-因特网提供的运输服务" class="headerlink" title="4 因特网提供的运输服务"></a>4 因特网提供的运输服务</h1></li><li>TCP服务<ul><li>面向连接的服务<ul><li>握手阶段：在应用层数据报文流动之前，TCP先让客户和服务器互相交换运输层控制信息，提醒双方即将有大量分组到来。</li><li>握手之后：一个TCP连接就建立起来，这条连接是双工的。</li><li>结束时：应用程序结束报文发送时，必须拆除该连接。</li></ul></li><li>可靠地数据传送服务<ul><li>无差错且按适当顺序交付所有发送的数据</li></ul></li><li>TCP协议还具有拥塞控制机制，它不针对某一进程，而是针对整个因特网。当发和收双方之间的网络出现拥塞时，TCP的拥塞机制就会抑制发送进程，同时也会限制每个TCP连接，让他们公平地共享网络带宽。</li></ul></li><li>UDP服务<br><br> UDP是不提供不必要服务的轻量级运输协议，仅提供最小服务。<ul><li>无连接的，也就是通信没有握手的过程</li><li>提供的是不可靠数据传送服务，它不保证对方能否收到，也不能保证报文的顺序。</li><li>没有拥塞控制机制，UDP的发送端可以以任何速率向下层注入数据。(可能受到中间链路带宽受限或者拥塞的影响，实际端到端的吞吐量甚至比这个速率还小)</li></ul></li><li>SSL<ul><li>TCP和UDP都没有提供任何加密机制，在TCP的基础上进行加强的套接字(Secure Sockets Layers SSL)</li><li>流程：发送进程将明文数据传给SSL套接字，发送主机中的SSL加密该数据并传递给TCP套接字，经过网络，传给接受进程的TCP套接字，它将加密数据传给SSL，由SSL进行解密，最后SSL通过SSL套接字将明文数据传递给接受进程。<blockquote><p>电子邮件、远程终端访问、web和文件传输等流行的因特网应用都使用了TCP协议，最主要的原因还是TCP提供着可靠的数据传输服务。因特网电话应用（Skype）则能够容忍某些丢失,选择了UDP。但是许多防火墙搜设置阻挡UDP流量，所以因特网电话应用也通常使用TCP作为备份。</p></blockquote></li></ul></li></ol><h1 id="5-应用层协议-HTTP"><a href="#5-应用层协议-HTTP" class="headerlink" title="5 应用层协议-HTTP"></a>5 应用层协议-HTTP</h1><p>应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。web的应用层协议是HTTP（超文本传输协议）。</p><h2 id="5-1-http相关概念"><a href="#5-1-http相关概念" class="headerlink" title="5.1 http相关概念"></a>5.1 http相关概念</h2><ol><li>超文本传输协议（HyperText Transfer Protocol） HTTP</li><li>同一资源定为符（Uniform Resource Locator） URL(网页地址, 包括协议、主机、端口、路径)</li><li>统一资源标识符（Uniform Resource Identifier）URI（由某个协议方案标识的资源的定为标识符）（[协议名]://[用户名]:[密码]@[服务器地址]:[服务器端口号]/[路径]?[查询字符串]#[片段ID]）</li><li>URI与URL区别<ul><li>URL是一种URI，它通过网络位置进行标示。</li><li>URI可以被视为定位符（URL），名称（URN）或者两者兼备。URN定义某事物的身份，URL提供查找该事物的方法。</li></ul></li><li>HTTP使用TCP作为它的支撑运输协议。HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节，这是分层体系结构的最大优点。</li><li>服务器向客户发送被请求文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议(stateless protoless)。<h2 id="5-2-非持续连接和持续连接"><a href="#5-2-非持续连接和持续连接" class="headerlink" title="5.2 非持续连接和持续连接"></a>5.2 非持续连接和持续连接</h2></li></ol><ul><li>非持续连接<ul><li>每个请求/响应是经过一个单独的TCP连接发送</li><li>缺点：<ul><li>必须为每个请求对象建立和维护一个全新的连接。对每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量。</li><li>每个对象经受两倍RTT（往返时延，数据完全发送完到收到确认信号的时间，传播*2 + 排队）的交付时间，一个RTT用于建立TCP，另一个RTT用于请求和接受一个对象</li></ul></li></ul></li><li>持续连接<ul><li>每个请求/响应对是经过一个相同的TCP连接发送</li><li>对对象的请求可以一个接一个的发出，而不必等待对未决请求的回答</li></ul></li><li>HTTP/1.1中默认保持持久连接，但是1.0的HTTP需要设置connection:keep-live<h2 id="5-3-HTTP报文格式"><a href="#5-3-HTTP报文格式" class="headerlink" title="5.3 HTTP报文格式"></a>5.3 HTTP报文格式</h2></li></ul><ol><li>请求报文<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/5FDF98FF4BAD4B0CB5E586AA1D495FC7/13364" alt="请求报文"></li></ol><p>包括请求行、首部行（请求头部）、空行、实体体</p><p>HTTP请求报文的第一行叫请求行，包括：方法字段、URL字段、HTTP版本字段</p><p>请求头部是一个个key-value对，比如<code>Accept-Language: en-US</code></p><p>CR(Carriage Return)回车符<br>LF(Line Feed)换行符</p><p>使用GET方法时请求实体为空，使用POST方法时才使用请求实体</p><ol start="2"><li>响应报文<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/66A0D094FAC149E18D944C6BC66B191A/13366" alt="响应报文"></li></ol><p>包括状态行、首部行、空行、实体体</p><p>HTTP响应报文的第一行叫状态行，包括：协议版本字段、状态码字段、相应状态信息</p><p>实体体部分是报文的主要部分，包含了请求的对象</p><h2 id="5-4-请求方法"><a href="#5-4-请求方法" class="headerlink" title="5.4 请求方法"></a>5.4 请求方法</h2><p>HTTP/1.1协议中定了9种方法来表明Request-URL指定资源的不同的操作方式</p><ol><li>OPTIONS询问支持的方法。返回服务器针对特定资源的HTTP请求方法.</li><li>HEAD获得报文首。向服务器索要与GET请求一致的响应，响应体不会被返回。主要用户URL有效性及资源更新日期时间。</li><li>GET获取资源。向特定资源发出请求（GET可能会被爬虫随意访问）</li><li>POST传输实体主体。向指定资源提交数据处理的请求（提交表单、上传文件）数据被包含在请求体中。POST可能会导致新建资源或已有资源的修改</li><li>PUT传输文件。自身不带验证机制，存在安全性问题。向指定资源上传最新内容。（本身不带安全验证，可以上传恶意文件，从而获取权限，存在安全机制一般不用）</li><li>DELETE删除文件。与PUT一样，不带安全验证，可以删除特定文件，存在安全性问题<a href="https://www.freebuf.com/articles/web/172695.html">安全问题</a>。请求服务器删除REQUEST_URL所标识的资源。</li><li>TRACE追踪路径。服务器会把通信路径返回客户端（通常不会用，易受攻击）。</li><li>CONNECT。要求 与代理服务器通信时建立隧道，使用SSL和TSL.CONNECT这个方法的作用就是把服务器作为跳板，让服务器代替用户去访问其它网页，之后把数据原原本本的返回给用户。这样用户就可以访问到一些只有服务器上才能访问到的网站了，这就是HTTP代理.<a href="https://www.cnblogs.com/xyl1932432873/p/7735866.html">详细解释</a></li><li>PATCH局部修改某一资源。</li></ol><h2 id="5-5-GET与POST的区别"><a href="#5-5-GET与POST的区别" class="headerlink" title="5.5 GET与POST的区别"></a>5.5 GET与POST的区别</h2><ol><li>作用：GET用于获取资源，POST用于传输实体主体</li><li>参数：GET和POST都能使用额外的参数，但是GET参数以查询字符串的形式出现在URL中，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin</a> 这个过程用户可见。而POST的参数存储在实体主体中。通过HTTP的POST机制。POST参数可以通过一些抓包工具（Fiddler）查看。<br><br>因为URL只支持ASCLL码，因此GET参数中文会被编码，空格被编码为%20</li><li>安全： 安全的HTTP方法不会改变服务器状态，可以说他是只读的<br><br>get方法是安全的，POST不是，POST方法传输主体内容，这个内容可能是某个表单数据，服务器可能把其存入数据库中，这样状态就发生了改变。</li><li>幂等性<br><br>幂等性的HTTP方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。<br><br>所有安全的方法是幂等的，GET、HEAD、PUT、DELETE方法都是幂等的。而POST方法不是幂等的。<br>一个幂等的操作典型如：把编号为5的记录的A字段设置为0，这种操作不管执行多少次都是幂等的。一个非幂等的操作典型如：把编号为5的记录的A字段增加1，这种操作显然就不是幂等的。</li><li>GET请求会被浏览器主动cache,而post不会，除非手动设置。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li><li>XMLHTTPRequest<br><br>XMLHTTPRequest是一个API，它为客户端和服务器之间传输数据的功能。他提供了一个URL来获取数据的简单方式，而且不会使整个页面刷新。这使得网页只更新一部分不会打扰到用户，在AJAX中被大量使用。在xmlhttprequest中POST会先发送header再发送data（当然也和浏览器的做法相关），而get方法会一起发送。</li><li>其他<br><br>Get传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递<br><br>Get方式只支持ASCII字符，向服务器传输的中文字符可能会乱码。POST支持标准字符集，可以正确的传递中文字符</li></ol><h2 id="5-6-PUT、POST区别"><a href="#5-6-PUT、POST区别" class="headerlink" title="5.6 PUT、POST区别"></a>5.6 PUT、POST区别</h2><p>put是幂等的，如果两个请求相同，后一个会把第一个覆盖掉。(PUT用来改资源)<br><br>post不是幂等的，后一个请求不会把第一个请求覆盖掉。(Post用来增加资源)</p><h2 id="5-7-HTTP首部Request"><a href="#5-7-HTTP首部Request" class="headerlink" title="5.7 HTTP首部Request"></a>5.7 HTTP首部Request</h2><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">客户端能够接受的内容类型</td><td align="center">text/html</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">浏览器可以支持的web服务器返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Accept-Language</td><td align="center">浏览器可以接受的语言</td><td align="center">zh-CN</td></tr><tr><td align="center">Cache-Control</td><td align="center">指定请求和相应遵循的缓存机制</td><td align="center">max-age=0</td></tr><tr><td align="center">Connection</td><td align="center">表示是否需要持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Cookie</td><td align="center">HTTP请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器</td><td align="center">键值对</td></tr><tr><td align="center">Host</td><td align="center">请求服务器的域名和端口号</td><td align="center"><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td align="center">Upgrade-Insecure-Requests</td><td align="center">浏览器可以处理HTTPS协议</td><td align="center">1</td></tr><tr><td align="center">User-Agent</td><td align="center">发出请求的用户信息</td><td align="center">Mozilla/5.0</td></tr></tbody></table><h2 id="5-8-HTTP-首部-Response"><a href="#5-8-HTTP-首部-Response" class="headerlink" title="5.8 HTTP 首部 Response"></a>5.8 HTTP 首部 Response</h2><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">告诉所有的缓存机制是否可以缓存及缓存哪种类型</td><td align="center">private</td></tr><tr><td align="center">Connection</td><td align="center">是否保持持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Content-Encoding</td><td align="center">返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Content-type</td><td align="center">返回内容的MIME类型</td><td align="center">text/html charset=utf-8</td></tr><tr><td align="center">Date</td><td align="center">原始服务器消息发出时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Expires</td><td align="center">响应过期的时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Server</td><td align="center">Web服务器软件名称</td><td align="center">BWS1.1</td></tr><tr><td align="center">Set-Cookie</td><td align="center">设置浏览器缓存</td><td align="center">BDSVRTM=114; path=/</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">文件传输编码</td><td align="center">chunked</td></tr></tbody></table><h2 id="5-9-HTTP状态码"><a href="#5-9-HTTP状态码" class="headerlink" title="5.9 HTTP状态码"></a>5.9 HTTP状态码</h2><p>HTTP中状态码大致分为5大类：</p><ol><li>100-199信息性状态码<ul><li>100 continue： 收到了请求的初始部分，请客户端继续</li></ul></li><li>200-299 成功状态码<ul><li>200 OK：请求被正常处理</li><li>204 No Content: 请求被接受，但是响应报文只有首部和状态行，没有实体部分</li><li>206 Partial Content: 客户端只请求了一部分的资源，服务器只针对请求的部分资源进行返回</li></ul></li><li>300-399 重定向状态码<ul><li>301 Moved Permanently: 永久重定向。服务器返回此响应时，会自动将请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。 </li><li>302 Found（临时移动）（对应转发）: 临时重定向，资源被临时移动了。但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎页面或网站已被移动。</li><li>303 See Other: 表示用户请求的资源代表着另一个URI，应该使用GET去获取资源。当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 </li><li>304 Not Modified: 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。<br>  如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应。由于服务器可以告诉 搜索引擎自从上次抓取后网页没有更改过，因此可节省带宽和开销。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</li><li>307 Temporary Redirect（临时重定向）（对应重定向）: 同302。</li></ul></li><li>400-499 客户端错误状态码<ul><li>400 Bad Request: 告知客户端它发送了一个错误的请求</li><li>401 Unauthorized: 请求需进行认证</li><li>403 Forbidden: 请求被服务器拒绝了</li><li>404 Not Found：服务器无法找到对应资源</li><li>405 Method Not Allowed：请求中带有不支持的方法（方法禁用）</li></ul></li><li>500-599 服务器错误状态码<ul><li>500 Internet Server Error: 服务器内部错误</li><li>502 Bad GateWay： 代理或网关服务器从下一条链路收到了伪响应（网关错误）</li><li>503 Server Unavailable: 服务器正忙</li><li>504 GateWay Timeout: 一个代理网关等待另一服务器时超时了<h2 id="5-10-cookie和session"><a href="#5-10-cookie和session" class="headerlink" title="5.10 cookie和session"></a>5.10 cookie和session</h2><h3 id="5-10-1-cookie"><a href="#5-10-1-cookie" class="headerlink" title="5.10.1 cookie"></a>5.10.1 cookie</h3></li></ul></li></ol><p>HTTP服务器时无状态的，但是一个Web站点通常希望能够识别用户，（限制访问、用户身份）为此使用cookie技术。</p><p>网络服务器用HTTP头向客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。</p><p>cookie技术的4个组件：<br></p><ol><li>HTTP响应报文中的cookie首部行</li><li>HTTP请求报文中的cookie首部行</li><li>用户端系统中保留有一个cookie文件，由浏览器进行管理。</li><li>位于Web站点的后端数据库</li></ol><p>过期时间：</p><ol><li>会话cookie： 若不设置过期时间，表示这个cookie的生命周期未浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie</li><li>持久cookie： 若设置了过期时间，浏览器会把cookie存储到硬盘上（可以拒绝），关闭后在打开这些cookie仍然有效<h3 id="5-10-2-session"><a href="#5-10-2-session" class="headerlink" title="5.10.2 session"></a>5.10.2 session</h3>session机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息</li></ol><p>当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。</p><p>session_id的存储</p><ol><li>保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session</li><li>由于cookie可以被人为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符</li><li>另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id</li></ol><h3 id="5-10-2-session-和-cookie区别"><a href="#5-10-2-session-和-cookie区别" class="headerlink" title="5.10.2 session 和 cookie区别"></a>5.10.2 session 和 cookie区别</h3><ol><li>存取方式不同<br><br>cookie只能保存ASCII字符，Unicode和二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较难。<br>而session中能够存取任何类型的数据，十分方便。</li><li>隐私策略不同<ul><li>cookie存储在客户端浏览器中，对客户可见，客户端可以窥探甚至修改cookie内容。</li><li>session存储在服务器上，对用户透明，不存在泄漏风险。</li><li>cookie可以像google及百度一样将敏感信息加密后保存，在服务器上进行解密。</li></ul></li><li>有效时间不同<ul><li>由于session依赖于session_ID的cookie，而session_id的过期时间默认为-1，关闭浏览器即消失。而cookie可以设置长期的保存。</li></ul></li><li>服务器压力不同<ul><li>由于不从的存储方式，存储在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大。</li></ul></li><li>浏览器支持不同<ul><li>cookie需要客户端浏览器的支持，假如客户端禁用或不支持cookie，则会话跟踪会失效</li><li>假如客户端不支持cookie，就需要运用session及URL地址重写。注意，所有用到session的程序url都要进行重写，否则session会话会失效</li></ul></li><li>跨域支持不同<ul><li>cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用</li><li>session尽在当前域名有效<blockquote><p>跨域名访问：<a href="https://www.cnblogs.com/sexintercourse/p/7011427.html">跨域问题</a> <a href="https://www.cnblogs.com/hujunzheng/p/5744755.html">cookie跨域</a></p></blockquote></li></ul></li></ol><h2 id="5-11-web缓存和条件GET方法"><a href="#5-11-web缓存和条件GET方法" class="headerlink" title="5.11 web缓存和条件GET方法"></a>5.11 web缓存和条件GET方法</h2><ol><li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本</li><li>条件GET方法<ul><li>条件GET使缓存器证实他的对象是最新的。<ul><li>请求报文中使用GET方法、</li><li>请求报文中包含“If-Modified-Since”首部行</li></ul></li><li>304 not modified告诉缓存器可以继续使用该对象<h2 id="5-12-HTTP和HTTPS的区别"><a href="#5-12-HTTP和HTTPS的区别" class="headerlink" title="5.12 HTTP和HTTPS的区别"></a>5.12 HTTP和HTTPS的区别</h2></li></ul></li><li>HTTPS协议需要CA申请证书，需要缴费</li><li>HTTP是超文本传输协议，明文传输，HTTPS是SSL加密传输</li><li>HTTP是80端口，HTTPS是443端口</li><li>HTTP连接很简单，无状态，HTTPS经过SSL+HTTP协议构建，加密传输，身份认证</li><li>HTTPS耗性能，安全性要求低用HTTP</li></ol><h2 id="5-12-CGI（Common-Gateway-Interface）公共网关接口"><a href="#5-12-CGI（Common-Gateway-Interface）公共网关接口" class="headerlink" title="5.12 CGI（Common Gateway Interface）公共网关接口"></a>5.12 CGI（Common Gateway Interface）公共网关接口</h2><p>CGI 是HTTP 中重要的技术之一，有着不可替代的作用。CGI是一个web服务器的标注接口。通过CGI接口Web服务器就能获取客户端提交的信息转交给服务器端的CGI程序处理，最后结果返回给客户端。</p><p>CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。服务器和客户端之间的通信，是浏览器和服务端web服务器的HTTP通信，所以只需知道浏览器执行哪个CGI程序即可.<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/F3459DFFB8F74C0690421E549BA2D514/13681"></p><h2 id="5-13-因特网中的电子邮件"><a href="#5-13-因特网中的电子邮件" class="headerlink" title="5.13 因特网中的电子邮件"></a>5.13 因特网中的电子邮件</h2><p>因特网电子邮件系统由3个主要组成部分：用户代理（user-agent)、邮件服务器（mail server)、简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）</p><ol><li><p>SMTP<br><br><strong>25号</strong>端口、TCP连接，传输的三个阶段： 握手、传输、关闭连接。</p></li><li><p>与HTTP的对比<br><br>都是TCP连接，持续的HTTP和SMTP都是持续连接。</p><ul><li>HTTP是一个拉协议，TCP连接由想接受文件的机器发起。SMTP是一个推协议，TCP连接由发送文件的机器发起。</li><li>SMTP要求报文采用7比特ASCII码格式，如果报文包含了非7比特ASCII字符，必须按照7比特ASCII码进行编码。HTTP数据则不受这种限制。</li><li>如何处理一个既包含文本又包含图形的文档。HTTP把每个对象封装到各自的HTTP响应报文中，SMTP则把所有报文对象放在同一个报文之中。</li></ul></li><li><p>邮件报文格式</p><ul><li>必须包含From首部行和To首部行</li></ul></li><li><p>邮件访问协议</p><ul><li>第三版邮局协议（Post Office Protocol-Version3，POP3）</li><li>因特网邮件访问协议（Internet Mail Access Protocol， IMAP）</li><li>HTTP</li><li>一张图说明邮件协议之间的关系<br>  <img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/5588B8730F3643EBA96E38F18D1D6707/13766" alt="邮件协议"><h1 id="5-14-FTP文件传输协议"><a href="#5-14-FTP文件传输协议" class="headerlink" title="5.14 FTP文件传输协议"></a>5.14 FTP文件传输协议</h1></li></ul></li><li><p>HTTP是超文本传输协议，是面向网页的；FTP是文件传输协议，是面向文件的。  </p></li><li><p>HTTP协议默认端口：80号端口。FTP协议默认端口：21号端口。</p></li><li><p>FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据。</p></li><li><p>因为在FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是带外传送的，如果控制信息和数据信息通过同一个TCP传输，则称为带内传送（HTTP）</p></li><li><p>FTP中控制连接贯穿整个会话，但是数据连接在一个文件开始传输时建立，传输结束后关闭，所以每次传输一个新文件时，都会建立一个数据连接。控制连接是持久连接，数据连接是非持久连接。</p></li><li><p>有状态。FTP需要在整个会话期间，保留用户的状态，也就是将控制连接同用户账户关联起来，同时记录在远程目录树上的操作，这就限制了FTP可以同时维持的会话总数。</p></li></ol><h1 id="5-15-DNS"><a href="#5-15-DNS" class="headerlink" title="5.15 DNS"></a>5.15 DNS</h1><ol><li>DNS（Domain Name System）提供主机名到IP地址转换的目录服务。</li><li>DNS运行在UDP传输协议之上，使用<strong>53号</strong>端口</li><li>DNS是：1. 一个由分层的DNS服务器实现的分布式数据库。2. 一个使得主机能够查询分布式数据库的应用层协议。</li><li>DNS采用分布式的设计方案，因为单一的DNS服务器无法解决单点故障，无法保证通信容量以及无法临近所有的查询主机和维护困难等问题。</li><li>根DNS服务器：因特网上由13个根DNS服务器，每台服务器是一个冗余的计算机网络以*提供安全性和可靠性</li><li>顶级域DNS服务器：负责顶级域名如com、org、net、edu等以及各个国家顶级域名的转换。</li><li>权威DNS服务器：因特网上，具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。</li><li>本地DNS服务器：邻近其所在网络的其他主机。当主机发出DNS请求时，请求被发往本地DNS服务器，起着代理的作用。</li><li>递归查询：从请求主机到本地DNS服务器的查询是递归的，其余都是迭代的</li><li>DNS缓存每当DNS服务器发出请求后受到回答时，就将回答的内容缓存在自己的主机空间上。注意有效时间</li></ol><h1 id="5-16-P2P2文件分发"><a href="#5-16-P2P2文件分发" class="headerlink" title="5.16 P2P2文件分发"></a>5.16 P2P2文件分发</h1><p>p2p体系结构具有良好的自扩展性。这种扩展性的直接成因是对等方除了是比特的消费者之外还是重新分发者。</p><h2 id="5-16-1-BitTorrent"><a href="#5-16-1-BitTorrent" class="headerlink" title="5.16.1 BitTorrent"></a>5.16.1 BitTorrent</h2><ol><li>参与一个特定文件分发的所有对等方的集合被称为一个洪流</li><li>在一个洪流中的对等方彼此下载等长度的文件块</li><li>当一个对等方下载文件块的时候，也向其他对等方发送了多个块，一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件。</li><li>P2P文件共享协议，参与一个特定文件分发的所有对等方结合被称为一个洪流（torrent），在一个洪流的对等方彼此下载等长度的文件块，可以随时离开洪流，也可继续向其他对等方上载。每个洪流都有一个追踪器。</li><li>Alice加入某洪流时，会在追踪器里进行注册，周期性通知追踪器它仍在洪流中。我们称所有与ALICE成功的创建了一个TCP链接的对等方成为邻近对等方。</li><li>洪流随机从参与对等方的结合中选择一个子集，将他们的IP地址发给Alice，Alice维护这张对等方列表，试图与所有对等方建立并行的TCP连接。</li><li>Alice周期询问每个邻近对等方（连上的）他们有的文件块列表，她随时知道邻居有哪些文件块</li><li>Alice使用最稀缺优先技术，首先请求那些邻居们副本数量最少的块，使该文件块迅速分发，以均衡每个块在洪流中的副本数量</li><li>BitTorrent使用一种算法，Alice优先从像她传时速度最快的邻居（4个，每10s修改一次）那里获取文件块。</li><li>每过30s，Alice也要随机选择另外一个对等方Bob，向他发送块。若Alice是Bob最快的前四快，Bob也是Alice的前4快，则Bob和Alice互相发送数据。</li><li>每过30s换一个新的对象，互相交换数据（一报还一报），为了使对等方能够找到彼此协调的速率上传</li></ol><ul><li>几个概念<ul><li>分布式散列表（DHT）</li><li>经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）（视频流）</li><li>内容分发网（Content Distribution Network，CDN ）<h1 id="5-17-网关和代理对比"><a href="#5-17-网关和代理对比" class="headerlink" title="5.17 网关和代理对比"></a>5.17 网关和代理对比</h1></li></ul></li></ul><ol><li>协议<br><br>理连接的是两个或多个使用相同协议的应用程序，而网关连接的则是两个或多个使用不同协议的应用程序。网关扮演的是‘协议转换器’的角色，即使客户端和服务端使用的是不同的协议，客户端也可以通过网关来和客户端进行交互。</li><li>功能<br><br>网关：如果一台电脑需要访问网络外的其他电脑，那么就需要配置网关来获得访问网络外部的权限。如果没有网关，电脑就无法访问局域网之外的网络部分，就像是被锁在家里一样。<br><br>代理服务器除了网关的功能外，还有信息过滤的功能。代理服务器能隐藏你的网络信息，任何用户想访问带有代理服务器的网络，都只能看到代理服务器的IP。代理服务器还有缓存功能。</li></ol><h2 id="5-18-总结"><a href="#5-18-总结" class="headerlink" title="5.18 总结"></a>5.18 总结</h2><p>一个web页面的请求过程</p><ol><li>DHCP配置主机信息(找主机IP)</li></ol><ul><li>主机生成一个DHCP请求报文，并将这个报文放入目的端口67和源端口68的UDP报文段中</li><li>该报文段放在一个广播IP地址(255.255.255.255)和源IP地址(0.0.0.0)的IP数据报中。</li><li>该数据报被放在MAC帧中，目的地址FF:FF:FF:FF:FF:FF,广播到交换机连接的所有设备</li><li>交换的DHCP服务器收到广播帧后，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址、DNS服务器IP地址、默认网关路由器的IP地址和子网掩码，再经过层层封装到MAC帧中</li><li>该帧的目的地址是主机的mac地址，主机收到该帧后分解得DHCP报文，之后配置IP地址，子网掩码，DNS服务器IP地址，安装默认网关</li></ul><ol start="2"><li>ARP解析网关MAC地址(找网关MAC地址)</li></ol><ul><li>主机通过浏览器生成一个TCP套接字，为了发送HTTP请求，需要知道网站对应的IP地址。</li><li>生成一个DNS查询报文，端口53(DNS服务器)</li><li>DNS查询报文放入目的地址为DNS服务器IP地址的IP数据报中</li><li>IP数据报放入一个以太网帧中，发送至网关路由器</li><li>DHCP过程只知道网关的IP地址，为了获取网关的MAC地址，需要用ARP协议。</li><li>主机生成一个目的地址为网关路由器IP的ARP查询报文，放入一个广播帧中，并发送这个以太网帧，交换机将其发送给所有的连接设备。</li><li>网关接收到该帧后，分解得到ARP报文，发现IP地址与自己相匹配，发送一个ACK报文回应自己的MAC地址。</li></ul><ol start="3"><li>DNS解析域名(找服务器IP)</li></ol><ul><li>知道了网关的MAC地址后就可以继续DNS解析过程</li><li>网关接收到DNS查询报文后，抽出IP数据报，并根据该表选择该转发的路由器</li><li>路由器根据内部网关协议(RIP、OSPF)和外部网关协议(BGP)配置路由器到DNS的路由表项</li><li>之前的DNS报文到DNS服务器后，照常依次抽出报文，在DNS库中查找解析域名</li><li>找到DNS记录后发送DNS回答报文，然后将其放入UDP报文段、IP数据报，通过路由器反转发回网关路由器，经过交换机到主机。</li></ul><ol start="4"><li>HTTP请求页面</li></ol><ul><li>有了HTTP服务器的IP地址后，主机便可以生成TCP套接字，向web服务器发送HTTP get报文</li><li>建立HTTP连接前需要进行TCP连接，进行三次握手，过程略</li><li>建立连接后发送HTTP的GET报文，交付给HTTP服务器</li><li>HTTP服务器从TCP中读出报文，生成HTTP相应报文，将web页面放入HTTP报文主体中发挥主机</li><li>浏览器收到HTTP相应报文后抽取WEB页面内容进行渲染，显示web页面</li></ul><p><a href="https://www.cnblogs.com/summerday152/p/13762598.html">计算机常用考试题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-网络应用程序体系结构&quot;&gt;&lt;a href=&quot;#1-网络应用程序体系结构&quot; class=&quot;headerlink&quot; title=&quot;1 网络应用程序体系结构&quot;&gt;&lt;/a&gt;1 网络应用程序体系结构&lt;/h1&gt;&lt;p&gt;两种主流应用体系结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户-服务器</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>运输层协议</title>
    <link href="http://example.com/2021/02/27/%E8%BF%90%E8%BE%93%E5%B1%82TCP/"/>
    <id>http://example.com/2021/02/27/%E8%BF%90%E8%BE%93%E5%B1%82TCP/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h1><ul><li>网络层提供了<strong>主机</strong>之间的逻辑通信，运输层协议为不同主机上的<strong>应用进程</strong>之间提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直相连一样。</li><li>运输层协议实在端系统而不是路由器中实现的。在发送端，运输层将从发送应用程序进程接受到的报文转换成运输层分组，称为报文段（segment）</li><li>UDP（User Datagram Protocol，用户数据报协议）为调用他的应用程序提供了一种不可靠、无连接的服务。</li><li>TCP（Transmission Control Protocol， 传输控制协议） 为调用它的应用程序提供了一种可靠的、面向连接的服务。</li><li>将主机间交付拓展到进程间交付被称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）</li><li>UDP流量是不可调节的，使用UDP的应用程序可以根据需要以其愿意的任何速率发送数据。</li><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接受进程。</li><li>TCP还提供拥塞控制（congestion control）。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务。TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</li></ul><h1 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2 多路复用和多路分解"></a>2 多路复用和多路分解</h1><p>一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据地门户。在接受主机地运输层实际上并没有将数据直接交付给进程，而是将数据交给一个中间地套接字。每个套接字都有一个标识符，标识符的格式取决于他是UDP还是TCP套接字。</p><p>将运输层报文段中地数据交付到正确地套接字（通过端口号）的工作称为多路分解（demultiplexing）<br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层称为多路复用。</p><h1 id="3-UDP、无连接运输"><a href="#3-UDP、无连接运输" class="headerlink" title="3 UDP、无连接运输"></a>3 UDP、无连接运输</h1><ol><li>应用场景</li></ol><ul><li>包总量较少的通信（DNS，SNMP等）</li><li>视频、音频等多媒体通信（及时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信</li></ul><ol start="2"><li>UDP特点</li></ol><ul><li>UDP只做传输协议能做的最少工作，只在IP数据服务上增加了两个最基本的服务：复用和分用 以及差错检测</li><li>UDP没有拥塞控制，采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层；TCP有拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制TCP发送方。TCP仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要多长时间。而实时应用通常要求及时性，能够容忍一些数据丢失。</li><li>无需建立连接：TCP开始数据传输之前需要三次握手。UDP不需要任何准备即可进行数据传输。</li><li>无状态连接：TCP需要在端系统中维护连接状态。包括接受和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不维护连接状态，也不跟踪这些参数。</li><li>分组首部开销小 ：TCP40字节，UDP8字节。UDP首部只有8个字节，分为四个字段：源端口、目的端口、UDP长度、UDP校验和<ul><li>端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。</li><li>长度为UDP报文段中的字节数(首部+数据)</li><li>检验和：检验和提供了差错检测功能。因为不能保证源和目的之间的所有链路都提供差错检测。虽然提供差错检测，但他对差错恢复无能为力。</li></ul></li></ul><ol start="3"><li>TCP和UDP的区别<br><br>主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小来讲</li></ol><ul><li>TCP面向连接，UDP无连接。TCP3次握手建立连接，UDP发送前不需要建立连接</li><li>TCP可靠，UDP不可靠，TCP丢包有确认重传机制，UDP不会</li><li>TCP有序，会对报文进行重排；而UDP无序，后发送信息可能先到达</li><li>TCP必须进行数据验校，UDP的校验可选</li><li>TCP有流量控制（滑动窗口）和拥塞控制，UDP没有</li><li>TCP传输慢，UDP传输快，因为TCP要建立连接、保证可靠有序，还有流量、拥塞控制</li><li>TCP包头较大（20字节）UDP较小（8字节）<h1 id="4-TCP"><a href="#4-TCP" class="headerlink" title="4 TCP"></a>4 TCP</h1><h2 id="4-1-TCP报文结构"><a href="#4-1-TCP报文结构" class="headerlink" title="4.1 TCP报文结构"></a>4.1 TCP报文结构</h2>TCP提供全双工服务<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/DF87911636F94317A7FDB929EA21815A/13972" alt="TCP报文结构"></li></ul><ol><li>源端口和目的端口：唯一确定一条TCP连接，TCP在发送数据前必须在彼此间建立连接，意思是：双方需要保存对方的信息。</li><li>序列号seq：占4个字节，用于标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号，确保TCP传输有序。</li><li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li><li>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。用于确认不丢包。</li><li>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li><li>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li><li>其他标志位的含义：<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/C232A5EDEF7348EBACB6E426C08571E6/13974" alt="其他标志位含义"></li><li>数据偏移(首部长度)：4比特。指示以32比特的字为单位的TCP首部长度，因为有选项字段，作为一个4比特的字节，TCP被限制为只能带60字节的头部。</li><li>接受窗口。16比特。用于流量控制，限制窗口大小到65535字节。</li><li>选项。可选与变长。在发送方与接收方协商最大报文段长度（MSS）时使用，或者在高速网络环境下用作窗口调节因子时使用、时间戳、ASCK（选择确认)。</li></ol><h2 id="4-2-三次握手"><a href="#4-2-三次握手" class="headerlink" title="4.2 三次握手"></a>4.2 三次握手</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/F59FF5FC9B48486092B2D9E035539503/13976"></p><ol><li>第一次握手：客户端发送初始序号seq = x和SYN=1的请求标志。此时服务器得知客户端发送正常，自己接收正常。</li><li>第二次握手：服务器发送请求标志SYN=1,确认标志ACK=1，自己的序号seq=y，发送客户端的确认信号x+1。客户端知道自己发送、接收正常，服务器接收、发送正常。</li><li>第三次握手：客户端发送确认信号ACK=1，发送自己的序号seq=x+1，发送对方的确认号ACK=y+1。服务器知道客户端发送、接收正常，自己接收、发送也正常。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/CACA11D7C63E4F118D6CFC5A862D6334/13978"></p><ol><li>第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态，是客户端的请求断开。</li><li>第二次挥手：服务器收到客户端的请求后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态，服务器确认客户端的断开请求。</li><li>第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态），服务器请求断开。</li><li>第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态，客户端确认服务器断开。<h2 id="4-3-常见问题"><a href="#4-3-常见问题" class="headerlink" title="4.3 常见问题"></a>4.3 常见问题</h2></li><li>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</li></ol><ul><li>连接时，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，对应用于同步+应答。</li><li>连接关闭时，当服务端收到FIN报文时，也许还有话要说，并不会立即关闭SOCKET，所以不会立即返回一个FIN，而是先回复一个ACK报文，告诉客户端自己已经收到了FIN，而只有等服务端把要说的话说完，才能发送FIN，因此需要四步。</li></ul><ol start="2"><li>为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</li></ol><ul><li>我们需要假想网络传输是不可靠的，有可能最后一个ACK将会丢失，TIME_WAIT状态可以用来重发可能丢失的ACK报文。在客户端发出最后的ACK回复时，如果服务端没有收到ACK，它将不断重复发送FIN片段，所以客户端不能立即关闭，它必须确认服务端收到了该ACK。</li><li>客户端会在发出ACK之后进入TIME_WAIT的状态，并等待两倍的MSL的时间，Maximum Segment Lifetime，片段在网络中的最大生存时间，两倍的MSL就是一个发送和一个回复所需要的最大时间，如果超出该时间，客户端还没有再次收到FIN，那么客户端就会推断ACK已经被成功接收，此时TCP连接结束。</li></ul><ol start="3"><li>为什么不能用两次握手进行连接？</li></ol><ul><li>三次握手完成了两个重要的功能：<ul><li>双方做好发送数据的准备工作。</li><li>允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</li></ul></li><li>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</li></ul><ol start="4"><li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li></ol><ul><li>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<h2 id="4-4-注意事项"><a href="#4-4-注意事项" class="headerlink" title="4.4 注意事项"></a>4.4 注意事项</h2></li></ul><ol><li>当主机接收到TCP报文段与进行中的进程都不匹配的情况时，发送重置报文段。当主机发送一个重置报文段时，他告诉该源“我没有那个报文段的套接字，请不要发送该报文段了”。当UDP套接字不匹配时，主机发送特殊的ICMP数据报。</li><li>TCP的半打开状态<ul><li>如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双方就无法获悉异常</li><li>半打开的一个常见原因是一方程序的非正常结束（断电、断网）如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了。而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST)处理</li></ul></li><li>同时打开与同时关闭<ul><li>两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2发送SYN同步信息的同时，B:port2也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。</li><li>而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段</li></ul></li><li>重置报文段 RST字段<ul><li>针对不存在端口的连接请求</li><li>终止一条连接：重置报文段会被立即发送，任何排队的数据都将被抛弃；接收方会说明通信另一端采用了终止的方式而不是一次正常关闭。</li><li>半开连接：服务器主机被切断连接重启后，留给客户端一个半开的连接。当再次从这条连接上接收到数据时，服务器对其一无所知，并回复一个重置报文段关闭连接。</li><li>一个重置报文段能破坏TIME_WAIT状态并强制连接关闭。</li></ul></li><li>TCP保活机制<br><br>若某个连接长时间处于空闲状态，在该连接地一端会发送一个探测数据包（可以不含任何数据，但一般会包含垃圾字节）从而实现保活功能。<ul><li>对方主机正在工作且可以到达。正常响应，保活计时器重置</li><li>对方主机崩溃。没有响应，请求段会保活时间间隔指定地时间后超时断开连接。</li><li>对方主机崩溃已重启。重置报文段，断开连接</li><li>对方主机正在工作但无法到达。同2</li></ul></li><li>TCP 连接的本质是什么，真的是“链接”吗<br><br>状态和序列号，以及错误校验（可以查看TCP和UDP的请求头，就会发现两者之间的差距了），其实所谓的TCP三次握手请求连接，无非就是初始化一个序列号，保证后面的数据有序到达，同时TCP还支持重传，错误校验，保证数据的可靠性，当然UDP也提供校验。<ul><li>建立连接（标志位）：通信前确认通信实体存在。</li><li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li><li>数据校验（校验和）：CRC校验全部数据。</li><li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li><li>窗口机制（窗口）：提供流量控制，避免过量发送。</li><li>拥塞控制：同上。</li></ul></li><li>大量的Time-wait怎么办<ul><li>Time-wait 状态不能消除，只能快速的回收或重用</li><li>reuse 处于Time-wait状态可以被后续连接重用</li><li>recycle 开启服务器对于time-wait的快速回收</li><li>time-out 修改系统默认的TIMEOUT时间<h2 id="4-5-TCP超时重传"><a href="#4-5-TCP超时重传" class="headerlink" title="4.5 TCP超时重传"></a>4.5 TCP超时重传</h2>异常网络，会出现如下网络状况</li></ul></li><li>数据顺利到对端，对端顺利响应ACK</li><li>数据包中途丢失</li><li>数据包顺利达到，但是ACK报文丢失</li><li>数据报数据达到，但是对异常未响应</li></ol><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/DA957EFC9E6F4DACAE0E8F0698937C1E/14096" alt="超时重传"></p><p>出现异常情况时，TCP就会超时重传。TCP每发送一个报文段，就对这个报文段，就对这个报文段设一个计时器，如果确认的时间到了而没有收到确认，就会重传报文段。这就是超时重传。</p><p>客户端一直没有得到ACK报文，客户端会一直重传，影响重传效率的是RTO（Retransmission Timeout）。RTO指发送数据后，传送数据等待ACK的时间。RTO(重传超时时间)非常重要。</p><ol><li>设长了，重发慢，没有效率</li><li>设短了，重发快，网络拥塞。</li></ol><p>如果底层传输特性已知，则重传相对简单，但是TCP体层完全异构，所以必须适应适应时延差异。</p><p>经典的自适应算法：</p><p><code>$SRTT = \alpha * SRTT + (1 - \alpha) * RTT$</code></p><p><code>$RTO = min(UBOUND, max(LBOUND, \beta * SRTT)$</code></p><p>UBOUND是最大的timeout时间，上限值，LBOUND是最小的timeout<br>时间，下限值。但这样会因为ACK传输导致RTT多义性问题。</p><p>carn算法，忽略重传，不采样重传的RTT，一旦发生重传，就对现有的RTO翻倍。<br>当不发生重传时，才根据上式计算平均往返时间RTT和重传时间。</p><p>处理差错的两种主要方法是差错校正码和数据重传。</p><p>当RTT测量值小于连接地实际值，就可能发生伪重传。在这种情况下，若TCP地等待时间稍长，不必要地重传就可能不发生。</p><h2 id="4-6-TCP滑动窗口"><a href="#4-6-TCP滑动窗口" class="headerlink" title="4.6 TCP滑动窗口"></a>4.6 TCP滑动窗口</h2><p>TCP的滑动窗口主要有两个作用：一是提供TCP的可靠性；二是提供TCP的流控特性。同时滑动 窗口机制还体现了TCP面向字节流的设计思路。解决乱序和流量控制。</p><blockquote><p>发送端叫拥塞窗口，为了解决拥堵，接收端是滑动窗口，为了解决流量控制。发送量取二者最小值。</p></blockquote><p>对于TCP会话的的发送方，任何时候器缓存数据可以分为四类:</p><ol><li>已经发送并受到对方的ACK</li><li>已经发送但未收到ACK</li><li>未发送但对方允许发送</li><li>对方不允许发送</li></ol><p>其中， 已经发送还未收到ACK和未发生但是对方允许发送的部分称为发送窗口<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/3D6CFB3A7E6E4B4B8C14674EC3FBEEFE/14115"><br>当接收到ACK后续的确认字节时，窗口便会滑动<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/489CF3079D0B43B185721DA291A2F29E/14117"><br>对于TCP会话的接收方，缓存数据可以分为三类</p><ol><li>已接收</li><li>未接受准备接收</li><li>未准备接收</li></ol><p>其中未接受准备接收称为接收窗口。</p><p>TCP是双工的协议，会话的双方可以同时接收、发送数据。TCP会话双方都各自维护一个发送窗口和接收窗口。滑动窗口实现面向流的可靠性来源于“确认重传机制”，TCP滑动窗口的可靠性也来源与确认重传。发送窗口只有受到对方对于本段ACK的确认，才会移动左边界。前面还有字节未接收的情况下，窗口不会移动。</p><p>滑动窗口功能的建立与序列号(seq)和确认号(ack)有关<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/14431655D304484BBE6BFCCA8C002539/14203"></p><h3 id="4-6-1-延时确认"><a href="#4-6-1-延时确认" class="headerlink" title="4.6.1 延时确认"></a>4.6.1 延时确认</h3><p>在许多情况下，TCP并不对每个到来的数据包都反回ACK，利用TCP的累积ACK字段就能实现该功能。累积确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传的数据结合发送。这种捎带传输的方法经常用于批量数据传输。</p><h3 id="4-6-2-Nagle算法"><a href="#4-6-2-Nagle算法" class="headerlink" title="4.6.2 Nagle算法"></a>4.6.2 Nagle算法</h3><p>当一个TCP连接中有在传数据（已发送还未经确认的数据）时，小的报文段（长度小于SMSS（发送发最大报文段））就不能被发送，直到所有的在传数据都收到ACK。在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。</p><h3 id="4-6-3-零窗口与TCP持续计时器"><a href="#4-6-3-零窗口与TCP持续计时器" class="headerlink" title="4.6.3 零窗口与TCP持续计时器"></a>4.6.3 零窗口与TCP持续计时器</h3><p>TCP通过接受端的通告窗口来实现流量控制。通告窗口指示了接受端可接受的数据量。当窗口值变为0时，可以阻止发送端继续发送，直到窗口大小恢复非零值。</p><p>当接收端重新获得可用空间时，会给发送端传输一个窗口更新，告知其可以继续发送数据。这样的窗口更新不包含数据，且没有可靠性，如果丢失，双方就一直处于等待状态。</p><p>为防止这种死锁发生，发送方会采用一个持续计时器间歇性地查询接收端，看其窗口是否增长。持续计时器会触发窗口探测地传输，强制要求接受端返回ACK（包含窗口大小）。</p><h3 id="4-6-4-糊涂窗口综合征"><a href="#4-6-4-糊涂窗口综合征" class="headerlink" title="4.6.4 糊涂窗口综合征"></a>4.6.4 糊涂窗口综合征</h3><p>通告窗口较小时，发送端会立即发送数据填满该窗口，这样在连接中就会出现大量高耗费地小数据包。对发送端来说，通告窗口较小应该避免发送小数据包；接受端应该尽量避免通告小窗口。</p><h2 id="4-7-TCP拥塞控制"><a href="#4-7-TCP拥塞控制" class="headerlink" title="4.7 TCP拥塞控制"></a>4.7 TCP拥塞控制</h2><p>计算机网络中的带宽、交换节点中的缓存和处理机等都是网络的资源。某段时间，网络需求超过了可用部分，网络性能就会变坏，这被称为拥塞。拥塞控制就是防止过多的网络流量注入到网络中。TCP拥塞控制由四个核心算法组成：满开始、拥塞避免、快速重传和快速恢复。</p><h3 id="4-7-1-慢开始和拥塞避免"><a href="#4-7-1-慢开始和拥塞避免" class="headerlink" title="4.7.1 慢开始和拥塞避免"></a>4.7.1 慢开始和拥塞避免</h3><p>发送发维持一个拥塞窗口的状态变量，拥塞窗口取决于网络的拥塞程度。发送方让自己的发送窗口等于拥塞窗口。考虑到接收方的接受能力，发送窗口可能小于拥塞窗口.</p><p>慢开始的思路就是一开始不发送大量的数据，先探测网络的拥塞程度。由小到大增加拥塞窗口。</p><ol><li>当主机发送数据时，如果将较大的发送窗口全部注入到网络中，可能引起拥塞</li><li>可以试探一下，由小到大增大拥塞窗口的数量</li><li>慢开始从1个MSS开始指数增长，为了防止其增长过大，设置一个门限ssthresh，当其达到门限时，变为拥塞避免算法。</li></ol><p>拥塞避免算法是使拥塞窗口缓慢增长，每经过一个RTT就将拥塞窗口加一。</p><ol><li>TCP连接初始化，拥塞窗口为1</li><li>执行慢开始算法，cwind指数增长，指导cwind=ssthresh时，开始拥塞避免算法.</li><li>当网络拥塞时（超时的丢包事件）将ssthresh设为当前的一半，cwind设为1重新开始。<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/4F66217AA2F845A78641437C306527C2/14119"><br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/EDC9663545AF4AD6A45CB43613576031/14121"></li></ol><h3 id="4-7-2-快重传和快恢复"><a href="#4-7-2-快重传和快恢复" class="headerlink" title="4.7.2 快重传和快恢复"></a>4.7.2 快重传和快恢复</h3><p>快重传要求接收方受到一个失序的报文段后立即发送重复确认（为使发送方尽早知道报文段为传到对方）。快重传规定只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必继续等待。</p><p>快重传还配合有快恢复，主要思想包括：</p><ol><li>一旦受到三个重复确认，执行乘法减小，ssthresh门限减半，但是并不执行慢开始</li><li>将cwind（拥塞窗口）设为ssthresh，执行拥塞避免算法。</li></ol><p>整体上，TCP拥塞窗口的原则时加法增大、乘法减小。可以看出TCP较好的保证了流之间的公平性，一旦丢包就减半退让。</p><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/2C6EDD14FA124DAB8595CC1BD14B186D/14123"><br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/8BFF5B63C99D44619D066B60F7409CBE/14125"></p><p>ACK号与接收端缓存中的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为失序数据，因为这些数据和之前接收的序列号不连续。合理采用SACK信息能更快地实现空缺填补，且能减少不必要地重传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-相关概念&quot;&gt;&lt;a href=&quot;#1-相关概念&quot; class=&quot;headerlink&quot; title=&quot;1 相关概念&quot;&gt;&lt;/a&gt;1 相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;网络层提供了&lt;strong&gt;主机&lt;/strong&gt;之间的逻辑通信，运输层协议为不同主机上的&lt;st</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络相关概念和知识</title>
    <link href="http://example.com/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E7%9F%A5%E8%AF%86/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h1><ol><li>因特网</li></ol><ul><li>端系统通过通信链路和分组交换机连接到一起<ul><li>构成因特网的基本硬件和软件组件</li><li>为分布式应用提供服务的联网基础设施</li></ul></li></ul><ol start="2"><li>协议</li></ol><ul><li>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送、接受、或其他事件采取的动作</li></ul><ol start="3"><li>网络边缘</li></ol><ul><li>主机 == 端系统 分为客户(client)和服务器(server)</li></ul><ol start="4"><li>网络核心(互联网端系统分组交换机和通信链路构成的网状网络。)</li></ol><ul><li>分组交换（将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组）<ul><li>存储转发传输</li><li>排队时延和分组丢失</li><li>转发表和路由选择协议</li></ul></li><li>电路交换（由于bai电路交换在通信之前要du在通信双方之间建立一条被zhi双方独占的物理通dao路（由通信双方之间的交换设备和链路逐段连接而成））<ul><li>频分复用（划分为不同频率）</li><li>时分复用（划分为不同时段）</li></ul></li><li>对比<ul><li>分组交换的缺点： 不适合实时服务，因为它端到端的时延是变动的和不可测的（排队时延）</li><li>分组交换的优点：提供了比电路交换更好地带宽共享；比电路交换更简单、更有效、实现成本低</li></ul></li><li>分组交换网中的时延、丢包、和吞吐量（todo）<ul><li>时延： 处理时延、排队时延、传输时延、传播时延</li><li>排队时延和丢包</li><li>端到端时延</li><li>吞吐量<br>关于分组交换详细见<a href="https://www.cnblogs.com/summerday152/p/11876748.html">分组交换网中的时延、丢包和吞吐量</a><h1 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2 计算机网络体系结构"></a>2 计算机网络体系结构</h1></li></ul></li></ul><p>有三种划分说法：OSI七层、五层协议、TCP/IP四层<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/7EA633CF44914DF4B472E6EA30B86A96/13138"></p><h2 id="2-1-五层协议"><a href="#2-1-五层协议" class="headerlink" title="2.1 五层协议"></a>2.1 五层协议</h2><ul><li>应用层：为特定应用程序提供数据传输服务，如HTTP,DNS等。数据单位为报文</li><li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<ul><li>传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；TCP主要提供完整性服务。</li><li>用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。UDP主要提供及时性服务。</li></ul></li><li>网络层：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的节点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感受不到这些差异。<blockquote><p>报文 -&gt; 数据报 -&gt; 分组 -&gt; 帧 -&gt; 比特流</p></blockquote></li></ul><h2 id="2-2-七层协议"><a href="#2-2-七层协议" class="headerlink" title="2.2 七层协议"></a>2.2 七层协议</h2><p>其中表示层和会话层用途如下：</p><ul><li>表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。</li><li>会话层：建立及管理会话<blockquote><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p></blockquote></li></ul><h2 id="2-3-TCP-IP协议"><a href="#2-3-TCP-IP协议" class="headerlink" title="2.3 TCP/IP协议"></a>2.3 TCP/IP协议</h2><p>它只有4层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>现在的TCP/IP体系结构不严格遵循OSI分层概念，应用层可能会直接使用IP层或者网络接口层。</p><p>TCP/IP协议族是一种沙漏形状，中间小两边大，IP协议在其中占有重要地位。<br><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/17578FC0C091412E9113EFBD546F78A2/13165"></p><h2 id="2-4-数据在各层之间的传递过程"><a href="#2-4-数据在各层之间的传递过程" class="headerlink" title="2.4 数据在各层之间的传递过程"></a>2.4 数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-相关概念&quot;&gt;&lt;a href=&quot;#1-相关概念&quot; class=&quot;headerlink&quot; title=&quot;1 相关概念&quot;&gt;&lt;/a&gt;1 相关概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;因特网&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;端系统通过通信链路和分组交换机连接到一起&lt;ul&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="http://example.com/2021/02/27/Http/"/>
    <id>http://example.com/2021/02/27/Http/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http1-0和Http1-1"><a href="#Http1-0和Http1-1" class="headerlink" title="Http1.0和Http1.1"></a>Http1.0和Http1.1</h1><ol><li>http1.0</li></ol><ul><li>客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li><li>浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接</li></ul><ol start="2"><li>http1.1</li></ol><ul><li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用：HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来，HTTP1.1在请求头引入range头域，它允许只请求资源的某个部分，即返回码是206.</li><li>错误通知管理：在HTTP1.1中新增了24个错误状态响应码。</li><li>Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。</li><li>长连接</li></ul><ol start="3"><li>HTTPS</li></ol><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><ol start="4"><li>spdy（http1.x改进）</li></ol><ul><li>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。<ol><li>使用多路复用，（多个请求共用一个tcp），降低了延迟</li><li>允许对多个请求设置优先级</li><li>header进行压缩</li><li>基于https</li></ol></li></ul><ol start="2"><li>http2.0<ol><li>http2.0与spdy区别</li></ol><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 HPACK <a href="http://http2.github.io/http2-spec/compression.html%EF%BC%8C%E8%80%8C%E9%9D%9E">http://http2.github.io/http2-spec/compression.html，而非</a> SPDY 采用的 DEFLATE <a href="http://zh.wikipedia.org/wiki/DEFLATE">http://zh.wikipedia.org/wiki/DEFLATE</a></li></ul><ol start="2"><li>其余改进与spdy差别不大</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Http1-0和Http1-1&quot;&gt;&lt;a href=&quot;#Http1-0和Http1-1&quot; class=&quot;headerlink&quot; title=&quot;Http1.0和Http1.1&quot;&gt;&lt;/a&gt;Http1.0和Http1.1&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;http1.0&lt;/li&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安全通信"><a href="#1-安全通信" class="headerlink" title="1 安全通信"></a>1 安全通信</h1><ol><li>机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密</li><li>报文完整性（message integrity） 确保没有被改动</li><li>端点鉴别（end-point authentication） 确定通信双方</li><li>运行安全性（operational security）</li></ol><h1 id="2-对称加密和非对称加密"><a href="#2-对称加密和非对称加密" class="headerlink" title="2 对称加密和非对称加密"></a>2 对称加密和非对称加密</h1><ol><li>对称加密<br><br>加密过程：<br><br> 加密：原文 + 密匙 = 密文<br><br> 解密：密文 - 密匙 = 原文</li><li>非对称加密<br>使用不同的密钥进行加密和解密，对原文使用公钥加密，则只能使用对应的私钥才能解密。</li></ol><h1 id="3-Diffie-Hellman密钥交换算法"><a href="#3-Diffie-Hellman密钥交换算法" class="headerlink" title="3 Diffie-Hellman密钥交换算法"></a>3 Diffie-Hellman密钥交换算法</h1><ol><li>Alice 和 Bob 协商出两个数字 N 和 G 作为生成元</li><li>现在 Alice 和 Bob 心中各自想一个数字出来，分别称为 A 和 B</li><li>现在 Alice 将自己心里的这个数字 A 和 G 通过某些运算得出一个数 AG，然后发给 Bob；Bob 将自己心里的数 B 和 G 通过相同的运算得出一个数 BG，然后发给 Alice</li><li>Alice 可以通过 BG 和自己的 A 通过某些运算得到一个数 ABG，Bob 也可以通过 AG 和自己的 B 通过某些运算得到 ABG，这个数就是 Alice 和 Bob 共有的秘密</li></ol><h1 id="4-公开密钥加密"><a href="#4-公开密钥加密" class="headerlink" title="4 公开密钥加密"></a>4 公开密钥加密</h1><p>公钥用于加密，私钥用于解密。（RSA）</p><p>但是非对称加密算法无法确定通信双方的身份，会遭到中间人的攻击。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。</p><p>也就是你不知道你收到的公钥是不是伪造者发出的</p><h1 id="5-报文完整性和数字签名"><a href="#5-报文完整性和数字签名" class="headerlink" title="5 报文完整性和数字签名"></a>5 报文完整性和数字签名</h1><h2 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h2><p>有两种攻击：1 针对被动攻击 ( 截获 ) : 加密 ;<br>2 针对主动攻击 ( 篡改 , 伪造 ) : 需要使用 鉴别 ;</p><p>密码散列函数的附加性质：找到任意两个不同的报文x和y使得<code>$H(x)=H(y)$</code>,在计算上是不可能的。</p><p>报文鉴别码：</p><ol><li>Alice生成报文m并计算散列<code>$H(m)$</code></li><li>然后Alice将<code>$H(m)$</code>附加到报文m上，生成一个扩展报文（m, H(m)),并将该扩展报文发给Bob</li><li>Bob接收到一个扩展报文（m，h）并计算<code>$H(m)$</code>，如果<code>$H(m)=h$</code>,Bob会认为一切正常。</li></ol><p>缺陷： 其他人可以生成虚假报文（m’, H(m’)),Bob无法发现这种行为。</p><p>为解决这种缺陷，需要鉴别密钥（authentication key），共享秘密s。（也就是对散列值加密）</p><ol><li>Alice生成报文m, 用s级联m以生成m+s，并计算散列<code>$H(m+s)$</code>。<code>$H(m+s)$</code>称为报文鉴别码（Message Authentication Code，MAC）</li><li>然后Alice将MAC附加到报文m上，生成一个扩展报文（m, H(m+s)),并将该扩展报文发给Bob</li><li>Bob接收到一个扩展报文（m，h）并计算<code>$H(m+s)$</code>，如果<code>$H(m+s)=h$</code>,Bob会认为一切正常。</li></ol><h1 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6 数字签名"></a>6 数字签名</h1><p>数字签名是一种在数字领域表明身份的密码技术。</p><p>用私钥加密数据，然后把加密的数据公布出去，这就是数字签名。</p><ol><li>公钥认证<br><br> 证书就是公钥+签名，由第三方认证机构颁发。<br><br> 证书认证的流程：<ol><li>Bob去可信任的认证机构正是本人真实身份，并提供自己的公钥</li><li>Alice想和Bob通信时，先向认证机构请求Bob的公钥，认证机构会将一张证书（bob的公钥以及自己对其公钥的签名）发送给Alice</li><li>Alice检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。</li><li>Alice通过这个公钥加密数据，开始和Bob通信。<blockquote><p>正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份。</p></blockquote></li></ol></li></ol><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7 HTTPS"></a>7 HTTPS</h1><p>HTTPS是身披SSL外壳的HTTP， 当HTTP加上加密处理和认证以及完整性保护后就是HTTPS。HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（secure socket layer）和TLS（transport layer security）协议代替。采用了SSL后，HTTP就有了HTTPS的加密、证书、和完整性保护这些功能。</p><ol><li><p>Https为了兼顾安全与效率，同时使用了对称加密和非对称加密。</p><ul><li>数据是被对称加密传输的</li><li>对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输</li><li>对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</li></ul></li><li><p>HTTPS在传输过程中涉及到三个密钥：服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密</p></li><li><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><ul><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>服务器将自己的公钥发送给客户端。</li><li>客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ul></li></ol><ol start="4"><li>SSL<ul><li>SSL记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。</li><li>SSL握手协议：它建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ul></li></ol><p><a href="https://yqzzxlj.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></p><h1 id="8-CSRF"><a href="#8-CSRF" class="headerlink" title="8 CSRF"></a>8 CSRF</h1><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/BA662715544C491E8EDDB0F6D5038C4B/15384" alt="CSRF"><br>    - 登录受信任网站A，并在本地生成Cookie。<br>    - 在不登出A的情况下，访问危险网站B。</p><ol><li>防止CSRF原理</li></ol><ul><li>用户请求信息的时候，被骇客获取中间请求信息，当然也会获取token信息，但是因为骇客并不能阻止用户请求到目标网站。</li><li>用户请求目标网站之后，token已经被校验。所以骇客获取的token信息依然无用。</li><li>当时骇客如果在用户请求到目标网站之前先去请求到目标网站，token的作用就没有了。</li></ul><ol start="2"><li>现在很多登陆选择基于token的登陆认证方案，一般也是把token缓存在localStorage里<ul><li>会话劫持”是一种常见攻击手段, 攻击者通过XSS注入获取非Http-Only的明文Cookies或者通过网络嗅探直接获取全部请求内容,从而得到Session标识的值</li><li>CSRF利用的是浏览器访问网页会自动携带该网页的cookie的特性来攻击，此攻击不会获取浏览器执行环境、cookie、token，将token加入HTTP头是用户自己的行为，不是浏览器自发行为，所以对于CSRF攻击而言，token是相对安全的；</li><li>对于XSS攻击而言，攻击者已经可以注入脚本，完全获得代码执行环境，这个时候cookie和token都不安全了，相对而言，cookie还可以设置HttpOnly来防止js获取，但是token就完全裸奔了，攻击者就可以完成提问者所说的攻击了；</li></ul></li></ol><h1 id="9-XSS"><a href="#9-XSS" class="headerlink" title="9 XSS"></a>9 XSS</h1><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">美团XSS</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-安全通信&quot;&gt;&lt;a href=&quot;#1-安全通信&quot; class=&quot;headerlink&quot; title=&quot;1 安全通信&quot;&gt;&lt;/a&gt;1 安全通信&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/02/27/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T10:16:29.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层能够被分解为两个相互作用的部分，即数据平面和控制平面。</p><p>数据平面的主要作用是从其输入链路向其输出链路转发数据报；控制平面的主要作用是协调这些本地的路由器转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传输。</p><p>转发和路由选择：数据平面和控制平面</p><p>转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。（硬件）</p><p>路由选择是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。（软件）</p><p>路由器工作原理</p><p>网际协议：IPv4、寻址、IPv6及其他， IP地址属于网络层地址， IP属于面向无连接型</p><h1 id="1-IPv4"><a href="#1-IPv4" class="headerlink" title="1 IPv4"></a>1 IPv4</h1><h2 id="1-1-IPV4数据报格式"><a href="#1-1-IPV4数据报格式" class="headerlink" title="1.1 IPV4数据报格式"></a>1.1 IPV4数据报格式</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/B1B01B5371E045A6B3AD6EE8730293FF/14238"></p><ul><li>版本号。由4比特构成，表示标识IP首部的版本号。字段值为4。</li><li>首部长度。由4比特构成，表明IP首部的大小。因为IPv4包含一些可变数量的选项。</li><li>服务类型（Tos字段）。由8比特构成，表明服务质量。（优先级、时延、吞吐量）</li><li>数据报长度。由16比特构成，表示IP数据报的总长度。</li><li>标识。由16比特构成。用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。</li><li>标志。由3比特构成。表示包被分片的相关信息。</li><li>片偏移。由13比特构成。用来表示被分片的每一个分段相对于原始数据的位置。</li><li>生存时间（Time To Live，TTL）。由8比特构成。表示可以中转多少个路由器，每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。</li><li>上层协议。由8比特构成，表示IP数据报的数据部分应该交给哪个协议。</li><li>首部检验和。由16比特构成，校验数据报的首部，不校验数据部分。用来确保IP数据报不被破坏。</li><li>源地址。由32比特构成，表示发送端IP地址</li><li>目标地址。由32比特构成，表示接受端IP地址</li><li>可选项。 长度可变，在实验或诊断时使用，包括安全级别、源路径、路径记录、时间戳。</li><li>数据。存入数据。包括IP上层协议的首部<blockquote><p>ipv4首部最小20字节，最大60字节。ipv6固定40字节</p></blockquote><h2 id="1-2-IPv4数据报分片"><a href="#1-2-IPv4数据报分片" class="headerlink" title="1.2 IPv4数据报分片"></a>1.2 IPv4数据报分片</h2></li></ul><p>一个链路层帧能承载的最大数据量叫作最大传送单元（Maximun Transmission Unit， MTU）。每种数据链路的最大传输单元都不近相同。</p><p>路由器将IP数据报分片但不会进行重组，重组只能由目标主机进行。</p><h2 id="1-3-Ipv4编址"><a href="#1-3-Ipv4编址" class="headerlink" title="1.3 Ipv4编址"></a>1.3 Ipv4编址</h2><p>主机与物理链路之间的边界叫接口。一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>IPv4地址由32位比特组成。每8位分成一组，分成4组，以”.”隔开，再将每组数转化为十进制数。</p><p>IPv4地址由网络标识（网络地址）和主机标识（主机地址）两部分组成。</p><p>子网掩码将原网络分为多个物理网络。<a href="https://blog.csdn.net/gatieme/article/details/50989257">子网掩码详解</a></p><p>物件别域间路由选择（Classless Interdomain Routing， CIDR） 和<br>可变长子网掩码（Variable Length Subnet Mask， VLSM）技术采用任意长度分割IP地址的网络标识和主机标识。</p><p>广播地址。把IP地址中的主机地址部分全部设置为1，就成了广播地址。<br>在本网络内的广播叫本地广播，不同网络之间的广播叫直接广播。</p><p>多播。多播用于将包发送给特定组内的所有主机。</p><p>对于没有连接互联网的独立网络中的主机，只要保证在这个网络每地址唯一，可以不用考虑互联网即可配置响应的IP地址。私有网络的IP地址</p><ul><li>A类 10.0.0.0 ~ 10.255.255.255（10/8）</li><li>B类 172.16.0.0 ~ 172.31.255.255（172.16/12）</li><li>C类 192.168.0.0 ~ 192.168.255.255（192.168/16）</li></ul><p>包含在这个范围内的IP地址都属于私有IP，在此之外的IP称为全局IP。</p><h1 id="2-Ipv6"><a href="#2-Ipv6" class="headerlink" title="2 Ipv6"></a>2 Ipv6</h1><h2 id="2-1-IPv6数据报格式"><a href="#2-1-IPv6数据报格式" class="headerlink" title="2.1 IPv6数据报格式"></a>2.1 IPv6数据报格式</h2><p><img src="http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/04C7048AF63C47A8802A06CA5B466098/14240"></p><ul><li>版本。 由4比特构成。6.</li><li>流量类型 由8比特构成。与IPv4中TOS字段含义相似。</li><li>流表签 由20比特构成。用于标识一条数据报的流。</li><li>有效载荷长度 由16比特构成。有效载荷指包的数据部分。</li><li>下一个首部 由8比特构成，相当于IPv4的协议字段</li><li>跳限制 由8比特构成，相当于IPv4的TTL。</li><li>源地址 由128比特构成。表示发送端IP地址</li><li>目的地址 由128比特构成。表示接受端IP地址。</li></ul><ol><li>IPv4数据报的几个字段不复存在：<ul><li>分片/重新组装： IPv6不允许在中间路由器上进行分片与重新组装。这种操作只能在源与目的地执行。</li><li>首部检验和： IP分组关注的重点是快速处理。减轻路由器负荷。</li><li>选项： 选项字段不再是首部的一部分，但他没有消失，可能出现在“下一个首部”指出的位置上。</li></ul></li><li>IPv6的必要性<ul><li>解决IPv4地址耗尽的问题</li><li>弥补IPv4中的大多数缺陷</li></ul></li><li>IPv6的特点<ul><li>IP地址的扩大与路由控制表的聚合</li><li>性能提升：包首部采用固定的值（40字节），不再采用首部检验码，简化首部结构，减轻路由器负荷。路由器不再做分片处理。</li><li>支持即插即用功能：即使没有DHCP服务器也可以实现自动分配IP地址</li><li>采用认证与加密功能：应对伪造IP地址的网络安全功能以及防止线路窃听的功能（IPsec）</li><li>多播、MobileIP称为扩展功能</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;网络层&lt;/h1&gt;&lt;p&gt;网络层能够被分解为两个相互作用的部分，即数据平面和控制平面。&lt;/p&gt;
&lt;p&gt;数据平面的主要作用是从其输入链路向其输出链路转发数据报；</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>select_poll_epoll</title>
    <link href="http://example.com/2020/10/29/select_poll_epoll/"/>
    <id>http://example.com/2020/10/29/select_poll_epoll/</id>
    <published>2020-10-29T08:06:54.000Z</published>
    <updated>2021-02-28T10:16:29.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-select-gt-时间复杂度O-n"><a href="#1-select-gt-时间复杂度O-n" class="headerlink" title="1 select==&gt;时间复杂度O(n)"></a>1 select==&gt;时间复杂度O(n)</h1><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><h1 id="2-poll-gt-时间复杂度O-n"><a href="#2-poll-gt-时间复杂度O-n" class="headerlink" title="2 poll==&gt;时间复杂度O(n)"></a>2 poll==&gt;时间复杂度O(n)</h1><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.</p><h1 id="3-epoll-gt-时间复杂度O-1"><a href="#3-epoll-gt-时间复杂度O-1" class="headerlink" title="3 epoll==&gt;时间复杂度O(1)"></a>3 epoll==&gt;时间复杂度O(1)</h1><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  </p><p><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select_poll_epoll区别</a></p><p>1.执行epoll_create时，创建了红黑树和就绪list链表。</p><p>2.执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。</p><p>3.执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p><p><a href="https://blog.csdn.net/weiyuefei/article/details/53006659">epoll为什么高效</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-select-gt-时间复杂度O-n&quot;&gt;&lt;a href=&quot;#1-select-gt-时间复杂度O-n&quot; class=&quot;headerlink&quot; title=&quot;1 select==&amp;gt;时间复杂度O(n)&quot;&gt;&lt;/a&gt;1 select==&amp;gt;时间复杂度O(n)</summary>
      
    
    
    
    <category term="IO" scheme="http://example.com/categories/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>BIO_NIO_AIO总结</title>
    <link href="http://example.com/2020/10/29/Linux%E7%9A%845%E4%B8%ADIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2020/10/29/Linux%E7%9A%845%E4%B8%ADIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-29T08:06:54.000Z</published>
    <updated>2021-02-28T10:16:29.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-5中模型"><a href="#Linux-5中模型" class="headerlink" title="Linux 5中模型"></a>Linux 5中模型</h1><h2 id="1-阻塞式IO模型"><a href="#1-阻塞式IO模型" class="headerlink" title="1 阻塞式IO模型"></a>1 阻塞式IO模型</h2><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p>典型的阻塞IO的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; socket.read();</span><br></pre></td></tr></table></figure><p>如果数据没有就绪，就会一直阻塞在read方法。</p><h2 id="2-非阻塞IO模型"><a href="#2-非阻塞IO模型" class="headerlink" title="2 非阻塞IO模型"></a>2 非阻塞IO模型</h2><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU就，而会一直占用CPU。</p><p>典型的非阻塞IO模型一般如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line">    data &#x3D; socket.read();</span><br><span class="line">    if (data !&#x3D; error) &#123;</span><br><span class="line">        处理数据</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非阻塞IO的缺点：在while循环中需要不断询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般很少使用这种方法来读取数据。</li></ul><h2 id="3-IO复用模型"><a href="#3-IO复用模型" class="headerlink" title="3 IO复用模型"></a>3 IO复用模型</h2><p>多路复用IO模型是目前使用得比较多的模型，JAVA NIO实际上就是多路IO复用。</p><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，只有真正的socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这里会导致用户线程的阻塞。</p><p>多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。对于多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><ul><li>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li><li>要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</li></ul><p>在这里使用了反应器（Reactor）设计模式，如下图：<br><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/8A1410B068594ED1A69F9FE75623D2C9/8220"></p><p>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型(也可以理解为同步非阻塞(数据准备到内核的过程非阻塞))。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void UserEventHandler::handle_event() </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if(can_read(socket)) </span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        read(socket, buffer);</span><br><span class="line"> </span><br><span class="line">        process(buffer);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    Reactor.register(new UserEventHandler(socket));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reactor::handle_events() </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    while(1) </span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        sockets &#x3D; select();</span><br><span class="line"> </span><br><span class="line">        for(socket in sockets) </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            get_event_handler(socket).handle_event();</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-信号驱动IO模型"><a href="#4-信号驱动IO模型" class="headerlink" title="4 信号驱动IO模型"></a>4 信号驱动IO模型</h2><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p><h2 id="5-异步IO模型"><a href="#5-异步IO模型" class="headerlink" title="5 异步IO模型"></a>5 异步IO模型</h2><p>异步IO模型中，用户线程发起操作之后，立刻就可以去做其他的事。而另一方面，从内核的角度，当它收到一个asynchronous之后，会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。</p><p>也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</p><p>注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。</p><blockquote><p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞(从内核read)。</p></blockquote><p><a href="https://www.cnblogs.com/dushangguzhousuoli/p/10822262.html">5种IO模型</a></p><p><a href="https://www.cnblogs.com/bitkevin/p/5724410.html">Reactor模式和Proactor模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-5中模型&quot;&gt;&lt;a href=&quot;#Linux-5中模型&quot; class=&quot;headerlink&quot; title=&quot;Linux 5中模型&quot;&gt;&lt;/a&gt;Linux 5中模型&lt;/h1&gt;&lt;h2 id=&quot;1-阻塞式IO模型&quot;&gt;&lt;a href=&quot;#1-阻塞式IO模型&quot; c</summary>
      
    
    
    
    <category term="IO" scheme="http://example.com/categories/IO/"/>
    
    
  </entry>
  
  <entry>
    <title>BIO_NIO_AIO总结</title>
    <link href="http://example.com/2020/10/29/BIO_NIO_AIO%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/10/29/BIO_NIO_AIO%E6%80%BB%E7%BB%93/</id>
    <published>2020-10-29T08:06:54.000Z</published>
    <updated>2021-02-28T10:16:29.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同步异步阻塞非阻塞"><a href="#1-同步异步阻塞非阻塞" class="headerlink" title="1 同步异步阻塞非阻塞"></a>1 同步异步阻塞非阻塞</h1><h2 id="1-1-同步与异步"><a href="#1-1-同步与异步" class="headerlink" title="1.1 同步与异步"></a>1.1 同步与异步</h2><p>同步和异步描述的是一种消息通知的机制，主动等待消息返回还是被动接受消息。</p><ul><li>同步：同步IO指的是调用方通过主动等待获取调用返回的结果来获取消息通知。</li><li>异步：异步IO指的是被调用方通过某种方式（如，回调函数）来通知调用方获取消息。</li></ul><h2 id="1-2-阻塞和非阻塞"><a href="#1-2-阻塞和非阻塞" class="headerlink" title="1.2 阻塞和非阻塞"></a>1.2 阻塞和非阻塞</h2><p>阻塞和非阻塞描述的是调用方在获取消息过程中的状态，阻塞等待还是立刻返回。</p><ul><li>阻塞IO指的是调用方在获取消息的过程中会挂起阻塞，直到获取到消息。</li><li>非阻塞IO指的是调用方在获取IO的过程中会立刻返回而不进行挂起。</li></ul><h1 id="2-BIO"><a href="#2-BIO" class="headerlink" title="2 BIO"></a>2 BIO</h1><p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p><h2 id="2-1-传统BIO"><a href="#2-1-传统BIO" class="headerlink" title="2.1 传统BIO"></a>2.1 传统BIO</h2><p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/1B620F8437B04888AAB5AA2638CD9558/3792" alt="BIO"></p><blockquote><p>IO过程中涉及两个过程，到网卡的数据通过内核调用到达内核区内存，用户程序再将内核区数据拷到用户区，再读入到程序中。在上图中accept和read两个过程都是阻塞的。</p></blockquote><ul><li>采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() <strong>linux native方法，建立连接，也就是把数据读到内核区</strong> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</li><li>无论是NIO还是BIO，读取输入流的过程都是阻塞的，即从内存中读取数据写数据的过程。即多个socket连接只能有一个进行读写操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端</span><br><span class="line">public class IOClient &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO 创建多个线程，模拟多个客户端连接服务端</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        Socket socket &#x3D; new Socket(&quot;127.0.0.1&quot;, 3333);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            socket.getOutputStream().write((new Date() + &quot;: hello world&quot;).getBytes());</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务端</span><br><span class="line">public class IOServer &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO 服务端处理客户端连接请求</span><br><span class="line">    ServerSocket serverSocket &#x3D; new ServerSocket(3333);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 阻塞方法获取新的连接</span><br><span class="line">          Socket socket &#x3D; serverSocket.accept();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 每一个新的连接都创建一个线程，负责读取数据</span><br><span class="line">          new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              int len;</span><br><span class="line">              byte[] data &#x3D; new byte[1024];</span><br><span class="line">              InputStream inputStream &#x3D; socket.getInputStream();</span><br><span class="line">              &#x2F;&#x2F; 按字节流方式读取数据(阻塞)</span><br><span class="line">              while ((len &#x3D; inputStream.read(data)) !&#x3D; -1) &#123;</span><br><span class="line">                System.out.println(new String(data, 0, len));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-BIO改进，伪异步IO"><a href="#2-2-BIO改进，伪异步IO" class="headerlink" title="2.2 BIO改进，伪异步IO"></a>2.2 BIO改进，伪异步IO</h2><p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/470934604B5343609AB712EE118A9B3A/3795"></p><ul><li><p>如上图所示，每accept一个socket，就会产生一个新的线程。这样就会支持多个socket同时读写，通过线程池可以改善性能，在并发量不大的情况在可行。</p></li><li><p>对BIO进行多线程上的改进，当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p></li></ul><h2 id="2-3-当客户端并发访问量增加后这种模型会出现什么问题？"><a href="#2-3-当客户端并发访问量增加后这种模型会出现什么问题？" class="headerlink" title="2.3 当客户端并发访问量增加后这种模型会出现什么问题？"></a>2.3 当客户端并发访问量增加后这种模型会出现什么问题？</h2><p>在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p><h1 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3 NIO"></a>3 NIO</h1><ul><li>NIO，可以看做是通过selector进行IO多路复用</li><li>Java NIO和IO之间最大的区别是IO是面向流（Stream）的，NIO是面向块（buffer）</li></ul><p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/7D92B0EF4C404E2DB7DC55684F75A058/3755"></p><p>如上图所示，从网卡调到内核空间的过程是非阻塞的调用函数为，epoll() 和 recvfrom() 等native方法。也就是数据准备阶段是非阻塞的。</p><p>从源码上看，select通过轮训选择有响应的socket，做读写操作是阻塞的，要注意select的过程是阻塞的，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，select() 方法将返回所发生的事件的数量,可以用分布式多线程提升性能。</p><blockquote><p>注意,为了提升性能，有时候会使用公共内存，减少数据从内核拷贝到用户区消耗的性能。</p></blockquote><p>IO流是阻塞的，NIO流是不阻塞的。也就是说select到的channel即表明数据已经全部存到buffer中，只需要从buffer中取即可。同步的含义是需要轮训判断是否读取完毕。读写过程中可以做别的事情，但如果读写的线程只有一个，性能较低，可以开多个线程进行读写。</p><p>NIO 包含下面几个核心的组件：</p><ul><li>Channel(通道)</li><li>Buffer(缓冲区)</li><li>Selector(选择器)</li></ul><p>NIO与IO区别：</p><ul><li>NIO少了1次从内核空间到用户空间的拷贝。（零拷贝）<br>ByteBuffer.allocateDirect()分配的内存使用的是本机内存而不是Java堆上的内存，和网络或者磁盘交互都在操作系统的内核空间中发生。allocateDirect()的区别在于这块内存不由java堆管理, 但仍然在同一用户进程内。</li><li>NIO以块处理数据，IO以流处理数据</li><li>非阻塞，NIO1个线程可以管理多个输入输出通道</li></ul><p>缓冲区的存在导致读入内核空间的过程是非阻塞的。缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class NIOServer &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，</span><br><span class="line">    &#x2F;&#x2F; 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等</span><br><span class="line">    Selector serverSelector &#x3D; Selector.open();</span><br><span class="line">    &#x2F;&#x2F; 2. clientSelector负责轮询连接是否有数据可读</span><br><span class="line">    Selector clientSelector &#x3D; Selector.open();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 对应IO编程中服务端启动</span><br><span class="line">        ServerSocketChannel listenerChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">        listenerChannel.socket().bind(new InetSocketAddress(3333));</span><br><span class="line">        listenerChannel.configureBlocking(false);</span><br><span class="line">        listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">          &#x2F;&#x2F; 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span><br><span class="line">          if (serverSelector.select(1) &gt; 0) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; set &#x3D; serverSelector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator &#x3D; set.iterator();</span><br><span class="line"></span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">              SelectionKey key &#x3D; keyIterator.next();</span><br><span class="line"></span><br><span class="line">              if (key.isAcceptable()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  &#x2F;&#x2F; (1)</span><br><span class="line">                  &#x2F;&#x2F; 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span><br><span class="line">                  SocketChannel clientChannel &#x3D; ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                  clientChannel.configureBlocking(false);</span><br><span class="line">                  clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  keyIterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          &#x2F;&#x2F; (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span><br><span class="line">          if (clientSelector.select(1) &gt; 0) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; set &#x3D; clientSelector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator &#x3D; set.iterator();</span><br><span class="line"></span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">              SelectionKey key &#x3D; keyIterator.next();</span><br><span class="line"></span><br><span class="line">              if (key.isReadable()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class="line">                  ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                  &#x2F;&#x2F; (3) 面向 Buffer</span><br><span class="line">                  clientChannel.read(byteBuffer);</span><br><span class="line">                  byteBuffer.flip();</span><br><span class="line">                  System.out.println(</span><br><span class="line">                      Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  keyIterator.remove();</span><br><span class="line">                  key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-几个有助理解的图"><a href="#4-几个有助理解的图" class="headerlink" title="4 几个有助理解的图"></a>4 几个有助理解的图</h1><p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/2341F85D9DAA47B0B4BA52E27C073D93/3777"><br><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/584105CFDCB145A0A387ECB07AA5B1F7/3779"><br><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/51931963C88A45D5968E96D61666E379/3831" alt="BIO"></p><center>BIO</center> <p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/F3C2D8748A7948EE85665B2489C34202/3833" alt="NIO"></p><center>NIO</center> <h1 id="5-Netty"><a href="#5-Netty" class="headerlink" title="5 Netty"></a>5 Netty</h1><p>Java 的开源框架  网络服务器客户端框架<br>使用netty的优点 java开源框架 原始nio有bug存在。</p><h2 id="5-1-Reactor线程模型"><a href="#5-1-Reactor线程模型" class="headerlink" title="5.1 Reactor线程模型"></a>5.1 Reactor线程模型</h2><ol><li>Reactor线程模型：<ul><li>单线程模型：所有的IO操作都由同一个NIO线程处理，仅限于一些小型应用场景。但在高负载、高并发等情况下使用单线程肯定就不太合理，主要是因为NIO的一个线程同时要去处理成千上万的请求 的时候，在性能上会支撑不了，即便CPU负载100%，对于海量消息的处理，编码解码以及读取、发送消息等情况，依然满足不了。</li><li>当NIO的线程负载过重之后，整体服务性能处理就会变慢，结果就是导致客户端在向服务端发起请求、链接就会超时，由于客户端一般都会有一种超时机制，反复地向服务端再次发起请求，此时就相当于陷入了死循环，更加加重了服务器负载。</li></ul></li></ol><p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/B625A11242CB43F083E51B956D643D32/3871"></p><ol start="2"><li>多线程模型：由一组NIO线程处理IO操作</li><li>主从线程模型：一组线程池接受请求，一组线程池处理IO</li></ol><p><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/60BD876D2259409CB7E63A33998D2511/3869"></p><p>多线程：一组nio线程处理io操作<br><img src="http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/997E77E15F7D45E8BC40AAEA8A73B5AB/3867"></p><p>重点概念：线程池  等待队列<br>主从线程模型：一组线程池接受请求，一组线程池，处理io</p><p><a href="https://blog.csdn.net/quxing10086/article/details/80296245">https://blog.csdn.net/quxing10086/article/details/80296245</a></p><h1 id="6-epoll（Todo）"><a href="#6-epoll（Todo）" class="headerlink" title="6 epoll（Todo）"></a>6 epoll（Todo）</h1><p><a href="https://blog.csdn.net/songchuwang1868/article/details/89877739">https://blog.csdn.net/songchuwang1868/article/details/89877739</a></p><h1 id="7-sync"><a href="#7-sync" class="headerlink" title="7 sync"></a>7 sync</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-同步异步阻塞非阻塞&quot;&gt;&lt;a href=&quot;#1-同步异步阻塞非阻塞&quot; class=&quot;headerlink&quot; title=&quot;1 同步异步阻塞非阻塞&quot;&gt;&lt;/a&gt;1 同步异步阻塞非阻塞&lt;/h1&gt;&lt;h2 id=&quot;1-1-同步与异步&quot;&gt;&lt;a href=&quot;#1-1-同步与异</summary>
      
    
    
    
    <category term="IO" scheme="http://example.com/categories/IO/"/>
    
    
  </entry>
  
</feed>
