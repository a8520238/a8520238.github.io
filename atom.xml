<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lgz_blog</title>
  
  <subtitle>Hey!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T12:31:33.719Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lgz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/28/java/Java%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/"/>
    <id>http://example.com/2021/02/28/java/Java%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</id>
    <published>2021-02-28T12:31:33.719Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的静态分派和动态分派"><a href="#Java的静态分派和动态分派" class="headerlink" title="Java的静态分派和动态分派"></a>Java的静态分派和动态分派</h1><p>由来：Class文件就在编译过程中，一切方法都只是符号引用，而不是实际地址（直接引用）。直到类加载时期，甚至到运行期间才能确定目标方法的直接引用。这个特性给Java带来了强大的动态扩展能力。</p><h2 id="1-解析"><a href="#1-解析" class="headerlink" title="1 解析"></a>1 解析</h2><ul><li>解析阶段将符号引用转换为直接引用</li><li>解析能成立的前提：方法在程序真正执行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可变的。也就是调用目标在编译期就要确定下来。</li><li>Java语言中符合”编译期可知，运行期不可变”，可以分为静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们不可能通过继承或别的方式重写其他版本，因此他们适合在类加载阶段进行解析。</li><li><strong>静态方法、私有方法、实例构造器、父类方法。这些方法称为非虚方法，它们在类加载的时候就会把符号引用解析为该方法的直接引用。与之相反，其他方法称为虚方法（除去final方法）。</strong></li></ul><h2 id="2-分派"><a href="#2-分派" class="headerlink" title="2 分派"></a>2 分派</h2><h3 id="2-1-静态分派"><a href="#2-1-静态分派" class="headerlink" title="2.1 静态分派"></a>2.1 静态分派</h3><p>可以将父类成为变量的静态类型，继承的子类为变量的实际类型。</p><p>静态类型和实际类型在程序中都可以发生一些变化。</p><p>区别：</p><ul><li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译器可知。</li><li>实际类型变化的结果在运行期才确定，编译器在编译期并不知道一个对象的实际类型是什么。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line">static abstract class Human&#123;</span><br><span class="line">&#125;</span><br><span class="line">static class Man extends Human&#123;</span><br><span class="line">&#125;</span><br><span class="line">static class Woman extends Human&#123;</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Human guy)&#123;</span><br><span class="line">System.out.println(&quot;hello,guy!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Man guy)&#123;</span><br><span class="line">System.out.println(&quot;hello,gentlemen!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Woman guy)&#123;</span><br><span class="line">System.out.println(&quot;hello,lady!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Human man&#x3D;new Man();</span><br><span class="line">Human woman&#x3D;new Woman();</span><br><span class="line">sayHello(man);</span><br><span class="line">sayHello(woman);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">hello,guy!</span><br><span class="line">hello,guy!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子说明：<strong>编译器在重载时是通过参数的静态类型而不是实际类型作为判定的依据</strong>。并且静态类型在编译期可知，因此，编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。<strong>换句话说因为该方法是重载。</strong> </p><blockquote><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用就是方法重载。</p></blockquote><h3 id="2-2-动态分派"><a href="#2-2-动态分派" class="headerlink" title="2.2 动态分派"></a>2.2 动态分派</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">static abstract class Human&#123;</span><br><span class="line">protected abstract void sayHello();</span><br><span class="line">&#125;</span><br><span class="line">static class Man extends Human&#123; </span><br><span class="line">@Override</span><br><span class="line">protected void sayHello() &#123; </span><br><span class="line">System.out.println(&quot;man say hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">static class Woman extends Human&#123; </span><br><span class="line">@Override</span><br><span class="line">protected void sayHello() &#123; </span><br><span class="line">System.out.println(&quot;woman say hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Human man&#x3D;new Man();</span><br><span class="line">Human woman&#x3D;new Woman();</span><br><span class="line">man.sayHello();</span><br><span class="line">woman.sayHello();</span><br><span class="line">man&#x3D;new Woman();</span><br><span class="line">man.sayHello(); </span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">man say hello!</span><br><span class="line">woman say hello!</span><br><span class="line">woman say hello!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面描述Java虚拟机是如何根据实际类型来分派方法执行版本:</p><ol><li>invokevirtual指令的多态查找过程</li></ol><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。</li><li>否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。</li></ul><ol start="2"><li>本质</li></ol><ul><li>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，<strong>所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上</strong>，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ul><ol start="3"><li>实际操作</li></ol><ul><li>为了保证性能，实际操作中不会出现对方法进行频繁的搜索。</li><li>对这种情况，最常用的”稳定优化“手段就是为类在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable），使用虚方法表索引来代替元数据查找以提高性能。</li><li>虚方法表：<ul><li>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实际入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实际版本的入口地址。</li><li>为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。</li><li>方法表一般在类加载阶段的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</li></ul></li><li>虚方法表中的实际指向是在运行时赋值是给出的，因为加载父类时，不知道真实指向。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java的静态分派和动态分派&quot;&gt;&lt;a href=&quot;#Java的静态分派和动态分派&quot; class=&quot;headerlink&quot; title=&quot;Java的静态分派和动态分派&quot;&gt;&lt;/a&gt;Java的静态分派和动态分派&lt;/h1&gt;&lt;p&gt;由来：Class文件就在编译过程中，一切方法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/28/java/java%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2021/02/28/java/java%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98/</id>
    <published>2021-02-28T12:31:33.719Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-堆中的对象内存"><a href="#Java-堆中的对象内存" class="headerlink" title="Java 堆中的对象内存"></a>Java 堆中的对象内存</h1><h2 id="1-java-中的对象指向问题"><a href="#1-java-中的对象指向问题" class="headerlink" title="1 java 中的对象指向问题"></a>1 java 中的对象指向问题</h2><h3 id="1-1-方法区指向堆"><a href="#1-1-方法区指向堆" class="headerlink" title="1.1 方法区指向堆"></a>1.1 方法区指向堆</h3><p><code>private static User user=new User();</code> </p><ul><li><p>引用变量user是静态的，所以存放在方法区中，而真实的user对象存放在堆中。所以，这就形成了方法区指向堆。</p></li><li><p>或者类变量是静态的，也会指向堆。</p></li><li><p>或者是final修饰的类常量。</p></li></ul><h3 id="1-2-虚拟机线程栈指向堆"><a href="#1-2-虚拟机线程栈指向堆" class="headerlink" title="1.2 虚拟机线程栈指向堆"></a>1.2 虚拟机线程栈指向堆</h3><p>类的方法中的属性存放在虚拟机栈的局部变量表 中，对象实例同样存在在堆中。</p><h2 id="2-堆中对象的实例的布局"><a href="#2-堆中对象的实例的布局" class="headerlink" title="2 堆中对象的实例的布局"></a>2 堆中对象的实例的布局</h2><h3 id="2-1-对象内存模型"><a href="#2-1-对象内存模型" class="headerlink" title="2.1 对象内存模型"></a>2.1 对象内存模型</h3><p>java 中的对象内存布局：</p><ul><li>对象头 Header<ul><li>mark word ： 8 字节</li><li>class pointer ： 未指针压缩时 8 字节，压缩后 4 字节</li><li>数组 length （数组对象特有）： 4 字节</li></ul></li><li>对象实例数据 Instance Data ：</li><li>对齐填充 Padding ： 填充为 8 字节的整数倍</li></ul><p><img src="http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/88CB4B6F16FA4A71A606DA0E62EC8BE5/9123" alt="java 中的对象内存布局"></p><h3 id="2-2-Object-obj-new-Object-占用的字节"><a href="#2-2-Object-obj-new-Object-占用的字节" class="headerlink" title="2.2 Object obj = new Object() 占用的字节"></a>2.2 Object obj = new Object() 占用的字节</h3><p>实例数据为空，mark word 占 8 字节，其他：</p><ul><li>若开启了类指针压缩 则 class pointer 占4字节，然后 padding 填充 4 字节</li><li>若没开启，则 class pointer 占 8 字节，padding 不填充</li></ul><p>所以，一共占用 16 字节。</p><h2 id="3-堆中对象访问"><a href="#3-堆中对象访问" class="headerlink" title="3 堆中对象访问"></a>3 堆中对象访问</h2><h3 id="3-1-句柄访问"><a href="#3-1-句柄访问" class="headerlink" title="3.1 句柄访问"></a>3.1 句柄访问</h3><p>堆中划分出一块空间来存放 句柄池 , 即 方法区/栈帧 中的对象引用是存放的句柄地址，通过句柄池再在堆中查找对象的实际地址。</p><p><img src="http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/7EA3C812D0484F4583883EAF2DCE4445/2708" alt="句柄访问"></p><h3 id="3-2-直接指针访问-hot-spot"><a href="#3-2-直接指针访问-hot-spot" class="headerlink" title="3.2 直接指针访问 (hot spot)"></a>3.2 直接指针访问 (hot spot)</h3><p>堆中直接存放对象的实例数据，即 方法区/栈帧 中的对象引用直接指向堆实例的地址。</p><p><img src="http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/0F7750F4ACE14A5BB5B93239A0203931/2707" alt="直接指针访问"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-堆中的对象内存&quot;&gt;&lt;a href=&quot;#Java-堆中的对象内存&quot; class=&quot;headerlink&quot; title=&quot;Java 堆中的对象内存&quot;&gt;&lt;/a&gt;Java 堆中的对象内存&lt;/h1&gt;&lt;h2 id=&quot;1-java-中的对象指向问题&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>javaWeb</title>
    <link href="http://example.com/2021/02/27/java/JavaWeb/"/>
    <id>http://example.com/2021/02/27/java/JavaWeb/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><ul><li>静态web, 提供给所有人看的数据始终不会发生变化。</li><li>动态web，每个人在不同的时间不同的地点看到的信息都不相同。</li></ul><h3 id="1-1-默认端口合计"><a href="#1-1-默认端口合计" class="headerlink" title="1.1 默认端口合计"></a>1.1 默认端口合计</h3><ul><li>tomcat: 8080</li><li>mysql: 3306</li><li>http:80</li><li>https:443</li></ul><h2 id="2-浏览器与服务器交互的过程"><a href="#2-浏览器与服务器交互的过程" class="headerlink" title="2 浏览器与服务器交互的过程"></a>2 浏览器与服务器交互的过程</h2><p>假设我们配置虚拟主机<a href="http://www.gacl.cn,并绑定了8080端口，并配置了虚拟主机映射如下：">www.gacl.cn,并绑定了8080端口，并配置了虚拟主机映射如下：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host name&#x3D;&quot;www.gacl.cn&quot; appBase&#x3D;&quot;F:\JavaWebApps&quot;&gt;</span><br><span class="line">      </span><br><span class="line">&lt;&#x2F;Host&gt;</span><br></pre></td></tr></table></figure><p>客户机查找的过程如下：<br><img src="http://note.youdao.com/yws/public/resource/bca95011244292ba9b4a461a47885868/xmlnote/D1C70AFCAB4B437EA3C064B1DFBDDFE4/6739"></p><p>当我们打开浏览器，在浏览器的地址栏中输入URL地址”<a href="http://www.gacl.cn:8080/JavaWebDemo1/1.jsp&quot;%E5%8E%BB%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%841.jsp%E8%BF%99%E4%B8%AAweb%E8%B5%84%E6%BA%90%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%BD%E5%81%9A%E4%BA%86%E7%A5%9E%E9%A9%AC%E6%93%8D%E4%BD%9C%E5%91%A2%EF%BC%8C%E6%88%91%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E9%9D%A2%E7%9C%8B%E5%88%B01.jsp%E8%BF%99%E4%B8%AAweb%E8%B5%84%E6%BA%90%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E7%9A%84%E5%91%A2%EF%BC%9F">http://www.gacl.cn:8080/JavaWebDemo1/1.jsp&quot;去访问服务器上的1.jsp这个web资源的过程中，浏览器和服务器都做了神马操作呢，我们是怎么在浏览器里面看到1.jsp这个web资源里面的内容的呢？</a></p><p>浏览器和服务器做了以下几个操作：</p><p>　　1、浏览器根据主机名”<a href="http://www.gacl.cn&quot;去操作系统的hosts文件中查找主机名对应的ip地址./">www.gacl.cn&quot;去操作系统的Hosts文件中查找主机名对应的IP地址。</a></p><p>　　2、浏览器如果在操作系统的Hosts文件中没有找到对应的IP地址，就去互联网上的DNS服务器上查找”<a href="http://www.gacl.cn&quot;这台主机对应的ip地址./">www.gacl.cn&quot;这台主机对应的IP地址。</a></p><p>　　3、浏览器查找到”<a href="http://www.gacl.cn&quot;这台主机对应的ip地址后,就使用ip地址连接到web服务器.**也就是通过ip定位到主机/">www.gacl.cn&quot;这台主机对应的IP地址后，就使用IP地址连接到Web服务器。**也就是通过IP定位到主机</a>**</p><p>　　4、浏览器连接到web服务器后，就使用http协议向服务器发送请求，发送请求的过程中，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源。</p><p>5、浏览器做完上面4步工作后，就开始等待，等待Web服务器把自己想要访问的1.jsp这个Web资源传输给它。</p><p>　　6、服务器接收到浏览器传输的数据后，开始解析接收到的数据，服务器解析”GET /JavaWebDemo1/1.jsp HTTP/1.1”里面的内容时知道客户端浏览器要访问的是JavaWebDemo1应用里面的1.jsp这个Web资源，然后服务器就去读取1.jsp这个Web资源里面的内容，将读到的内容再以Stream(流)的形式传输给浏览器。　　</p><h2 id="3-三层架构"><a href="#3-三层架构" class="headerlink" title="3 三层架构"></a>3 三层架构</h2><p><img src="http://note.youdao.com/yws/public/resource/bca95011244292ba9b4a461a47885868/xmlnote/3C07BADF838C4948A23549ADE5760FD3/7046"></p><h1 id="toDO"><a href="#toDO" class="headerlink" title="toDO"></a>toDO</h1><p><a href="https://www.cnblogs.com/xdp-gacl/p/3744053.html">jAVA WEB</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaWeb&quot;&gt;&lt;a href=&quot;#JavaWeb&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb&quot;&gt;&lt;/a&gt;JavaWeb&lt;/h1&gt;&lt;h2 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="javaEE" scheme="http://example.com/categories/javaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="http://example.com/2021/02/27/java/String%E7%B1%BB/"/>
    <id>http://example.com/2021/02/27/java/String%E7%B1%BB/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-String-str-“”-和-new-String-区别"><a href="#1-String-str-“”-和-new-String-区别" class="headerlink" title="1 String str= “” 和 new String()区别"></a>1 String str= “” 和 new String()区别</h1><h2 id="String-str1-“abc”"><a href="#String-str1-“abc”" class="headerlink" title="String str1= “abc”"></a>String str1= “abc”</h2><p>在编译期，JVM会去常量池来查找是否存在“abc”，</p><p>如果不存在，就在常量池中开辟一个空间来存储“abc”；如果存在，就不用新开辟空间。</p><p>然后在栈内存中开辟一个名字为str1的空间，来存储“abc”在常量池中的地址值。</p><h2 id="String-str2-new-String-“abc”"><a href="#String-str2-new-String-“abc”" class="headerlink" title="String str2 = new String(“abc”)"></a>String str2 = new String(“abc”)</h2><p>在编译阶段JVM先去常量池中查找是否存在“abc”，如果过不存在，则在常量池中开辟一个空间存储“abc”。</p><p>在运行时期，通过String类的构造器在堆内存中new了一个空间，然后将String池中的“abc”复制一份存放到该堆空间中，在栈中开辟名字为str2的空间，存放堆中new出来的这个String对象的地址值。</p><p>也就是说，前者在初始化的时候可能创建了一个对象，也可能一个对象也没有创建；后者因为new关键字，至少在内存中创建了一个对象，也有可能是两个对象。</p><p><img src="http://note.youdao.com/yws/public/resource/cf631267d2ad6409b8796f1bae308c36/xmlnote/F7F6A16B9D124D96806319258EE3D80E/6690"></p><h2 id="特殊创建中，常量池中没有，堆中有"><a href="#特殊创建中，常量池中没有，堆中有" class="headerlink" title="特殊创建中，常量池中没有，堆中有"></a>特殊创建中，常量池中没有，堆中有</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; new String(&quot;he&quot;)+new String(&quot;llo&quot;); </span><br></pre></td></tr></table></figure><ol><li>这个代码中，首先，new String(“he”)，先在常量池中看，发现没有这个”he”常量，于是建一个，然后再在堆中创建一个String的对象（但没引用，很快被gc的）。</li><li>加法，暗中new了StringBuilder，调用append方法。</li><li>new String(“llo”)一样的道理，堆中一个String对象，常量池中”llo”常量对象。</li><li>StringBuilder的append方法搞定后，调用toString()方法，具体是new一个String对象，也就是现在是一个堆中的String对象，内容是”hello”，但注意这个hello没有在常量池中创建！！其实可以理解因为没有出现过一次”hello”，拼接是通过StringBuilder的append方法完成的。</li></ol><blockquote><p>总之：对于所有包含new方式新建对象（包括null）和变量形式 的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p></blockquote><h1 id="2-String为什么是不可变的？"><a href="#2-String为什么是不可变的？" class="headerlink" title="2 String为什么是不可变的？"></a>2 String为什么是不可变的？</h1><p>效率和安全两方面考虑</p><p>1).不可变对象可以提高String Pool的效率和安全性。如果你知道一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址（通常一个指针的大小）需要很小的内存效率也很高。对于同时引用这个“ABC”的其他变量也不会造成影响。</p><p>2).不可变对象对于多线程是安全的，因为在多线程同时进行的情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况。</p><blockquote><blockquote><p>注意字符串引用名相加，相当于new一个String</p></blockquote></blockquote><blockquote><blockquote><p><a href="https://blog.csdn.net/u010887744/article/details/50844525">https://blog.csdn.net/u010887744/article/details/50844525</a></p></blockquote></blockquote><h1 id="3-字符串常量池的位置"><a href="#3-字符串常量池的位置" class="headerlink" title="3 字符串常量池的位置"></a>3 字符串常量池的位置</h1><p>在JDK 7以前的版本中，字符串常量池是放在永久代中的。</p><p>因为按照计划，JDK会在后续的版本中通过元空间来代替永久代，所以首先在JDK 7中，将字符串常量池先从永久代中移出，暂时放到了堆内存中。</p><p>在JDK 8中，彻底移除了永久代，使用元空间替代了永久代，于是字符串常量池再次从堆内存移动到永久代中</p><h1 id="4-JDK6和JDK7中substring的原理和区别"><a href="#4-JDK6和JDK7中substring的原理和区别" class="headerlink" title="4 JDK6和JDK7中substring的原理和区别"></a>4 JDK6和JDK7中substring的原理和区别</h1><ol><li>JDK6 中的substring</li></ol><ul><li>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。</li><li>当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的。</li></ul><ol start="2"><li>JDK6中substring导致的问题：</li></ol><ul><li>如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。</li><li>在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; x.substring(x, y) + &quot;&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>JDK7中的substring</li></ol><p>上面提到的问题，在jdk 7中得到解决。在jdk 7 中，substring方法会在堆内存中创建一个新的数组。其使用new String创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p><h1 id="5-replaceFirst、replaceAll、replace"><a href="#5-replaceFirst、replaceAll、replace" class="headerlink" title="5 replaceFirst、replaceAll、replace"></a>5 replaceFirst、replaceAll、replace</h1><p>replace(CharSequence target, CharSequence replacement) ，用replacement替换所有的target，两个参数都是字符串。</p><p>replaceAll(String regex, String replacement) ，用replacement替换所有的regex匹配项，regex很明显是个正则表达式，replacement是字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;文字替换（全部） </span><br><span class="line">Pattern pattern &#x3D; Pattern.compile(&quot;正则表达式&quot;); </span><br><span class="line">Matcher matcher &#x3D; pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello World&quot;); </span><br><span class="line">&#x2F;&#x2F; Java Hello World,Java Hello World</span><br><span class="line">System.out.println(matcher.replaceAll(&quot;Java&quot;));</span><br></pre></td></tr></table></figure><p>replaceFirst(String regex, String replacement) ，基本和replaceAll相同，区别是只替换第一个匹配项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;文字替换（首次出现字符） </span><br><span class="line">Pattern pattern &#x3D; Pattern.compile(&quot;正则表达式&quot;); </span><br><span class="line">Matcher matcher &#x3D; pattern.matcher(&quot;正则表达式 Hello World,正则表达式 Hello World&quot;); </span><br><span class="line">&#x2F;&#x2F;Java Hello World,正则表达式 Hello World</span><br><span class="line">System.out.println(matcher.replaceFirst(&quot;Java&quot;)); </span><br></pre></td></tr></table></figure><h1 id="6-Pattern和Matcher"><a href="#6-Pattern和Matcher" class="headerlink" title="6 Pattern和Matcher"></a>6 Pattern和Matcher</h1><ol><li>Pattern是创建一个正则匹配串，只能通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern &#x3D; Pattern.compile(&quot;正则表达式&quot;); </span><br></pre></td></tr></table></figure>来创建，因为他的构造方法是私有的。其作用是编译正则表达式后创建一个匹配模式.</li></ol><p>常用方法介绍：</p><ul><li>Pattern complie(String regex)，由于Pattern的构造函数是私有的,不可以直接创建,所以通过静态方法compile(String regex)方法来创建,将给定的正则表达式编译并赋予给Pattern类。</li><li>String pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数。</li><li>Pattern.matcher(CharSequence input) 对指定输入的字符串创建一个Matcher对象。</li><li>String[] split(CharSequence input, int limit)<br>功能和String[] split(CharSequence input)相同,增加参数limit目的在于要指定分割的段数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String regex &#x3D; &quot;\\?|\\*&quot;;</span><br><span class="line">Pattern pattern &#x3D; Pattern.compile(regex);</span><br><span class="line">String[] splitStrs &#x3D; pattern.split(&quot;123?123*456*456&quot;);&#x2F;&#x2F;123 123 456 456</span><br><span class="line">String[] splitStrs2 &#x3D; pattern.split(&quot;123?123*456*456&quot;, 2);&#x2F;&#x2F; 123 123*456*456</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>Matcher类使用Pattern实例提供的模式信息对正则表达式进行匹配</li></ol><ul><li>boolean matches() 最常用方法:尝试对整个目标字符展开匹配检测,也就是只有整个目标字符串完全匹配时才返回真值.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern &#x3D; Pattern.compile(&quot;\\?&#123;2&#125;&quot;);</span><br><span class="line">Matcher matcher &#x3D; pattern.matcher(&quot;??&quot;);</span><br><span class="line">boolean matches &#x3D; matcher.matches();&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li>boolean lookingAt() 对前面的字符串进行匹配,只有匹配到的字符串在最前面才会返回true.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p &#x3D; Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line">Matcher m &#x3D; p.matcher(&quot;22bb23&quot;);</span><br><span class="line">boolean match &#x3D; m.lookingAt();&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li>boolean find() 对字符串进行匹配,匹配到的字符串可以在任何位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pattern p &#x3D; Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line">Matcher m &#x3D; p.matcher(&quot;22bb23&quot;);</span><br><span class="line">m.find();&#x2F;&#x2F; 返回true</span><br><span class="line">Matcher m2 &#x3D; p.matcher(&quot;aa2223&quot;);</span><br><span class="line">m2.find();&#x2F;&#x2F; 返回true</span><br><span class="line">Matcher m3 &#x3D; p.matcher(&quot;aa2223bb&quot;);</span><br><span class="line">m3.find();&#x2F;&#x2F; 返回true</span><br><span class="line">Matcher m4 &#x3D; p.matcher(&quot;aabb&quot;);</span><br><span class="line">m4.find();&#x2F;&#x2F; 返回false</span><br></pre></td></tr></table></figure></li><li>group，返回匹配到的字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pattern p &#x3D; Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line">Matcher m &#x3D; p.matcher(&quot;aa22bb23&quot;);</span><br><span class="line">m.find();</span><br><span class="line">int start &#x3D; m.start();&#x2F;&#x2F;2</span><br><span class="line">String group &#x3D; m.group();&#x2F;&#x2F;22</span><br><span class="line">int end &#x3D; m.end();&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Pattern模式 </li></ol><ul><li>Pattern.MULTILINE模式的用法</li></ul><p>正则表达式中出现了^或者$, 默认只会匹配第一行. 设置了Pattern.MULTILINE模式,会匹配所有行。例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pattern p1 &#x3D; Pattern.compile(&quot;^.*b.*$&quot;);</span><br><span class="line">&#x2F;&#x2F;输出false,因为正则表达式中出现了^或$，默认只会匹配第一行，第二行的b匹配不到。</span><br><span class="line">System.out.println(p1.matcher(&quot;a\nb&quot;).find());</span><br><span class="line">Pattern p2 &#x3D; Pattern.compile(&quot;^.*b.*$&quot;,Pattern.MULTILINE);</span><br><span class="line">&#x2F;&#x2F;输出true,指定了Pattern.MULTILINE模式，就可以匹配多行了。</span><br><span class="line">System.out.println(p2.matcher(&quot;a\nb&quot;).find());</span><br></pre></td></tr></table></figure><ul><li>Pattern.DOTALL模式的用法</li></ul><p>默认情况下, 正则表达式中点(.)不会匹配换行符, 设置了Pattern.DOTALL模式, 才会匹配所有字符包括换行符。例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pattern p1 &#x3D; Pattern.compile(&quot;a.*b&quot;);</span><br><span class="line">&#x2F;&#x2F;输出false，默认点(.)没有匹配换行符</span><br><span class="line">System.out.println(p1.matcher(&quot;a\nb&quot;).find());</span><br><span class="line">Pattern p2 &#x3D; Pattern.compile(&quot;a.*b&quot;, Pattern.DOTALL);</span><br><span class="line">&#x2F;&#x2F;输出true,指定Pattern.DOTALL模式，可以匹配换行符。</span><br><span class="line">System.out.println(p2.matcher(&quot;a\nb&quot;).find());</span><br></pre></td></tr></table></figure><ul><li>同时指定Pattern.MULTILINE和Pattern.DOTALL模式</li></ul><p>实际情况中要是比较复杂的情况，可能Pattern.MULTILINE模式和Pattern.DOTAL模式需要同时指定来匹配多行，下面看一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pattern p1 &#x3D; Pattern.compile(&quot;^a.*b$&quot;);</span><br><span class="line">&#x2F;&#x2F;输出false</span><br><span class="line">System.out.println(p1.matcher(&quot;cc\na\nb&quot;).find());</span><br><span class="line">Pattern p2 &#x3D; Pattern.compile(&quot;^a.*b$&quot;, Pattern.DOTALL);</span><br><span class="line">&#x2F;&#x2F;输出false,因为有^或&amp;没有匹配到下一行</span><br><span class="line">System.out.println(p2.matcher(&quot;cc\na\nb&quot;).find());</span><br><span class="line">Pattern p3 &#x3D; Pattern.compile(&quot;^a.*b$&quot;, Pattern.MULTILINE);</span><br><span class="line">&#x2F;&#x2F;输出false，匹配到下一行，但.没有匹配换行符</span><br><span class="line">System.out.println(p3.matcher(&quot;cc\na\nb&quot;).find());</span><br><span class="line">&#x2F;&#x2F;指定多个模式，中间用|隔开</span><br><span class="line">Pattern p4 &#x3D; Pattern.compile(&quot;^a.*b$&quot;, Pattern.DOTALL|Pattern.MULTILINE);</span><br><span class="line">&#x2F;&#x2F;输出true</span><br><span class="line">System.out.println(p4.matcher(&quot;cc\na\nb&quot;).find());</span><br></pre></td></tr></table></figure><h1 id="7-String-s-a-b-c-d-e，共创建了多少对象"><a href="#7-String-s-a-b-c-d-e，共创建了多少对象" class="headerlink" title="7 String s = a + b + c + d + e，共创建了多少对象"></a>7 String s = a + b + c + d + e，共创建了多少对象</h1><ol><li>如果是String s = “a” + “b” + “c” + “d” + “e”</li></ol><ul><li>会创建1个对象，赋值符号右边的”a”、”b”、”c”、”d”、”e”都是常量<br>对于常量，编译时就直接存储它们的字面值而不是它们的引用<br>在编译时就直接讲它们连接的结果提取出来变成了”abcde”<br>该语句在class文件中就相当于String s = “abcde”<br>然后当JVM执行到这一句的时候， 就在String pool里找<br>如果没有这个字符串，就会产生一个。</li></ul><ol start="2"><li>String s = a+b+c+d+e; 其中各个字母都是引用</li></ol><ul><li>3个对象，但只有一个String对象。由于编译器的优化，最终代码为通过StringBuilder完成。</li><li>总结：三个对象分别为</li></ul><p>1 StringBuilder</p><p>2 new char[capacity]</p><p>3 new String(value,0,count);</p><blockquote><p>两个String 相加， 会转成StringBuilder.append</p></blockquote><h1 id="8-String连接"><a href="#8-String连接" class="headerlink" title="8 String连接"></a>8 String连接</h1><ul><li>+</li><li>concat</li><li>StringBuilder</li><li>StringBuffer</li><li>StringUtils.join</li></ul><blockquote><p>如果不是在循环体中进行字符串拼接的话，直接使用+就好了。</p></blockquote><blockquote><p>如果在并发场景中进行字符串拼接的话，要使用StringBuffer来代替StringBuilder。</p></blockquote><h1 id="9-String-valueOf和Integer-toString的区别"><a href="#9-String-valueOf和Integer-toString的区别" class="headerlink" title="9 String.valueOf和Integer.toString的区别"></a>9 String.valueOf和Integer.toString的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.int i &#x3D; 5;</span><br><span class="line">2.String i1 &#x3D; &quot;&quot; + i;</span><br><span class="line">3.String i2 &#x3D; String.valueOf(i);</span><br><span class="line">4.String i3 &#x3D; Integer.toString(i);</span><br></pre></td></tr></table></figure><p>第三行和第四行没有区别，因为String.valueOf(i)也是调用Integer.toString(i)来实现的。</p><p>第二行代码其实是String i1 = (new StringBuilder()).append(i).toString(); 首先创建一个StringBuilder对象。</p><h1 id="10-intern"><a href="#10-intern" class="headerlink" title="10 intern"></a>10 intern</h1><p>在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Q：下列程序的输出结果：</span><br><span class="line">String s1 &#x3D; “abc”;</span><br><span class="line">String s2 &#x3D; “abc”;</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);</span><br><span class="line">A：true，均指向常量池中对象。</span><br><span class="line"></span><br><span class="line">Q：下列程序的输出结果：</span><br><span class="line">String s1 &#x3D; new String(“abc”);</span><br><span class="line">String s2 &#x3D; new String(“abc”);</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);</span><br><span class="line">A：false，两个引用指向堆中的不同对象。</span><br><span class="line"></span><br><span class="line">Q：下列程序的输出结果：</span><br><span class="line">String s1 &#x3D; “abc”;</span><br><span class="line">final String s2 &#x3D; “a”;</span><br><span class="line">final String s3 &#x3D; “bc”;</span><br><span class="line">String s4 &#x3D; s2 + s3;</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s4);</span><br><span class="line">A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4&#x3D;”a”+”bc”，而这种情况下，编译器会直接合并为s4&#x3D;”abc”，所以最终s1&#x3D;&#x3D;s4。</span><br><span class="line"></span><br><span class="line">Q：下列程序的输出结果：</span><br><span class="line">String s1 &#x3D; “abc”;</span><br><span class="line">String s2 &#x3D; “a”;</span><br><span class="line">String s3 &#x3D; “bc”;</span><br><span class="line">String s4 &#x3D; s2 + s3;</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s4);</span><br><span class="line">A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String a &#x3D; &quot;abc&quot;;</span><br><span class="line">String b &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">System.out.println(a &#x3D;&#x3D; b);</span><br><span class="line">fasle 一个返回常量池，一个返回堆中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q：下列程序的输出结果：</span><br><span class="line">String s &#x3D; new String(“abc”);</span><br><span class="line">String s1 &#x3D; “abc”;</span><br><span class="line">String s2 &#x3D; new String(“abc”);</span><br><span class="line">System.out.println(s &#x3D;&#x3D; s1.intern());</span><br><span class="line">System.out.println(s &#x3D;&#x3D; s2.intern());</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2.intern());</span><br><span class="line">A：false，false，true。</span><br></pre></td></tr></table></figure><h2 id="10-1-1-6和1-7中的intern"><a href="#10-1-1-6和1-7中的intern" class="headerlink" title="10.1 1.6和1.7中的intern"></a>10.1 1.6和1.7中的intern</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str1 &#x3D; new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();</span><br><span class="line">    System.out.println(str1.intern() &#x3D;&#x3D; str1);</span><br><span class="line"></span><br><span class="line">    String str2 &#x3D; new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</span><br><span class="line">    System.out.println(str2.intern() &#x3D;&#x3D; str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在JDK1.6中，会得到两个false，在JDK1.7中运行，会得到一个true和一个false。</p><ul><li><p>书上说，产生差异的原因是：在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。</p></li><li><p>而JDK1.7的intern()不会再复制实例，只是在常量池中记录首次出现的实例的引用，因此intern()返回的引用和StringBuilder创建的那个字符串的实例是同一个。对str2比较返回false是因为”java”这个字符串在执行StringBuilder.toString()之前就已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p></li></ul><h2 id="10-2-stringTable"><a href="#10-2-stringTable" class="headerlink" title="10.2 stringTable"></a>10.2 stringTable</h2><p>这里先再提一下字符串常量池，实际上，为了提高匹配速度，也就是为了更快地查找某个字符串是否在常量池中，Java在设计常量池的时候，还搞了张stringTable，这个有点像我们的hashTable，根据字符串的hashCode定位到对应的桶，然后遍历数组查找该字符串对应的引用。如果找得到字符串，则返回引用，找不到则会把字符串常量放到常量池中，并把引用保存到stringTable了里面。</p><p>在JDK7、8中，可以通过-XX:StringTableSize参数StringTable大小</p><h2 id="10-3-jdk1-6及其之前的intern-方法"><a href="#10-3-jdk1-6及其之前的intern-方法" class="headerlink" title="10.3 jdk1.6及其之前的intern()方法"></a>10.3 jdk1.6及其之前的intern()方法</h2><p>在JDK6中，常量池在永久代分配内存，永久代和Java堆的内存是物理隔离的，执行intern方法时，如果常量池不存在该字符串，虚拟机会在常量池中复制该字符串，并返回引用；如果已经存在该字符串了，则直接返回这个常量池中的这个常量对象的引用。所以需要谨慎使用intern方法，避免常量池中字符串过多，导致性能变慢，甚至发生PermGen内存溢出。</p><p><strong>当然，这个常量池和堆是物理隔离的。</strong></p><p><img src="http://note.youdao.com/yws/public/resource/cf631267d2ad6409b8796f1bae308c36/xmlnote/9953192D405E40A490141C053FAEEC0F/6710"></p><h2 id="10-4-jdk1-7的intern-方法-1-8之后"><a href="#10-4-jdk1-7的intern-方法-1-8之后" class="headerlink" title="10.4 jdk1.7的intern()方法 (1.8之后)"></a>10.4 jdk1.7的intern()方法 (1.8之后)</h2><p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</p><p>当然这个时候，常量池被从方法区中移出来到了堆中。</p><p>看一个特殊的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str2 &#x3D; new String(&quot;str&quot;)+new String(&quot;01&quot;);</span><br><span class="line">str2.intern();</span><br><span class="line">String str1 &#x3D; &quot;str01&quot;;</span><br><span class="line">System.out.println(str2&#x3D;&#x3D;str1);&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个返回true的原因也一样，str2的时候，只有一个堆的String对象，然后调用intern，常量池中没有“str01”这个常量对象，于是常量池中生成了一个对这个堆中string对象的引用。</p><p>然后给str1赋值的时候，因为是带引号的，所以去常量池中找，发现有这个常量对象，就返回这个常量对象的引用，也就是str2引用所指向的堆中的String对象的地址。</p><p>所以str2和str1指向的是同一个东西，所以为true。</p><p><img src="http://note.youdao.com/yws/public/resource/cf631267d2ad6409b8796f1bae308c36/xmlnote/98CB3B6F74BF45DD83A656A08DF48060/6712"></p><h1 id="11-字符串长度的限制"><a href="#11-字符串长度的限制" class="headerlink" title="11 字符串长度的限制"></a>11 字符串长度的限制</h1><ul><li>编译期</li></ul><ol><li>常量池字面量限制65536</li><li>javac的Gen类中限制不能&gt;=65535</li></ol><p>所以编译期String最长65534</p><ul><li>运行期<br>运行期长度的限制是不能超过Int的范围</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-String-str-“”-和-new-String-区别&quot;&gt;&lt;a href=&quot;#1-String-str-“”-和-new-String-区别&quot; class=&quot;headerlink&quot; title=&quot;1 String str= “” 和 new String(</summary>
      
    
    
    
    <category term="javaSE" scheme="http://example.com/categories/javaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql底层架构</title>
    <link href="http://example.com/2021/02/27/Mysql%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2021/02/27/Mysql%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL架构"><a href="#1-MySQL架构" class="headerlink" title="1 MySQL架构"></a>1 MySQL架构</h1><p><a href="https://www.itzhai.com/articles/insight-into-the-underlying-architecture-of-mysql-buffer-and-disk.html">Mysql底层架构</a></p><p><a href="https://www.jb51.net/article/101062.htm">函数sync、fsync与fdatasync的总结整理</a></p><p><a href="https://www.jianshu.com/p/8991cbca3854">覆盖索引与回表</a></p><p><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">Doublewrite Buffer与redo log</a></p><p><a href="https://www.cnblogs.com/better-farther-world2099/p/9290966.html">InnoDB事务日志（redo log 和 undo log）详解</a></p><ol><li><p>相关概念：</p><ul><li>内存结构： buffer pool、log buffer、change buffer, buffer pool的页淘汰机制是怎样的</li><li>磁盘结构：系统表结构、独立表空间、通用表空间、undo表空间、redo log;</li></ul></li><li><p>为什么MySQL使用B+树？</p><ul><li>哈希表虽然可以提供O(1)的单行数据操作性能，但却不能很好的支持排序和范围查找，会导致全表扫描；</li><li>B树可以再非叶子节点存储数据，但是这可能会导致查询连续数据的时候增加更多的I/O操作；</li><li>而B+树数据都存放在叶子节点，叶子节点通过指针相互连接，可以减少顺序遍历时产生的额外随机I/O</li></ul></li><li><p>为什么使用自增主键</p><ul><li>自增主键的插入是递增顺序插入的，每次添加记录都是追加的，不涉及到记录的挪动，不会触发叶子节点的分裂，而一般业务字段做主键，往往都不是有序插入的，写成本比较高，所以我们更倾向于使用自增字段作为主键。</li></ul></li><li><p>聚集索引</p><ul><li>当在表上面定义了PRIMARY KEY之后，InnoDB会把它作为聚集索引。</li><li>如果您没有为表定义PRIMARY KEY，则MySQL会找到第一个不带null值的UNIQUE索引，并其用作聚集索引；</li><li>如果表没有PRIMARY KEY或没有合适的UNIQUE索引，则InnoDB 内部会生成一个隐藏的聚集索引GEN_CLUST_INDEX，作为行ID，行ID是一个6字节的字段，随着数据的插入而自增。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MySQL架构&quot;&gt;&lt;a href=&quot;#1-MySQL架构&quot; class=&quot;headerlink&quot; title=&quot;1 MySQL架构&quot;&gt;&lt;/a&gt;1 MySQL架构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.itzhai.com/articles/i</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://example.com/2021/02/27/Mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/02/27/Mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><p>Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。</p><p>哈希索引对应哈希表，InnoDB BTree 对应 B+ Tree</p><p><a href="https://www.cnblogs.com/l199616j/p/11232392.html">Mysql索引详解</a></p><h2 id="1-MyISAM-与-InnoDB-Index的区别"><a href="#1-MyISAM-与-InnoDB-Index的区别" class="headerlink" title="1 MyISAM 与 InnoDB Index的区别"></a>1 MyISAM 与 InnoDB Index的区别</h2><ul><li>MyISAMl（非聚集索引）: B+ 树叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li><li>InnoDB(聚集索引), 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></li><li>聚集索引适用的场合：<ul><li>包含大量非重复值的列。</li><li>使用下列运算符返回一个范围值的查询：BETWEEN、&gt;、&gt;=、&lt; 和 &lt;=。</li><li>被连续访问的列。</li><li>返回大型结果集的查询。</li><li>经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。</li><li>OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。</li></ul></li></ul><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/3D230F580DE94664934DB386CE5D48C8/3566" alt="应用场景"></p><p><a href="https://blog.csdn.net/alexdamiao/article/details/51934917">MYSQL索引：对聚簇索引和非聚簇索引的认识</a></p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2 索引"></a>2 索引</h2><ul><li>索引：索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li></ul><h3 id="2-1-索引的优点"><a href="#2-1-索引的优点" class="headerlink" title="2.1 索引的优点"></a>2.1 索引的优点</h3><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><blockquote><p>使用索引的原因：访问磁盘块时，若访问非键字段，需要遍历表空间 On。添加所用可以使用二分查找，降低到logN</p></blockquote><h3 id="2-2-索引的缺点"><a href="#2-2-索引的缺点" class="headerlink" title="2.2 索引的缺点"></a>2.2 索引的缺点</h3><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h3 id="2-3-索引的使用"><a href="#2-3-索引的使用" class="headerlink" title="2.3 索引的使用"></a>2.3 索引的使用</h3><p>添加：</p><ol><li>INDEX indexName (Field_name(length))</li><li>ALTER TABLE table_name ADD INDEX index_name (column_list) (普通索引)</li><li>CREATE INDEX index_name ON table_name (column_list)</li><li>CREATE UNIQUE INDEX index_name ON table_name (column_list) (UNIQUE索引)</li></ol><p>删除：</p><ol><li>DROP INDEX [indexName] ON [table_name];</li><li>alter table [table_name] drop index [index_name] ;</li><li>alter table [table_name] drop primary key ;</li></ol><blockquote><p>如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p></blockquote><p>查看：</p><ol><li>SHOW INDEX FROM [table_name];</li><li>show keys from [table_name];</li></ol><h1 id="2-4-针对存储性质的讲解"><a href="#2-4-针对存储性质的讲解" class="headerlink" title="2.4 针对存储性质的讲解"></a>2.4 针对存储性质的讲解</h1><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2 id="3-索引的数据结构B-Tree和B-Tree"><a href="#3-索引的数据结构B-Tree和B-Tree" class="headerlink" title="3 索引的数据结构B-Tree和B+Tree"></a>3 索引的数据结构B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.</p><h3 id="3-1-B树"><a href="#3-1-B树" class="headerlink" title="3.1 B树"></a>3.1 B树</h3><p>B树也就是二叉搜索树，也有说法是B树与B-树等价</p><p><a href="https://www.jianshu.com/p/1775b4ff123a">B树和B-树的剖析（建树过程）</a></p><h3 id="3-2-B-Tree"><a href="#3-2-B-Tree" class="headerlink" title="3.2 B-Tree"></a>3.2 B-Tree</h3><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/8F052C172C834AFC8BFF711812E724BE/3601" alt="B-树存储"><br><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606" alt="B-树键结构"></p><p>B-树的键区间为开区间，非叶子节点可结束</p><h3 id="3-3-B-Tree-Mysql"><a href="#3-3-B-Tree-Mysql" class="headerlink" title="3.3 B+Tree(Mysql)"></a>3.3 B+Tree(Mysql)</h3><ol><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的K个关键字。</li><li>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/DB87125DAF1E40B8B1FFFDD842163FD3/3597" alt="B+树存储"><br><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606" alt="B+树键结构"></p><h4 id="3-3-1-B-树的搜索方法"><a href="#3-3-1-B-树的搜索方法" class="headerlink" title="3.3.1 B+树的搜索方法"></a>3.3.1 B+树的搜索方法</h4><ul><li>一种是按叶节点自己拉起的链表顺序搜索。</li><li>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</li></ul><h3 id="3-4-B树和B-树的区别"><a href="#3-4-B树和B-树的区别" class="headerlink" title="3.4 B树和B+树的区别"></a>3.4 B树和B+树的区别</h3><ol><li><p>B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。</p><p> 而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。</p></li><li><p>因为B树键位置不定，且在整个树结构中只出现一次。虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。</p></li><li><p>B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</p></li><li><p>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。 </p></li><li><p>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</p></li></ol><h3 id="3-5-B-树的优点和缺点"><a href="#3-5-B-树的优点和缺点" class="headerlink" title="3.5 B+树的优点和缺点"></a>3.5 B+树的优点和缺点</h3><ol><li>优点</li></ol><ul><li>单次请求涉及的磁盘IO次数少（出度d大， 且非叶子节点不包含表数据，树的高度小）</li><li>查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）；</li><li>遍历效率高（从符合条件的某个叶子节点开始遍历即可）；</li></ul><ol start="2"><li>缺点</li></ol><ul><li>主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片；</li><li>即使主键是有序递增的，大量写请求的分布仍是随机的；</li></ul><ol start="3"><li>解释缺点</li></ol><ul><li>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</li><li>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）</li></ul><p>作者：奈文摩尔ST<br>链接：<a href="https://www.jianshu.com/p/06f9f7f41fdb">https://www.jianshu.com/p/06f9f7f41fdb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><blockquote><p>聚簇优点：物理存储的顺序导致磁盘读取的次数减少</p></blockquote><blockquote><p>B/B+优点：相比二叉搜索树，一个盘块存储的key多，一个读取多个key。读取总的盘块次数减少，时间减少。</p></blockquote><h2 id="4-索引分类"><a href="#4-索引分类" class="headerlink" title="4 索引分类"></a>4 索引分类</h2><ol><li>普通索引</li><li>唯一索引：与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：</li><li>全文索引：（FULLTEXT）： <strong>TODO</strong><ul><li>定义：全文检索是对大数据文本进行索引，在建立的索引中对要查找的单词进行进行搜索，定位哪些文本数据包括要搜索的单词。因此，全文检索的全部工作就是建立索引和在索引中搜索定位，所有的工作都是围绕这两个来进行的。<blockquote><p>如果可能，请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。</p></blockquote></li></ul></li><li>多列索引（组合索引：<br> MySQL能在多个列上创建索引。一个索引可以由最多15个列组成。（在CHAR和VARCHAR列上，你也可以使用列的前缀作为一个索引的部分)。<ul><li>一个多重列索引可以认为是包含通过合并(concatenate)索引列值创建的值的一个排序数组。</li><li>多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格（获得结果集记录数最少）的索引。</li><li>在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li></ul></li></ol><blockquote><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引。</p></blockquote><h3 id="4-1-hash索引和B-树索引区别"><a href="#4-1-hash索引和B-树索引区别" class="headerlink" title="4.1 hash索引和B+树索引区别"></a>4.1 hash索引和B+树索引区别</h3><p><a href="https://blog.csdn.net/qq_44590469/article/details/97877397">Hash索引和B+树索引有什么区别或者说优劣势</a></p><h3 id="4-2-最左匹配原则（针对联合索引）"><a href="#4-2-最左匹配原则（针对联合索引）" class="headerlink" title="4.2 最左匹配原则（针对联合索引）"></a>4.2 最左匹配原则（针对联合索引）</h3><p><a href="https://blog.csdn.net/sinat_41917109/article/details/88944290">讲得不错的最左匹配原则</a></p><h2 id="4-3-索引建立的注意事项"><a href="#4-3-索引建立的注意事项" class="headerlink" title="4.3 索引建立的注意事项"></a>4.3 索引建立的注意事项</h2><ol><li>最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</li><li>尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。</li><li>索引列不能参与计算，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = ‘2016-06-06’ 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP(‘2016-06-06’)。</li><li>尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</li><li>单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。</li></ol><p><a href="https://blog.csdn.net/ss123mlk/article/details/106902596">sql优化：explain关键字</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql索引&quot;&gt;&lt;a href=&quot;#Mysql索引&quot; class=&quot;headerlink&quot; title=&quot;Mysql索引&quot;&gt;&lt;/a&gt;Mysql索引&lt;/h1&gt;&lt;p&gt;Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。&lt;/p&gt;
&lt;p&gt;哈希索引对应哈希表，</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql难点语法</title>
    <link href="http://example.com/2021/02/27/Mysql%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2021/02/27/Mysql%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql难点语法"><a href="#Mysql难点语法" class="headerlink" title="Mysql难点语法"></a>Mysql难点语法</h1><h2 id="1-group-by"><a href="#1-group-by" class="headerlink" title="1 group by"></a>1 group by</h2><p>group by 要与having共用， 不能与where，因为where中不能有聚集函数做为条件表达式</p><p>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数</p><h2 id="2-数据库中的union与union-all的区别"><a href="#2-数据库中的union与union-all的区别" class="headerlink" title="2 数据库中的union与union all的区别"></a>2 数据库中的union与union all的区别</h2><p>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All</p><p> 两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</p><p> union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 </p><p> Union All：对两个结果集进行并集操作，包括重复行，不进行排序； </p><h2 id="3-连表查询比子查询快"><a href="#3-连表查询比子查询快" class="headerlink" title="3 连表查询比子查询快"></a>3 连表查询比子查询快</h2><h2 id="4-按某一属性排序并生成行号序列"><a href="#4-按某一属性排序并生成行号序列" class="headerlink" title="4 按某一属性排序并生成行号序列"></a>4 按某一属性排序并生成行号序列</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row_number() over(partition by customer_id </span><br><span class="line">order by order_date desc)</span><br></pre></td></tr></table></figure><h2 id="5-using连接查询"><a href="#5-using连接查询" class="headerlink" title="5 using连接查询"></a>5 using连接查询</h2><p> sql/92标准可以使用using关键字来简化连接查询，但是只是在查询满足下面两个条件时，才能使</p><p>用using关键字进行简化。</p><ul><li>1.查询必须是等值连接。</li><li>2.等值连接中的列必须具有相同的名称和数据类型。</li></ul><h2 id="6-case-when"><a href="#6-case-when" class="headerlink" title="6 case when"></a>6 case when</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">    when ...</span><br><span class="line">    whem ...</span><br><span class="line">    else ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql难点语法&quot;&gt;&lt;a href=&quot;#Mysql难点语法&quot; class=&quot;headerlink&quot; title=&quot;Mysql难点语法&quot;&gt;&lt;/a&gt;Mysql难点语法&lt;/h1&gt;&lt;h2 id=&quot;1-group-by&quot;&gt;&lt;a href=&quot;#1-group-by&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://example.com/2021/02/27/RabbitMQ/"/>
    <id>http://example.com/2021/02/27/RabbitMQ/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MQ的三个作用"><a href="#1-MQ的三个作用" class="headerlink" title="1 MQ的三个作用"></a>1 MQ的三个作用</h1><ol><li>异步</li><li>解耦，消息统一分发</li><li>流量削峰</li></ol><h1 id="2-AMQP事物机制控制"><a href="#2-AMQP事物机制控制" class="headerlink" title="2 AMQP事物机制控制"></a>2 AMQP事物机制控制</h1><ol><li>txSelect, txCommit, txRollback</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MQ的三个作用&quot;&gt;&lt;a href=&quot;#1-MQ的三个作用&quot; class=&quot;headerlink&quot; title=&quot;1 MQ的三个作用&quot;&gt;&lt;/a&gt;1 MQ的三个作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;解耦，消息统一分发&lt;/li&gt;
&lt;li&gt;流量削峰&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="http://example.com/2021/02/27/dubbo/"/>
    <id>http://example.com/2021/02/27/dubbo/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo是一款高性能的Java RPC框架</p><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=72">ZooKeeper+Dubbo分布式架构基础教程</a></p><ol><li>面向接口的的远程方法调用，智能容错和负载均衡，服务自动注册和发现<h1 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1 RPC"></a>1 RPC</h1></li></ol><ul><li>A服务器的方法调用B服务器的方法，不在同一个内存空间。<ol><li>客户端调用</li><li>序列化</li><li>发送消息</li><li>发序列化</li><li>调用本地服务</li><li>服务处理</li><li>返回结果</li><li>将结果序列化</li><li>返回消息</li><li>反序列化</li><li>返回调用结果<h1 id="2-RMI"><a href="#2-RMI" class="headerlink" title="2 RMI"></a>2 RMI</h1></li></ol></li><li>java原生支持的远程调用，采用JRMP作为通信协议</li><li>client、server、registy注册中心</li></ul><ol><li>大致原理：服务端在注册中心注册服务，客户端从注册中心获取服务具体信息，客户端调用服务端执行服务。</li><li>步骤<ol><li>创建远程接口，继承Remote</li><li>实现远程接口，并且继承UnicastRemoteObject</li><li>启动RMI注册服务，指定端口号</li><li>创建要被访问的远程对象的实例</li><li>把远程对象实例注册到RMI注册服务器上</li></ol></li></ol><h1 id="3-dubbo高可用"><a href="#3-dubbo高可用" class="headerlink" title="3 dubbo高可用"></a>3 dubbo高可用</h1><ol><li>服务路由（包含一条路由规则）<ul><li>dubbo提供了三种服务路由实现（条件路由ConditionRouter、脚本路由ScriptRouter、标签路由TagRouter）</li></ul></li><li>条件路由规则的格式：<ul><li>服务消费者匹配条件 =&gt; 服务提供者匹配条件</li><li>host = 10.20.153.10 =&gt; host = 10.20.153.11</li><li>该条规则表示IP为10.20.153.10的服务消费者止咳调用IP为10.20.153.11机器上的服务，不可调用其他机器上的服务。</li><li>如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。</li><li>包括黑名单、白名单、读写分离、前后天分离</li></ul></li><li>集群容错<ul><li>FailoverCluster,某个服务器产生异常，重试其他服务器，可以设置重试次数。</li><li>Failfast Cluter快速失败，只调用一次，立即报错。通常用于非幂等性的写操作</li></ul></li><li>负载均衡（面试题）<ul><li>随机权重分配，无状态</li><li>轮训服务器，有状态</li><li>活跃计数器随机</li><li>一致性哈希，为IP分配固定的服务器</li></ul></li><li>dubbo降级服务<ul><li>服务降级就是指在由于非主业务异常导致的服务不可用时（服务器宕机/网络超时/并发数太高等），可以返回默认值，避免异常影响主业务的处理</li></ul></li></ol><blockquote><p>zookeeper 和 redis 用于消息中心的很重要的原因是知道断开</p></blockquote><p>Dubbo SPI流程：名字–&gt;文件–&gt;实现类–&gt;对象–&gt;依赖注入–&gt;AOP–&gt;完整的一个对象</p><blockquote><p>Dubbo的依赖注入与spring的区别，注入的是一个属性的代理对象，根据实际要用时传入的url中的实际对象赋真正的值，也就是set的时候并没有确定最终的对象。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dubbo是一款高性能的Java RPC框架&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BA411q7ia?p=72&quot;&gt;ZooKeeper+Dubbo分布式架构基础教程&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向接口的的</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql初学笔记</title>
    <link href="http://example.com/2021/02/27/mysql%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/27/mysql%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql笔记-（关系型数据库）"><a href="#mysql笔记-（关系型数据库）" class="headerlink" title="mysql笔记 （关系型数据库）"></a>mysql笔记 （关系型数据库）</h1><h2 id="一-使用终端操纵数据库"><a href="#一-使用终端操纵数据库" class="headerlink" title="一 使用终端操纵数据库"></a>一 使用终端操纵数据库</h2><h3 id="1-登录数据库"><a href="#1-登录数据库" class="headerlink" title="1. 登录数据库"></a>1. 登录数据库</h3><p>mysql -uroot -p</p><h3 id="2-查询所有数据库"><a href="#2-查询所有数据库" class="headerlink" title="2. 查询所有数据库"></a>2. 查询所有数据库</h3><p>show database;</p><h3 id="3-选中某一数据库操作"><a href="#3-选中某一数据库操作" class="headerlink" title="3. 选中某一数据库操作"></a>3. 选中某一数据库操作</h3><p>use database;</p><h3 id="4-查询"><a href="#4-查询" class="headerlink" title="4.查询"></a>4.查询</h3><p>select * from admin where admin_Id = 1</p><h3 id="5-退出"><a href="#5-退出" class="headerlink" title="5.退出"></a>5.退出</h3><p>exit;或quit;</p><h3 id="6-创建数据库"><a href="#6-创建数据库" class="headerlink" title="6.创建数据库"></a>6.创建数据库</h3><p>create database name;</p><h3 id="7-查看数据库中的数据表"><a href="#7-查看数据库中的数据表" class="headerlink" title="7.查看数据库中的数据表"></a>7.查看数据库中的数据表</h3><p>show tables;</p><h3 id="8-创建数据表"><a href="#8-创建数据表" class="headerlink" title="8.创建数据表"></a>8.创建数据表</h3><p>创建宠物数据表</p><pre><code>CREATE TABLE pet (name VARCHAR(20),owner VARCHAR(20),sex CHAR(1),birth DATE);</code></pre><h3 id="9-查看创建好的数据表"><a href="#9-查看创建好的数据表" class="headerlink" title="9. 查看创建好的数据表"></a>9. 查看创建好的数据表</h3><p>decribe pet;</p><h3 id="10-查看表中记录"><a href="#10-查看表中记录" class="headerlink" title="10 查看表中记录"></a>10 查看表中记录</h3><p>select * from pet;</p><h3 id="11-插入记录"><a href="#11-插入记录" class="headerlink" title="11.插入记录"></a>11.插入记录</h3><pre><code>INSERT INFO petVALUES (&#39;pp&#39;,&#39;mm&#39;,&#39;f&#39;,&#39;1999-03-26&#39;);</code></pre><h3 id="12-mysql-常用数据类型"><a href="#12-mysql-常用数据类型" class="headerlink" title="12.mysql 常用数据类型"></a>12.mysql 常用数据类型</h3><p>数值<br>类型|大小|范围（有符号|范围(无符号)|用途<br>-|:-:|:-:|:-:|:-:|-</p><p>日期/时间</p><p>字符串</p><p>数据类型选择 日期按照格式 数值和字符串按照大小</p><h3 id="13-删除数据"><a href="#13-删除数据" class="headerlink" title="13. 删除数据"></a>13. 删除数据</h3><p>delete from pet where name =’pp’;</p><h3 id="14-修改数据"><a href="#14-修改数据" class="headerlink" title="14.修改数据"></a>14.修改数据</h3><p>update pet set name=’旺财’ where owner = ‘mm’;</p><h3 id="15-mysql建表约束条件"><a href="#15-mysql建表约束条件" class="headerlink" title="15.mysql建表约束条件"></a>15.mysql建表约束条件</h3><p>1.主键约束</p><pre><code>id int(11) primary key</code></pre><p>它能够唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束就可以使该字段不重复且不为空。</p><p>可以有多个主键，主键联合约束。只要联合的主键值加起来不同即可。但联合主键每一个都不能为空。</p><ol start="2"><li><p>自增约束</p><p> primary key auto_increment<br>与主键约束搭配起来进行自增</p></li></ol><p>忘记添加主键，创建后添加</p><pre><code>alter table user4 add primary key(id);</code></pre><p>输出表结构主键</p><pre><code>alter table user4 drop primary key;</code></pre><p>修改字段主键约束</p><pre><code>alter table user4 modify id int primary key;</code></pre><ol start="3"><li>外键约束</li></ol><p><a href="https://blog.csdn.net/wdd199801140310/article/details/102984378">有主从表|主外键关系时删除表和删除数据</a></p><p>涉及到两个表，一个是主表，一个是副标，或父表，子表，外键设置在副表上</p><pre><code>create table classes(    id int primary key,    name varchar(20));create table students(    id int primary key,    name varchar(20),    class_id int,    foreign key(class_id) references classes(id));</code></pre><p>副表中的外键值要参照主表， 1.主表中没有的数据值，副表不能使用。2.被副表引用的主表值不允许被删除。</p><ol start="4"><li>唯一约束</li></ol><p>约束修饰的字段的值不可以重复</p><pre><code>name carchar(20) uniquealter table user add unique(name); </code></pre><p>可以unique(name, id)<br>这两个件在一起不重复就可以。</p><p>删除唯一约束</p><pre><code>alter table user drop index name</code></pre><p>modify 添加</p><pre><code>alter table user modify name varchar(20 unique);</code></pre><ol start="5"><li>非空约束</li></ol><p>修饰的字段不能为空</p><pre><code>create table user (    id int,    name varchar(20) not null);</code></pre><p>单独插入会报错</p><pre><code>insert into user (name) values &#39;list&#39;;</code></pre><ol start="6"><li>默认约束</li></ol><p>插入字段时，如果没有传值，使用默认值</p><pre><code>age int default 20</code></pre><h3 id="16-数据库设计三大设计范式"><a href="#16-数据库设计三大设计范式" class="headerlink" title="16.数据库设计三大设计范式"></a>16.数据库设计三大设计范式</h3><p>1.第一范式 1NF</p><p>数据表中的所有字段都是不可分割的原子值</p><pre><code>create table user (    id int primary key,    name varchar(20),    address varchar(30));</code></pre><p>字段值还可以继续拆分， 就不满足第一范式, 上表不满足第一范式</p><pre><code>create table user (    id int primary key,    name varchar(20),    cuntry varchar(30),    province varchar(30),    city varchar(30));</code></pre><p>上表拆分比较详细，满足第一范式。</p><p>范式设计一般来说越详细越好，但还是要根据具体工程。</p><ol start="2"><li>第二范式</li></ol><p>必须是满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖主键</p><p>如果出现不完全依赖，只可能发生在联合主键的情况下。某字段只依赖其中一个主键。</p><p>如果实在要这样，设计成外键关联，拆分表。</p><p>3.第三范式 3NF</p><p>必须先满足第二范式，除开主键列的其他列之间不能有传递依赖。不能有冗余依赖。需要拆分。</p><h3 id="17-查询联系"><a href="#17-查询联系" class="headerlink" title="17.查询联系"></a>17.查询联系</h3><p>学生表<br>Student<br>学号<br>姓名<br>性别<br>出生年月日<br>所在班级</p><pre><code>create table student &#123;    sno varchar(20) primary key,    sname varcher(20) not null,    ssex varchar(10) not null,    sbirthday datatime,    class varchar(20)&#125;</code></pre><p>成绩表<br>Score<br>学号<br>课程号<br>成绩</p><pre><code>create table score(    sno varchar(20) not null,    cno varchar(20) not null,    degree decimal,    foreign key(sno) references student(sno),    foreign key(cno) references course(cno),    primary key(sno, cno));</code></pre><p>查询所有记录 select * from student;</p><p>查询指定记录，（某些字段）， select sname, ssex, class from student;</p><p>查询不重复的depart列<br>select distinct depart from teacher;</p><p>查询区间<br>select * from score where degree between 60 and 80;<br>或者运算符比较<br>select * from score where degree &gt; 60 and degree &lt; 80;</p><p>查询或关系<br>select * from score where degree in (85, 86, 88);</p><p>查询表中性别为女的同学记录<br>select * from student where class=’95031’ or ssex=’女’;</p><p>以class降序查询<br>select * from student order by class desc;<br>默认升序或者arc</p><p>以cno升序，degree 降序查询所有记录<br>select * from score order by cno asc, degree desc;</p><p>查询总人数 count<br>select count(*) from student where class=’95031’;</p><p>查询最高分<br>select sno,cno from score where degree=(selectmax(degree) from score);</p><p>查询每门课的平均成绩</p><p>select avg(degree) from score where cno=’3-105’</p><p>select cno,avg(degree) from score group by cno;</p><p>查询score表中至少有两名学生选修的并以3开头的课程</p><p>select cno, avg(degree),count(*)) from score group by  cno having count(cno)&gt;=2 and cno like ‘3%’;</p><p>查询分数大于70小于90的sno列</p><p>select sno,degree from score where degree&gt;70 and degree &lt; 90;<br>或者用between and</p><p>多表查询</p><p>查询所有学生的sname, cno和degree</p><p>select sname,con,degree from student,score where student.sno=score.sno;</p><p>三表关联查询(重点)<br>通过字段相等联查</p><p>select sname,cname,degree from student,course,score where student.sno=score.sno and course.cno=score.cno;</p><p>查询’95031’班学生每门课的平均分</p><p>select cno,avg(degree) from score where sno in (select sno from student where class=’95031’) group by cno;</p><ol start="18"><li>查询”3-105”课程的成绩高于”109”号同学 “3-105”成绩的所有同学的记录。</li></ol><p>select * from score where cno= ‘3-105’ and degree &gt; (select degree from score where sno=’109’ and cno=’3-105’);</p><p>查询和学号为108、101的同学同年出生的所有学生的sno\sname和sbirthday列</p><p>select * from student where year(sbirthday) in (select year(sbirthday) from student where sno in (108, 101));</p><p>查询 “张旭” 教师任课的学生成绩</p><p>select * from score where cno =(select cno from course where tno= (select * from teacger where tname= ‘张旭’));</p><p>查询选修某课程的同学人数多于5人的教师姓名。</p><p>select tname from teacher where tno = (select tno from course where cno = (select cno from score groupby cno having count(*) &gt; 5;));</p><p>查询95033班和95031班全体学生的记录。</p><p>select * from student where class in (‘95031’, ‘95033’);</p><p>查询存在成绩在85分以上的课程的cno</p><p>select * from score where degree&gt;85;</p><p>查询出 “计算机系” 教师所有课程的成绩表</p><p>select * from score where cno in (select cno from course where tno in (select tno from teacher where depart= ‘计算机系’;));</p><p>查询 “计算机系” 与 “电子工程系”不同职称的教师的tnam和prof</p><p>union 求并集</p><p>select * from teacher where depart = ‘计算机系’ and prof not in (select prof from teacher where depart = ‘电子工程系’)<br>union<br>select * from teacher where depart = ‘电子工程系’ and prof not in (select prof from teacher where depart = ‘计算机系’)</p><p>查询选修编号为 “3-105”课程且成绩至少高于选修课程 “3-245”的同学的cno,sno和degree,并且按degree从高到低排序</p><p>select * from score where cno = ‘3-105’ and degree &gt; any(select degree from score where cno = ‘3-245’) order by degree desc;</p><p>查询选修编号为 “3-105”<br>且成绩高于选修编号为 “3-245” 的同学的 cnp\sno 和 degree</p><p>select * from score where cno= ‘3-105’ and degree&gt;all(select degree from score where cno=’3-245’);</p><p>查询所有教师和同学的name,sex和birthday</p><p>select tname as name,tsex as sex,tbirthday as birthday from teacher<br>union<br>select sname,ssex,sbirthday from student</p><p>查询成绩比该课程平均成绩低的同学的成绩表</p><p>select * from score a where degree &lt; (select avg(degree) from score b where a.cno=b.cno);</p><p>查询至少有两名男生的班号</p><p>select class from student where ssex= ‘男’ group by class having count(*)&gt;1;</p><p>查询student 表中最大值和最小sbirthday日期值</p><p>select max(sbirthday) as ‘最大’，min(sbirthday) as ‘最小’ from student;</p><h3 id="18-SQL的四中连接查询"><a href="#18-SQL的四中连接查询" class="headerlink" title="18 SQL的四中连接查询"></a>18 SQL的四中连接查询</h3><p>内连接<br>inner join 或者 join</p><p>外连接<br>1.左连接 left join 或者 left outer join</p><p>2.右连接 right join 或 outer join</p><p>3.完全外连接 full join 或者 full outer join</p><pre><code>create table person(    id int,    name varchar(20),    cardId int);create table card(    id int,    name varchar(20),);</code></pre><p>insert into person values();</p><p>inner join查询<br>select * from person inner join card on person.cardId = card.id;</p><p>内联查询，就是两章表中的数据，通过某个字段相对，查询出相关记录数据。</p><p>left join（左外连接）</p><p>select * from person left join card on person.cardId=card.id;</p><p>左外连接吧左边表里的所有数据取出来，右边表有相等显示出来，没有就会补null</p><p>right join（右外连接）</p><p>select * from person right (outer) join card on person.cardId=card.id;</p><p>同左外连接，左右互换</p><p>full join(全外链接)</p><p>select * from person full join card on person.cardId=card.id;</p><p>mysql不支持full join<br>求出两边表的并集</p><p>mysql通过union实现</p><p>select * from person left join card on person.cardId=card.id<br>union<br>select * from person right join card on person.cardId=card.id;</p><h3 id="20-mysql-事务"><a href="#20-mysql-事务" class="headerlink" title="20.mysql 事务"></a>20.mysql 事务</h3><p>mysql中，事务湿气重一个最小的不可分割的单元，事务能够保证一个业务的完整性。</p><p>多条mysql同时成功或者同时失败的要求。</p><p>mysql是默认开起事务的</p><p>默认事务开启的作用</p><p>当我们去执行一个sql语句时，效果立刻体现，不会回滚。</p><p>回滚是rollback；</p><p>设置自动提交为false<br>set autocommit=0;</p><p>begin或者start transaction 开启一个事务，之后可以回滚<br>直到commit</p><p>事务的四大特征</p><p>A.原子性：事务是最小单位，不可以分割</p><p>C.一致性：事务要求，同一事物中的sql语句必须同时成功或失败</p><p>I。隔离性：事务1和事务2之间具有隔离性。</p><p>D.持久性：事物一旦结束（commit,rollback），就不可以返回。</p><p>事务开启</p><p>1.修改默认提交 set autocommit=0;</p><p>2.begin</p><p>3.start transaction</p><p>事务的隔离性</p><p>1.read uncommited (读未提交)</p><p>事务对数据进行操作，在操作过程中，事务没有被提交，但是b可以看见a操作的结果。</p><p>查看隔离级别mysql8.0</p><p>系统级别</p><p>select @@global.transaction_isolation;</p><p>会话级别</p><p>select @@transaction_isolation</p><p>设置</p><p>set global transaction isolation level read uncommited;</p><p>这种读未提交的叫做脏读</p><p>2.read commited<br>(读已经提交)</p><p>3.repeatable read<br>(可以重复读)</p><p>4.serializable<br>(串行化)</p><h2 id="二-使用可视化工具操纵数据库"><a href="#二-使用可视化工具操纵数据库" class="headerlink" title="二 使用可视化工具操纵数据库"></a>二 使用可视化工具操纵数据库</h2><h2 id="三-在编程语言中使用数据库"><a href="#三-在编程语言中使用数据库" class="headerlink" title="三 在编程语言中使用数据库"></a>三 在编程语言中使用数据库</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql笔记-（关系型数据库）&quot;&gt;&lt;a href=&quot;#mysql笔记-（关系型数据库）&quot; class=&quot;headerlink&quot; title=&quot;mysql笔记 （关系型数据库）&quot;&gt;&lt;/a&gt;mysql笔记 （关系型数据库）&lt;/h1&gt;&lt;h2 id=&quot;一-使用终端操纵数</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="http://example.com/2021/02/27/java/Map/"/>
    <id>http://example.com/2021/02/27/java/Map/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HashMap和HashTable不同点"><a href="#1-HashMap和HashTable不同点" class="headerlink" title="1 HashMap和HashTable不同点"></a>1 HashMap和HashTable不同点</h1><ol><li>HashTable继承于Dictionary类，HashMap继承于AbstractMap。AbstractMap中提供的基础方法更多，并且实现了多个通用的方法，而在Dictionary中只有少量的接口，并且都是abstract类型。</li><li>HashMap可以允许存在一个为null的key和任意个为null的value,但是Hashtable中的key和value都不允许为null。当HashMap遇到为null的key时，会调用putForNullKey方法进行处理，对value没有处理，只要是对象就可以。而HashTable遇到null时，会直接抛出NullPointerException异常信息。</li><li>Hashtable是同步的， HashMap不是，Collections类中存在一个静态方法：synchronizedMap()，该方法也是一个线程安全的Map对象。HashMap内部没有实现任何线程同步的代码，性能相对要好，HashTable大部分对外的接口都使用synchronized包裹，所以是线程安全的，但是性能会差。</li><li>算法不一样，HashMap的initialCapacity为16，而Hashtable的initialCapacity为11。HashMap中的初始容量必须是2的幂，如果初始化传入的initialCapacity不是2的幂，会自动调整为大于初始的initialCapacity最小的2的幂。HashMap使用自己的计算hash的方法（会依赖key的hashCode方法），HashTable则直接使用key的hashCode方法得到。</li></ol><h1 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2 LinkedHashMap"></a>2 LinkedHashMap</h1><ul><li>LinkedHashMap可以看做是HashMap和双向链表合二为一。LinkedHashMap是HashMap的子类，拥有HashMap所有特性。LinkedHashMap支持LRU算法。</li><li>HashMap内部是无序的，LinkedHashMap通过维护内部的双向链表保证了迭代顺序。<br><img src="http://note.youdao.com/yws/public/resource/6d570a4731e802c585e8b26b774f0e30/xmlnote/6470514937724277985DCD01037CCE04/12780"></li></ul><ol><li>成员变量</li></ol><ul><li>与HashMap相比，linkedHashMap增加了两个属性用于保证迭代顺序，分别是双向链表头结点header和标志位accessOrder（值为true时，表示按照访问顺序迭代，值为false时，表示按照插入顺序迭代）</li></ul><ol start="2"><li>LinkedHashMap没有增加额外的方法，重写了部分方法。<br><img src="http://note.youdao.com/yws/public/resource/6d570a4731e802c585e8b26b774f0e30/xmlnote/41963E5194674F00A49B1DEFB90DA22E/12798"></li><li>Entry<br><img src="http://note.youdao.com/yws/public/resource/6d570a4731e802c585e8b26b774f0e30/xmlnote/C8685352761E46DAA3D51F769645CA90/12783"></li><li>put<br><br>LinkedHashMap完全继承了HashMap的put方法，只是对put方法所调用的recordAccess方法和addEntry方法进行了重写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当key为null时，调用putForNullKey方法，并将该键值对保存到table的第一个位置 </span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value); </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据key的hashCode计算hash值</span><br><span class="line">    int hash &#x3D; hash(key.hashCode());           </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算该键值对在数组中的存储位置（哪个桶）</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length);              </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在table的第i个桶上进行迭代，寻找 key 保存的位置</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;      </span><br><span class="line">        Object k;</span><br><span class="line">        &#x2F;&#x2F;判断该条链上是否存在hash值相同且key值相等的映射，若存在，则直接覆盖 value，并返回旧value</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this); &#x2F;&#x2F; LinkedHashMap重写了Entry中的recordAccess方法--- (1)    </span><br><span class="line">            return oldValue;    &#x2F;&#x2F; 返回旧值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++; &#x2F;&#x2F;修改次数增加1，快速失败机制</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;原Map中无该映射，将该添加至该链的链头</span><br><span class="line">    addEntry(hash, key, value, i);  &#x2F;&#x2F; LinkedHashMap重写了HashMap中的createEntry方法 ---- (2)    </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>addEntry方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This override alters behavior of superclass put method. It causes newly</span><br><span class="line"> * allocated entry to get inserted at the end of the linked list and</span><br><span class="line"> * removes the eldest entry if appropriate.</span><br><span class="line"> *</span><br><span class="line"> * LinkedHashMap中的addEntry方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建新的Entry，并插入到LinkedHashMap中  </span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  &#x2F;&#x2F; 重写了HashMap中的createEntry方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;双向链表的第一个有效节点（header后的那个节点）为最近最少使用的节点，这是用来支持LRU算法的</span><br><span class="line">    Entry&lt;K,V&gt; eldest &#x3D; header.after;  </span><br><span class="line">    &#x2F;&#x2F;如果有必要，则删除掉该近期最少使用的节点，  </span><br><span class="line">    &#x2F;&#x2F;这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  </span><br><span class="line">    if (removeEldestEntry(eldest)) &#123;  </span><br><span class="line">        removeEntryForKey(eldest.key);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        &#x2F;&#x2F;扩容到原来的2倍  </span><br><span class="line">        if (size &gt;&#x3D; threshold)  </span><br><span class="line">            resize(2 * table.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">-------------------------------我是分割线------------------------------------</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="line"> * the specified bucket.  It is the responsibility of this</span><br><span class="line"> * method to resize the table if appropriate.</span><br><span class="line"> *</span><br><span class="line"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="line"> * </span><br><span class="line"> * HashMap中的addEntry方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取bucketIndex处的Entry</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry </span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;若HashMap中元素的个数超过极限了，则容量扩大两倍</span><br><span class="line">    if (size++ &gt;&#x3D; threshold)</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>createEntry<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123; </span><br><span class="line">    &#x2F;&#x2F; 向哈希表中插入Entry，这点与HashMap中相同 </span><br><span class="line">    &#x2F;&#x2F;创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old &#x3D; table[bucketIndex];  </span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; new Entry&lt;K,V&gt;(hash, key, value, old);  </span><br><span class="line">    table[bucketIndex] &#x3D; e;     </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span><br><span class="line">    &#x2F;&#x2F;这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)</span><br><span class="line">    &#x2F;&#x2F;同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span><br><span class="line">    e.addBefore(header);  </span><br><span class="line">    size++;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>resize<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这一块是处理原来的HashMap冲突的，因为容量扩容了</span><br><span class="line">原来通过 &amp; 运算出来的hash冲突的key,与新的容量 &amp; 可能位置会发生改变</span><br><span class="line">比如之前的冲突的两个key （k1,k2）的hash 分别为 1101，11101</span><br><span class="line">初始化默认的容量是16 二进制就是 10000， 16-1的二进制就是 1111 与key进行&amp; 运算结果都是 1101，但是与11111(36-1)进行 一个是1101 另一是11101</span><br><span class="line">所以需要重新计算下标，通过与oldCap 进行 &amp; 运算 分为低位和高位，因为和oldCap &amp;运算只有两种结果，一种是0 另一种是oldCap</span><br><span class="line">将结果&#x3D;0的设置成低位，将等于oldCap的保存到高位，</span><br><span class="line">低位的hash值肯定小于oldCap，所以下标还是在原来的位置</span><br><span class="line">高位的hash一定大于oldCap，在二进制最左至少会多一个1（有可能还有前面还有其他二进制数字，但运算结果都是一样的）计算正好是原来位置加上新的容量</span><br></pre></td></tr></table></figure></li></ol><ul><li>LinkedHashMap完全继承了HashMap的resize()方法，只是对它所调用的transfer方法进行了重写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 若 oldCapacity 已达到最大值，直接将 threshold 设为 Integer.MAX_VALUE</span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;             &#x2F;&#x2F; 直接返回</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 否则，创建一个更大的数组</span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将每条Entry重新哈希到新的数组中</span><br><span class="line">    transfer(newTable);  &#x2F;&#x2F;LinkedHashMap对它所调用的transfer方法进行了重写</span><br><span class="line"></span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">    threshold &#x3D; (int)(newCapacity * loadFactor);  &#x2F;&#x2F; 重新设定 threshold</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Map扩容操作的核心在于重哈希。所谓重哈希是指重新计算原HashMap中的元素在新table数组中的位置并进行行复制处理的过程。鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对重哈希过程(transfer方法)进行了重写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Transfers all entries to new table array.  This method is called</span><br><span class="line"> * by superclass resize.  It is overridden for performance, as it is</span><br><span class="line"> * faster to iterate using our linked list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void transfer(HashMap.Entry[] newTable) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    &#x2F;&#x2F; 与HashMap相比，借助于双向链表的特点进行重哈希使得代码更加简洁</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; header.after; e !&#x3D; header; e &#x3D; e.after) &#123;</span><br><span class="line">        int index &#x3D; indexFor(e.hash, newCapacity);   &#x2F;&#x2F; 计算每个Entry所在的桶</span><br><span class="line">        &#x2F;&#x2F; 将其链入桶中的链表</span><br><span class="line">        e.next &#x3D; newTable[index];</span><br><span class="line">        newTable[index] &#x3D; e;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从上述源码可知，LinkedHashMap借助于自身维护的双向链表轻松实现了重哈希操作。</li></ul><ol start="6"><li>get对比<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据key获取对应的Entry，若没有这样的Entry，则返回null</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;)getEntry(key); </span><br><span class="line">    if (e &#x3D;&#x3D; null)      &#x2F;&#x2F; 若不存在这样的Entry，直接返回</span><br><span class="line">        return null;</span><br><span class="line">    e.recordAccess(this);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * Returns the entry associated with the specified key in the</span><br><span class="line">     * HashMap.  Returns null if the HashMap contains no mapping</span><br><span class="line">     * for the key.</span><br><span class="line">     * </span><br><span class="line">     * HashMap 中的方法</span><br><span class="line">     *     </span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">             e !&#x3D; null;</span><br><span class="line">             e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>总结</li></ol><ul><li>LinkedHashMap相对于HashMap只是要额外维护一个双向链表用于保持迭代顺序。</li><li>put操作上，虽然LinkedHashMap完全继承了HashMap的put操作，还增加了其他，比如在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。</li></ul><h1 id="3-LinkedHashMap与LRU（Least-recently-used，-最近最少使用）算法"><a href="#3-LinkedHashMap与LRU（Least-recently-used，-最近最少使用）算法" class="headerlink" title="3 LinkedHashMap与LRU（Least recently used， 最近最少使用）算法"></a>3 LinkedHashMap与LRU（Least recently used， 最近最少使用）算法</h1><ol><li>LinkedHashMap通过双向链表头结点header和标志位accessOrder来保证迭代顺序。</li></ol><ul><li>当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列，具体是将当前访问的Entry(put进来的Entry或get出来的Entry)移到双向链表的尾部，这样会使得链表既符合插入顺序，又符合访问的先后顺序，因为这时该Entry也被访问了。</li><li>当标志位accessOrder的值为false时，表示双向链表中的元素按照Rntry插入LinkedHashMap中的先后顺序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序。</li><li>当标志位accessOrder的值为false时，虽然也会调用recordAccess方法，但不做任何操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* This method is invoked by the superclass whenever the value</span><br><span class="line">* of a pre-existing entry is read by Map.get or modified by Map.set.</span><br><span class="line">* If the enclosing Map is access-ordered, it moves the entry</span><br><span class="line">* to the end of the list; otherwise, it does nothing.</span><br><span class="line">*&#x2F;</span><br><span class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;  </span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm &#x3D; (LinkedHashMap&lt;K,V&gt;)m;  </span><br><span class="line">    &#x2F;&#x2F;如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，  </span><br><span class="line">    &#x2F;&#x2F;如果是按照插入的先后顺序排序，则不做任何事情。  </span><br><span class="line">    if (lm.accessOrder) &#123;  </span><br><span class="line">        lm.modCount++;  </span><br><span class="line">        &#x2F;&#x2F;移除当前访问的Entry  </span><br><span class="line">        remove();  </span><br><span class="line">        &#x2F;&#x2F;将当前访问的Entry插入到链表的尾部  </span><br><span class="line">        addBefore(lm.header);  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>再结合创建节点，就很清晰了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F;创建新的Entry，并插入到LinkedHashMap中  </span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  &#x2F;&#x2F; 重写了HashMap中的createEntry方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;双向链表的第一个有效节点（header后的那个节点）为最近最少使用的节点，这是用来支持LRU算法的</span><br><span class="line">    Entry&lt;K,V&gt; eldest &#x3D; header.after;  </span><br><span class="line">    &#x2F;&#x2F;如果有必要，则删除掉该近期最少使用的节点，  </span><br><span class="line">    &#x2F;&#x2F;这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  </span><br><span class="line">    if (removeEldestEntry(eldest)) &#123;  </span><br><span class="line">        removeEntryForKey(eldest.key);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        &#x2F;&#x2F;扩容到原来的2倍  </span><br><span class="line">        if (size &gt;&#x3D; threshold)  </span><br><span class="line">            resize(2 * table.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123; </span><br><span class="line">    &#x2F;&#x2F; 向哈希表中插入Entry，这点与HashMap中相同 </span><br><span class="line">    &#x2F;&#x2F;创建新的Entry并将其链入到数组对应桶的链表的头结点处， </span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old &#x3D; table[bucketIndex];  </span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; new Entry&lt;K,V&gt;(hash, key, value, old);  </span><br><span class="line">    table[bucketIndex] &#x3D; e;     </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在每次向哈希表插入Entry的同时，都会将其插入到双向链表的尾部，  </span><br><span class="line">    &#x2F;&#x2F;这样就按照Entry插入LinkedHashMap的先后顺序来迭代元素(LinkedHashMap根据双向链表重写了迭代器)</span><br><span class="line">    &#x2F;&#x2F;同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，也符合LRU算法的实现  </span><br><span class="line">    e.addBefore(header);  </span><br><span class="line">    size++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>总结来说，使用LinkedHashMap实现LRU的必要前提是将accessOrder标志位设为true以便开启按访问顺序排序的模式。无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此就把该Entry加入到了双向链表的末尾：get方法通过调用recordAccess方法来实现；</li></ul><ol start="2"><li>使用LinkedHashMap实现LRU算法</li></ol><ul><li>需要将accessOrder设置为true</li><li>需要重写removeEldestEntry方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class LRU&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    public LRU(int initialCapacity,</span><br><span class="line">             float loadFactor,</span><br><span class="line">                        boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor, accessOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** </span><br><span class="line">     * @description 重写LinkedHashMap中的removeEldestEntry方法，当LRU中元素多余6个时，</span><br><span class="line">     *              删除最不经常使用的元素</span><br><span class="line">     * @author rico       </span><br><span class="line">     * @created 2017年5月12日 上午11:32:51      </span><br><span class="line">     * @param eldest</span><br><span class="line">     * @return     </span><br><span class="line">     * @see java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry)     </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        if(size() &gt; 6)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LRU&lt;Character, Integer&gt; lru &#x3D; new LRU&lt;Character, Integer&gt;(</span><br><span class="line">                16, 0.75f, true);</span><br><span class="line"></span><br><span class="line">        String s &#x3D; &quot;abcdefghijkl&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            lru.put(s.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;LRU中key为h的Entry的值为： &quot; + lru.get(&#39;h&#39;));</span><br><span class="line">        System.out.println(&quot;LRU的大小 ：&quot; + lru.size());</span><br><span class="line">        System.out.println(&quot;LRU ：&quot; + lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>LinkedHashMap实现有序性的原理</li></ol><ul><li>需要重写HashMap中的迭代器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">    throw new IllegalStateException();</span><br><span class="line">    if (modCount !&#x3D; expectedModCount)</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        LinkedHashMap.this.remove(lastReturned.key);</span><br><span class="line">        lastReturned &#x3D; null;</span><br><span class="line">        expectedModCount &#x3D; modCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry&lt;K,V&gt; nextEntry() &#123;        &#x2F;&#x2F; 迭代输出双向链表各节点</span><br><span class="line">    if (modCount !&#x3D; expectedModCount)</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">        if (nextEntry &#x3D;&#x3D; header)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; lastReturned &#x3D; nextEntry;</span><br><span class="line">        nextEntry &#x3D; e.after;</span><br><span class="line">        return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>JDK1.8的改动</li></ol><ul><li>删除了addentry, createentry方法。</li><li>提供实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">   void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">   void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure>本质思想是一样的。</li></ul><h2 id="1-7和1-8重要区别"><a href="#1-7和1-8重要区别" class="headerlink" title="1.7和1.8重要区别"></a>1.7和1.8重要区别</h2><ul><li>1.7 哈希表，头插法，2个线程put，同时扩容会出现链表成环</li><li>哈希表，当链表达到一定长度则转化为红黑树<br>尾插法，避免2个线程put扩容链表成环<br><a href="https://www.cnblogs.com/lankerenf3039/p/12128199.html">1.7和1.8区别</a></li></ul><p><a href="https://www.cnblogs.com/wen-he/p/11496050.html">头插和尾插的区别</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-HashMap和HashTable不同点&quot;&gt;&lt;a href=&quot;#1-HashMap和HashTable不同点&quot; class=&quot;headerlink&quot; title=&quot;1 HashMap和HashTable不同点&quot;&gt;&lt;/a&gt;1 HashMap和HashTable不</summary>
      
    
    
    
    <category term="java集合框架" scheme="http://example.com/categories/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloud_netflix</title>
    <link href="http://example.com/2021/02/27/springcloud_netflix/"/>
    <id>http://example.com/2021/02/27/springcloud_netflix/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springcloud生态"><a href="#springcloud生态" class="headerlink" title="springcloud生态"></a>springcloud生态</h1><p><a href="https://www.bilibili.com/video/BV1jJ411S7xr?p=15">springcloud</a></p><h2 id="1-4-个问题"><a href="#1-4-个问题" class="headerlink" title="1 4 个问题"></a>1 4 个问题</h2><ol><li>API （解决网关）</li><li>HTTP， RPC（解决分布式通讯）</li><li>注册和发现（解决高可用）</li><li>熔断机制（进行服务降级）</li></ol><p>微服务：将单一的应用程序划分成一组小的服务</p><blockquote><p>mycat 数据库读写分离  elastic search</p></blockquote><p>spring cloud netflix</p><p>spring cloud 中国社区·</p><p>eureca是对应zookeeper的</p><h2 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2 Eureka"></a>2 Eureka</h2><p>是Netflix的一个子模块，是一个机遇rest的服务</p><ol><li>导入依赖</li><li>编写配置文件</li><li>开启这个功能@Enable</li><li>配置类</li></ol><p>eureka好死不如赖活着</p><p>eureka与zookeeper区别</p><p>CAP三选二<br>C 强一致性<br>A 可用性<br>P 分区容错性</p><p>zookeeper保证的是CP，enreka保证的是AP</p><blockquote><p>面试题，两者的区别</p></blockquote><h2 id="3-ribbon"><a href="#3-ribbon" class="headerlink" title="3 ribbon"></a>3 ribbon</h2><ol><li>spring cloud ribbon 是基于netflix实现的一套客户端负载均衡工具</li></ol><p>nginx是集中时，由nginx决定分发给谁</p><p>ribbon是进程时，由消费方通过注册中心获取所有可用，通过算法决定如何选择。</p><blockquote><p>feign是面向接口版本的ribbon, 也是负载均衡的</p></blockquote><h2 id="4-Hystrix"><a href="#4-Hystrix" class="headerlink" title="4 Hystrix"></a>4 Hystrix</h2><p>Hystrix 可以提供服务熔断和服务降级</p><p>服务熔断机制是对应雪崩效应的一种微服务链路保护机制</p><p>相关概念，备份，服务降级</p><p>服务熔断是提供者，服务降级是消费者</p><p>降级是客户端的，因为后台为了释放资源已经关闭了，可以用feign配合hystrix来进行</p><p>服务熔断：服务端，某个服务超时或者异常，引起熔断，保险丝</p><p>服务降级：客户端，从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再会被调用，不走服务器。此时在客户端，我们可以准备一个FallbackFactory，返回一个默认的值，但整体服务水平下降了。</p><h1 id="5-路由网关-zuul"><a href="#5-路由网关-zuul" class="headerlink" title="5 路由网关 zuul"></a>5 路由网关 zuul</h1><ol><li>身份验证和安全性</li><li>监控</li><li>动态路由</li><li>压力测试</li><li>减载</li><li>静态响应处理</li><li>多区域弹性</li></ol><blockquote><p>统一路由，统一权限认证</p></blockquote><p>通过配置文件对请求进行路由和过滤</p><h1 id="6-spring-cloud-config"><a href="#6-spring-cloud-config" class="headerlink" title="6 spring cloud config"></a>6 spring cloud config</h1><p>config为微服务架构中的微服务提供集中化的外部配置支持 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springcloud生态&quot;&gt;&lt;a href=&quot;#springcloud生态&quot; class=&quot;headerlink&quot; title=&quot;springcloud生态&quot;&gt;&lt;/a&gt;springcloud生态&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilib</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloudalibaba</title>
    <link href="http://example.com/2021/02/27/springcloudalibaba/"/>
    <id>http://example.com/2021/02/27/springcloudalibaba/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-nacos实时QPS"><a href="#1-nacos实时QPS" class="headerlink" title="1 nacos实时QPS"></a>1 nacos实时QPS</h1><p>服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户端，由客户端进行服务限流降级等操作。客户端的操作行为也会被推送到服务端，从而形成QPS</p><h1 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h1><ol><li>服务发现组件nacos</li><li>配置中心组件nacos</li><li>断路保护组件sentinel</li><li>远程组件dubbo,而原来是Openfeign</li><li>seata分布式事务</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-nacos实时QPS&quot;&gt;&lt;a href=&quot;#1-nacos实时QPS&quot; class=&quot;headerlink&quot; title=&quot;1 nacos实时QPS&quot;&gt;&lt;/a&gt;1 nacos实时QPS&lt;/h1&gt;&lt;p&gt;服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://example.com/2021/02/27/zookeeper/"/>
    <id>http://example.com/2021/02/27/zookeeper/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1 zookeeper"></a>1 zookeeper</h1><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=31">zookeeper+Dubbo</a></p><p>包括数据发布订阅、负载均衡、命名服务、集群管理分布式锁、分布式队列等功能。</p><ol><li>zookeeper提供了分布式数据一致性解决方案</li></ol><p>一致性：</p><ul><li>强一致性：锁机制、如果数据不一致，不提供服务</li><li>最终一致性：数据最终同步即可，没有实时性要求</li></ul><ol start="2"><li>CAP原则（一致性、可用性和分区容错性）</li></ol><ul><li>一致性：指的是强一致性 (C)</li><li>可用性：服务一直处于可用状态 (A)</li><li>分区容错性：在遇到任何网络分区故障，仍需要对外提供一致性和可用性服务。(P)<br>3选2， 要么AP 要么CP</li></ul><ol start="2"><li><p>一致性协议</p><ul><li><p>2PC二阶段提交</p><ul><li>阶段一预执行，但事务没有提交</li><li>阶段二执行事务提交或者中断事务，如果所有参与者都返回ack，则执行事务，否则中断<blockquote><p>这一个过程需要协调者</p><br></blockquote></li></ul></li><li><p>二阶段提交的问题</p><ul><li>同步阻塞：协调者发送消息后需要阻塞</li><li>单点：如果协调者挂了，就完了</li><li>脑裂导致数据不一致：如果协调者与某个节点断开，有些节点提交了，有些没有不一致</li></ul></li><li><p>3PC阶段提交</p><ul><li>阶段1，协调者向所有参与者发送canCommit询问，能否响应事务请求，相当于网络测试</li><li>阶段2，如果阶段1所有节点都能通讯，所有都执行预提交，也就是preCommit操作预提交，如果某个节点返回no或等待超时，则则中断事务。</li><li>阶段3，doCommit，如果所有阶段2都成功，执行提交，发送提交请求，否则中断事务。</li></ul></li><li><p>3PC解决了同步阻塞和单点问题，一个是超时时间解决同步阻塞，一个是如果协调者在三阶段挂了，其他节点没收到commit会自动提交</p></li></ul></li><li><p>paxos算法</p><ul><li>基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题的最有效的算法。</li><li>解决问题，在分布式系统中，如果产生宕机或网络异常，快速的正确的在集群内部解决数据一致性问题（过半理念）zookeeper基于 fast paxos版本</li><li>paxos中的四个角色<ul><li>client：产生提案者</li><li>peoposer：提案者</li><li>acceptor：决策者</li><li>learners: 学习者（只遵循最后的结果）</li></ul></li><li>paxos分为两个阶段<ul><li>阶段1：prepare阶段：准备解决</li><li>阶段2：accept阶段：同意阶段</li></ul></li><li>prepare阶段<ul><li>proposer做出一个提案，编号为n发送给所有acceptor。</li><li>第一次接受prepare请求：maxN被保存，同时响应</li><li>不是第一次，每个决策者保存一个最大提案号maxN,如果n小于maxN，证明提案已过时，拒绝。如果大于maxN，更新maxN，进行响应。</li><li>如果收到的响应过半，立刻进入第二阶段。</li></ul></li><li>accept阶段<ul><li>传递编号n和value， (n, value)，如果n大于等于maxN,同意提案，进行响应。如果小于，那么拒绝提案，不会响应。</li></ul></li></ul><ol><li> 活锁问题（解决办法，执行时间稍稍错开）</li></ol></li><li><p>zookeeper 使用的是ZAB（Fast Paxos），因为Paxos存在活锁和全序的问题</p></li></ol><ul><li>ZAB（zookeeper atomic broadcast）：是一种支持崩溃恢复的原子广播协议</li><li>Zookeeper使用单一主进程Leader处理客户端发送过来的所有事务请求（写清求）。当服务器数据发生变更后，会把请求包装成提案，发送给所有follower，只要follower达到半数，同意请求，之后leader通知所有follower，进行同步数据。读请求的话，leader会自己响应。</li><li>如果客户端发送到follower上的话，如果是读请求，follwer自己响应，否则是写清求的话，会将请求转发给leader，走leader的流程。</li></ul><ol start="5"><li>zookeeper的三种角色</li></ol><ul><li>leader：主要负责处理集群的写清求，并发起投票，只有超过半数的节点同意后才会提交该写请求</li><li>follower：处理读请求，响应结果。转发写清求得到leader,并在选举leader过程中参与投票。</li><li>observer：可以理解为没有投票权的follower，主要职责是协助follower处理读请求，当整个zk集群读请求负载很高时，增加。如果增加follower会增加写请求负载，因为follower也要投票。</li></ul><ol start="5"><li>zookeeper两种模式</li></ol><ul><li>恢复模式：当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，完成leader和其他机器的同步，当大多数server完成和leader的同步后，恢复模式结束。</li><li>广播模式：一旦leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li><li>在ZAB的事务的二阶段提交中，移除了事务的中断，要么ack，要么放弃，leader无需等待所有的follower的ack.</li></ul><ol start="6"><li>zxid</li></ol><ul><li>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid</li></ul><ol start="7"><li>leader选举原则<ol><li>zookeeper集群只有超过了半数以上的服务器启动，集群才能正常工作</li><li>在集群正常工作之前，myid小的服务器会给myid大服务器进行投票，持续到集群正常工作，选出leader</li><li>选出leader之后，之前的服务器的状态由looking改变为following,之后的服务器都是follower</li></ol></li><li>zab解决全序问题，因为事务执行顺序不同，导致结果不同，leader会创建一个队列，保证最终结果。</li></ol><blockquote><p>相关操作</p></blockquote><blockquote><ol><li>ls path watch 监听节点子节点的变化</li></ol></blockquote><blockquote><ol start="2"><li>get path watch 监听节点值的变化</li></ol></blockquote><blockquote><ol start="3"><li>监听的有效期只有一次</li></ol></blockquote><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h1><ol><li>配置中心</li></ol><ul><li>把配置信息存在节点中，通过监听来同步</li></ul><ol start="2"><li>负载均衡</li></ol><ul><li>新增服务器，让nginx知道服务器列表的更新。通过监听器监视servers子节点的状态变化。</li></ul><ol start="3"><li>命名服务</li></ol><ul><li>创建顺序节点保证唯一标识</li></ul><ol start="4"><li>DNS服务</li><li>集群管理<ol><li>集群控制：对集群中节点进行操作与控制</li><li>集群监控：对集群节点运行状态的收集</li></ol></li></ol><ul><li>zookeeper集群管理主要利用了watcher机制和创建临时节点来实现。比如机器上下线：<ul><li>新增机器的时候，将Agent部署到新增的机器上，当Agent部署启动时，会向zookeeper指定的节点下创建一个临时子节点，通过监视器，对机器的上下线进行监控。</li><li>当子节点创建完成后，机器会接受到”子节点变更事件”，即上限通知，就可以对新加入的机器开启相应的后台管理逻辑。监控中心同样可以获得到机器的运行状态信息。</li></ul></li></ul><ol start="6"><li>分布式锁<ol><li>数据库实现分布式锁，让不同的服务器操作同一个数据库。使用dblock.lock();添加一条记录，lock_name:db_lock_stock。注意这个lock_name是惟一的，如果已经存在，需要阻塞。</li><li>redis实现分布式锁，基于setnx（set if not exists），设置成功返回1，否则返回0.要注意设置过期时间，防止异常，expire name time。redis为了解决单点问题，官方推出了分布式锁redlock</li><li>zookeeper实现分布式锁<ul><li>原理：创建有序临时节点+watch监听来实现。每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己剩下的临时节点的序号是否是最小的。如果是最小的，将会获取到锁，执行相关操作，释放锁。如果不是最小的，会监听它的前一个节点，当它的前一个节点被删除时，它就会获得锁，依次类推。</li></ul></li></ol></li><li>分布式队列：跟分布式锁相似，监听之前的节点是否出列</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-zookeeper&quot;&gt;&lt;a href=&quot;#1-zookeeper&quot; class=&quot;headerlink&quot; title=&quot;1 zookeeper&quot;&gt;&lt;/a&gt;1 zookeeper&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903490196619272">操作系统内存管理</a></p><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">图解内存管理</a>(重点)</p><h1 id="1-存储区体系"><a href="#1-存储区体系" class="headerlink" title="1 存储区体系"></a>1 存储区体系</h1><p>主存（RAM）是一件非常重要的资源，不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多。</p><h2 id="1-1-分层存储器体系-memory-hierarchy"><a href="#1-1-分层存储器体系-memory-hierarchy" class="headerlink" title="1.1 分层存储器体系(memory hierarchy)"></a>1.1 分层存储器体系(memory hierarchy)</h2><p><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/DCDF99335BF54511A72AC2890C6F17FD/14946" alt="存储层次结构"></p><h2 id="1-2-无存储抽象"><a href="#1-2-无存储抽象" class="headerlink" title="1.2 无存储抽象"></a>1.2 无存储抽象</h2><p>将物理内存暴露给进程的缺点：</p><ol><li>如果用户程序可以寻址内存的每个字节，他们就可以很容易的破坏操作系统，从而使系统停止运行。</li><li>难以运行多个程序（地址冲突）</li></ol><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><blockquote><p>MMU(内存管理单元)：硬件组件负责处理CPU的内存访问请求</p></blockquote><h2 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h2><p>更好的支持多道程序并发执行，提高系统性能。进程之间共享的不仅仅是处理机，还有主存储器。如果不对内存进行管理，容易导致内存数据的混乱。</p><h2 id="2-2-内存管理功能"><a href="#2-2-内存管理功能" class="headerlink" title="2.2 内存管理功能"></a>2.2 内存管理功能</h2><ul><li>内存空间的分配与回收</li><li>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</li><li>内存空间的扩充：虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li><li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li><li>程序装入和链接<h2 id="2-3-逻辑地址空间和物理地址空间"><a href="#2-3-逻辑地址空间和物理地址空间" class="headerlink" title="2.3 逻辑地址空间和物理地址空间"></a>2.3 逻辑地址空间和物理地址空间</h2></li><li>编译后，每个目标模块都是从0号单元开始编址（逻辑地址），链接程序顺序依次按各个模块的相对地址构成从0号单元开始编址的逻辑地址空间。</li><li>物理地址空间指内存中物理单元的集合。通过物理地址在主存中存取数据。</li><li>当装入程序将可执行代码装入内存时，必须通过地址转换讲逻辑地址转换成物理地址，这个过程称为地址重定位<h2 id="2-4-内存保护"><a href="#2-4-内存保护" class="headerlink" title="2.4 内存保护"></a>2.4 内存保护</h2></li></ul><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p><ul><li>设置上下限寄存器存放主存中的上下限地址判断是否越界。</li><li>采用重定位寄存器（基址寄存器，存放最小的物理地址值）和界地址寄存器（限长寄存器，存放逻辑地址的最大值）。<h1 id="3-管理方式"><a href="#3-管理方式" class="headerlink" title="3 管理方式"></a>3 管理方式</h1></li></ul><h2 id="3-0-逻辑地址与物理地址的转换"><a href="#3-0-逻辑地址与物理地址的转换" class="headerlink" title="3.0 逻辑地址与物理地址的转换"></a>3.0 逻辑地址与物理地址的转换</h2><ol><li>ALU需要某个逻辑地址的内存的内容</li><li>内存管理单元（MMU）寻找在逻辑地址和物理地址之间的映射，如果没有就从内存中找。（操作系统完成）</li><li>控制器从总线发送在物理内存内容的请求</li><li>内存发送物理地址给CPU</li></ol><h2 id="3-1-连续分配管理方式"><a href="#3-1-连续分配管理方式" class="headerlink" title="3.1 连续分配管理方式"></a>3.1 连续分配管理方式</h2><ol><li>单一连续分配：分配到内存固定区域，只适合单任务系统</li><li>固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不相等。内部碎片（已经被分配出去（能明确是哪个线程），却不能被利用的内存空间）<ul><li>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</li></ul></li><li>动态分区分配：按程序的需要进程动态划分。外部碎片（还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。）<ul><li>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br><a href="https://www.cnblogs.com/sjlove/archive/2013/06/05/3119683.html">外部碎片和内部碎片</a><h2 id="3-2-空闲内存管理"><a href="#3-2-空闲内存管理" class="headerlink" title="3.2 空闲内存管理"></a>3.2 空闲内存管理</h2>在进行内存动态分配时，操作系统必须对其进行管理。一般来说，有两种监控内存使用的方式</li></ul></li></ol><ul><li>位图（bitmap）（基于表的）：使用位图方法时，内存被划分为分配单元，每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。位图的大小取决于内存和分配单元的大小。</li><li>位图的分配：找到连续的0。</li><li>空闲列表（free lists）（基于链的）：维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点会包含进程或者是两个进程间的空闲区域。</li><li>空闲列表的分配：（动态分区分配算法）<br><br>(如果为进程和空闲区维护各自独立的链表，就能集中精力只检查空闲区而不是进程，但这种分配速度的提高的一个不可避免的代价就是增加复杂度和内存释放速度变慢，因为必须将一个回收的段从进程链表中删除并插入空闲区链表)<ol><li>首次适配：从头开始扫描，直到找到一个足够大的空闲区</li><li>下次适配：从上次结束的地方开始扫描</li><li>最佳适配：从头到尾扫描，找到能容纳进程的最小空闲区。会产生大量无用的小缓冲区。</li><li>最差适配：总是分配最大的内存区域（不会分裂出小缓冲区）</li><li>快速适配：为常用大小的空闲区维护单独的链表。<br>[位图和空闲链表]<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">https://blog.csdn.net/qq_22238021/article/details/80175461</a>)</li></ol></li></ul><h2 id="3-3-非连续分配管理方式"><a href="#3-3-非连续分配管理方式" class="headerlink" title="3.3 非连续分配管理方式"></a>3.3 非连续分配管理方式</h2><p>对于内存的连续分配，总是会有碎片的产生，内存利用率低，而且执行碎片整理的方法也都是有开销的。因此，非连续内存分配就能很好的解决碎片问题，也是操作系统中用的最多的内存分配方法。<br>非连续分配（分页/分段）允许一个程序分散地装入到不相邻的内存分区中去。</p><h3 id="3-3-1-基本分页存储管理方式"><a href="#3-3-1-基本分页存储管理方式" class="headerlink" title="3.3.1 基本分页存储管理方式"></a>3.3.1 基本分页存储管理方式</h3><p><a href="https://zhuanlan.zhihu.com/p/87514615">分页分段解释较好</a></p><p>内存分为固定的块，按物理结构划分，会有内部碎片</p><ol><li>基本概念<ul><li>页<ul><li>一定大小字节数内存单元，属于逻辑单元。进程中所有代码、数据等信息均按页进行存储，属于逻辑组织形式。每个页有页码及其他信息。</li></ul></li><li>页框<ul><li>对应页字节数的物理内存，属于物理单元，是实际存在于物理内存中的可用地址单元。页框相当于页的容器，进程运行过程中，可能会动态加载不同页进入页框，CPU则直接对页框进行存取。</li></ul></li><li>页表<ul><li>既然有页和对应页框，那就必须有映射表将两者联系起来，而页表就是页和页框之间的映射表。换言之，知道页就可以查询到页框，知道页框，也可以查询到对应页。</li></ul></li><li>进程中的块称为页，内存中的块称为页框，外存以同样的单位进行划分，称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框。</li><li>地址结构 页号 + 页内偏移量</li><li>页表 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建3立一张页表，记录页面在内存中对应的物理块号。页表一般放在内存中。</li></ul></li><li>基本地址变换机构<br><br>页式管理中地址空间是一维的<br><br>两个主要问题：<ul><li>每次访问操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低</li><li>每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li></ul></li><li>具有快表的地址变换机构</li></ol><ul><li>若页表全部放在内存中，则存取一条数据或指令至少需要访问两次内存：一次访问页表，确定物理地址，第二次存取数据或指令</li><li>快表/联想寄存器/TLB 在地址变换机构中的一个具有并行查找能力的高速缓冲存储器。用来存放当前访问的若干页表项，以加速地址变换的过程。主存中的页表称为慢表。</li></ul><ol start="4"><li>两级页表<br><br>一级页号+二级页号+页内偏移</li><li>分页和分段的区别<ul><li>页是信息的物理单位，分页是为了减少内存碎片，提高内存利用率。分页仅仅是由于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它包含一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统确定，逻辑地址的划分是由寄存器实现的，因而一个系统只能有一种大小的页面。段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<h3 id="3-3-2-基本分段存储管理模式"><a href="#3-3-2-基本分段存储管理模式" class="headerlink" title="3.3.2 基本分段存储管理模式"></a>3.3.2 基本分段存储管理模式</h3></li></ul></li></ol><p>内存块的大小不固定，按逻辑结构划分，会有外部碎片。</p><h1 id="4-内存扩充"><a href="#4-内存扩充" class="headerlink" title="4 内存扩充"></a>4 内存扩充</h1><h2 id="4-1-覆盖"><a href="#4-1-覆盖" class="headerlink" title="4.1 覆盖"></a>4.1 覆盖</h2><p>在较小的内存中运行较大的内存，将没有调用关系的程序放在一个分区。可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分里即将访问的段放进覆盖区，其他段放在外存。<br><img src="http://note.youdao.com/yws/public/resource/375267987e6a5e59121a79328ccdf2bc/xmlnote/BE6AB4C1E94E42FD8718721D3956E4C3/15170"><br>B，D，E没有调用关系，也就是说，在调用B时，不可能同时调用D或E，所以共享一个覆盖区。早期用这个技术来节约内存。</p><h2 id="4-2-交换"><a href="#4-2-交换" class="headerlink" title="4.2 交换"></a>4.2 交换</h2><p>将暂时不能运行的程序送到外存，从而获得空闲内存空间。粒度是一个程序，需要操作系统支持，对程序员透明。</p><p>把处于等待状态的程序从内存移到辅存，把内存空间腾出来（换出）。把准备好竞争CPU运行的程序从辅存移到内存（换入）</p><ol><li>覆盖与交换的比较<ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间。</li><li>交换技术是在以内存中的程序大小为单位来进行的，一般一页以上。不需要程序员给出各个模块之间的逻辑覆盖结构。</li><li>覆盖和交换都有它的局限性，覆盖过于麻烦，而交换的粒度太大，以程序为单位。所以需要虚拟内存技术。</li></ul></li></ol><h2 id="4-3-虚拟内存"><a href="#4-3-虚拟内存" class="headerlink" title="4.3 虚拟内存"></a>4.3 虚拟内存</h2><p>随着软件的不断增大，需要运行的程序往往大到内存无法容纳。应用交换技术并不是很高效（交换几GB的内存）。</p><p>虚拟内存使用了外存上的空间来扩充内存的空间，通过一定的换入换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，导致平均访存时间下降，如果使用了不合适的替换算法，则会<br>大大降低系统性能。</p><ul><li>虚拟存储器：对物理存储器的抽象，允许程序申请大于实际物理存储的内存，提供一致性的地址空间。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统讲所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放要掉入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</li><li>内存管理单元（Memory Management Unit， MMU），MMU把虚拟地址映射为物理内存地址。</li></ul><h3 id="4-3-1-局部性原理"><a href="#4-3-1-局部性原理" class="headerlink" title="4.3.1 局部性原理"></a>4.3.1 局部性原理</h3><ul><li>时间局部性：如果一条指令被执行或某个数据被访问过，那么不久以后该指令可能再次执行，该数据可能再次被访</li><li>空间局部性：如果某个单元被访问过，那么不久之后它周围的空间也会被访问。<h3 id="4-3-2-特征"><a href="#4-3-2-特征" class="headerlink" title="4.3.2 特征"></a>4.3.2 特征</h3></li></ul><ol><li>多次性， 无需在作业时一次性全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性，无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出</li><li>虚拟性，从逻辑上扩充内存的容量，用户看到的内存容量，远大于实际的内存容量<h3 id="4-3-3-虚拟技术内存的实现"><a href="#4-3-3-虚拟技术内存的实现" class="headerlink" title="4.3.3 虚拟技术内存的实现"></a>4.3.3 虚拟技术内存的实现</h3></li><li>一定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序访问到的部分尚未调入内存，则产生中断</li><li>地址变换机构，逻辑地址到物理地址的变换</li></ol><h3 id="4-3-4-请求分页管理方式"><a href="#4-3-4-请求分页管理方式" class="headerlink" title="4.3.4 请求分页管理方式"></a>4.3.4 请求分页管理方式</h3><ol><li>页表机制</li></ol><ul><li>页号</li><li>物理块号</li><li>保护位：允许对该页做何种类型的访问（只读、可读写、）</li><li>驻留位：指示该页在内存还是在外存</li><li>访问字段A：记录本页在一段时间内被访问的次数，或多长时间未被访问（用于页面置换算法）</li><li>修改位M：标识该页在调入内存后收否被修改过</li><li>外存地址：该页在外存上的地址</li></ul><ol start="2"><li>缺页中断机构</li></ol><ul><li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成时唤醒），如果内存中有空闲块则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页。（若被淘汰页在内存期间被修改过，则要将其写回外存）</li></ul><ol start="3"><li>地址变换机构<br><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/8E649EF21B8F4CDCB559DDDAE97F147E/15122"></li></ol><h3 id="4-3-5-页面置换算法（决定应该换入哪页，换出哪页）"><a href="#4-3-5-页面置换算法（决定应该换入哪页，换出哪页）" class="headerlink" title="4.3.5 页面置换算法（决定应该换入哪页，换出哪页）"></a>4.3.5 页面置换算法（决定应该换入哪页，换出哪页）</h3><ol><li>最佳置换算法（OPT）：选择在最长时间内不在被访问的页面换出。实际上该算法无法使用</li><li>先进先出（FIFO）页面置换算法：淘汰最早进入内存的页面</li><li>最近最久未使用（LRU）置换算法：选择最长时间未访问的页面淘汰需要TLB实现（硬件支持 双向链表+hash</li><li>时钟（CLOCK）（Not Recently Used，NRU）置换算法：循环扫描缓冲区，像时钟的针一样转动。给每一帧关联一个使用位。当缺页错误出现时，首先检查指针指向的页面，如果R位是0就淘汰页面，并把新页面插入，然后表针前移；如果R位是1就清零前移。和第二次算法性能差不多，花费更少时间，实际使用的算法.</li><li>工作集置换算法，一个进程当前使用的页面的集合称为工作集。</li><li>工作集时钟页面置换算法</li><li>LFU（ Least Frequently Used，最不频繁使用）两个双向链表+hash</li><li>第二次机会页面置换算法：在FIFO基础上增加使用位，如果链首使用位是1则清零加入链尾。相比FIFO性能大大提高</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903490196619272&quot;&gt;操作系统内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_29677867/article/details/91038</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>创建型模式</title>
    <link href="http://example.com/2021/02/27/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/27/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;noodle&quot;)) &#123;</span><br><span class="line">            Food noodle &#x3D; new LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(&quot;more&quot;);</span><br><span class="line">            return noodle;</span><br><span class="line">        &#125; else if (name.equals(&quot;chicken&quot;)) &#123;</span><br><span class="line">            Food chicken &#x3D; new HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(&quot;potato&quot;);</span><br><span class="line">            return chicken;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单工厂模式可以理解为根据类名，通过if else创建不同的类。一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><h1 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 工厂模式</h1><p>定义一个接口，接口中有方法，不同的实际类会实现这个接口，这个方法会创建对象，这样通过多态就可以创建对象。每个工厂可以生产多个产品。</p><h1 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3 抽象工厂模式"></a>3 抽象工厂模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简单工厂模式&quot;&gt;&lt;a href=&quot;#1-简单工厂模式&quot; class=&quot;headerlink&quot; title=&quot;1 简单工厂模式&quot;&gt;&lt;/a&gt;1 简单工厂模式&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>大话设计模式</title>
    <link href="http://example.com/2021/02/27/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/27/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>设计模式分为三大类：</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="一、简单工厂模式与工厂方法模式（重点可看大话设计模式）-https-blog-csdn-net-qq-34337272-article-details-80472071"><a href="#一、简单工厂模式与工厂方法模式（重点可看大话设计模式）-https-blog-csdn-net-qq-34337272-article-details-80472071" class="headerlink" title="一、简单工厂模式与工厂方法模式（重点可看大话设计模式） https://blog.csdn.net/qq_34337272/article/details/80472071"></a>一、简单工厂模式与工厂方法模式（重点可看大话设计模式） <a href="https://blog.csdn.net/qq_34337272/article/details/80472071">https://blog.csdn.net/qq_34337272/article/details/80472071</a></h1><h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h2><p>简单工厂模式实际上就是创建一个接口，这个接口有相关类的某种抽象功能或者特性，这个接口或父类的对象就是简单工厂中的产品。</p><p>在实际使用中，我们只需要创建某个类实现这个借口，或者继承父类，就可以创建子类对象，投入到简单工厂中。</p><p>再创建一个工厂类，这里可以采用两种办法，第一种使用switch，但就不符合开放封闭原则。第二种使用反射， obj = Class.forName(clazz.getName()).newInstance(); 这种方法可以在增加子类产品时不需要修改工厂类。</p><h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2 工厂方法模式"></a>2 工厂方法模式</h2><p>工厂方法模式是定义一个用于创建对象的接口，由子类对象决定实例化哪一个。</p><p>工厂方法模式与简单工厂的一个区别，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p><p>工厂方法模式，将工厂类进行抽象，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。换句话说，工厂方法模式中的要素有四个：</p><p>抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 </p><p>具体工厂(Concrete Factory)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 </p><p>抽象产品(AbstractProduct)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</p><p>具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应</p><p>这样，我们创建抽象类型的工厂类，其实际对象为具体工厂类（对应具体产品），可以将实现方法剥离。在调用时，我们只需要生成生产具体产品的具体工厂类，调用其中的统一方法即可。</p><h2 id="3-抽象工厂方法"><a href="#3-抽象工厂方法" class="headerlink" title="3 抽象工厂方法"></a>3 抽象工厂方法</h2><p>抽象工厂是生产一整套有产品的方法（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。</p><p>也就是说抽象工厂类中不再只有一抽象种产品，而是多个抽象产品。再创建具体工厂时要对两种产品做出@Override。每种抽象产品又有多个具体产品实现类。</p><p>举个例子，抽象工厂代表某军事工事，其能生产抽象产品枪和子弹，具体的工厂为某品牌工厂，在该具体工厂类中，其所重写的方法即是生产该品牌公司所生产的具体产品枪和子弹。</p><p>这样也有缺点，极有可能会违反抽象封闭原则，比如增加公司，这个问题可用反射解决。</p><h1 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h1><h2 id="1-预加载"><a href="#1-预加载" class="headerlink" title="1 预加载"></a>1 预加载</h2><p>还没有实例化该对象，该对象就已经加载到内存中。这种方法会造成内存的浪费。</p><pre><code>public class PreloadSingleton &#123;   public static PreloadSingleton instance = new PreloadSingleton();   //其他的类无法实例化单例类的对象   private PreloadSingleton() &#123;   &#125;;   public static PreloadSingleton getInstance() &#123;          return instance;   &#125;&#125;</code></pre><h2 id="2-懒加载（这里涉及到线程加锁保证安全问题）"><a href="#2-懒加载（这里涉及到线程加锁保证安全问题）" class="headerlink" title="2 懒加载（这里涉及到线程加锁保证安全问题）"></a>2 懒加载（这里涉及到线程加锁保证安全问题）</h2><p>用到该单例对象时再创建，可避免内存浪费，但不是线程安全的。</p><pre><code>public class Singleton &#123;   private static Singleton instance=null;   private Singleton()&#123;   &#125;;   public static Singleton getInstance()   &#123;          if(instance==null)          &#123;                 instance=new Singleton();          &#125;          return instance;   &#125;&#125;</code></pre><h1 id="三、装饰器模式"><a href="#三、装饰器模式" class="headerlink" title="三、装饰器模式"></a>三、装饰器模式</h1><p>装饰器模式中有四个类很重要。</p><p>1.Component（被装饰对象的基类）<br>   定义一个对象接口，可以给这些对象动态地添加职责。</p><p>2.ConcreteComponent（具体被装饰对象）<br>   定义一个对象，可以给这个对象添加一些职责。</p><p>3.Decorator（装饰者抽象类）<br>   维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。</p><p>4.ConcreteDecorator（具体装饰者）<br>   具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</p><p>以商城为例子，如下：</p><ol><li>Component抽象类</li></ol><pre><code>public abstract class Component &#123;    public abstract void operation();&#125;</code></pre><ol start="2"><li>ConretetComponent类（具体被装饰物类）</li></ol><pre><code>public class ConcreteComponent extends Component &#123;    @Override    public void operation() &#123;        System.out.println(&quot;具体对象的操作&quot;);    &#125;&#125;</code></pre><p>3 Decorator装饰类</p><pre><code>public abstract class Decorator extends Component &#123;    private Component component = null;    //通过构造函数传递给被修饰者    public Decorator(Component component) &#123;        this.component = component;    &#125;    //委托给被修饰者执行    @Override    public void operation() &#123;        if(component != null) &#123;            this.component.operation();        &#125;    &#125;&#125;</code></pre><p>4 ConcreteDecorator类（具体装饰类）</p><pre><code>public class ConcreteDecoratorA extends Decorator &#123;    //定义被修饰者    public ConcreteDecoratorA(Component component) &#123;        super(component);    &#125;    //定义自己的修饰方法    private void method1() &#123;        System.out.println(&quot;method1 修饰&quot;);    &#125;    @Override    public void operation() &#123;        this.method1();        super.operation();    &#125;&#125;public class ConcreteDecoratorB extends Decorator &#123;    //定义被修饰者    public ConcreteDecoratorB(Component component) &#123;        super(component);    &#125;    //定义自己的修饰方法    private void method2() &#123;        System.out.println(&quot;method2 修饰&quot;);    &#125;    @Override    public void operation() &#123;        super.operation();        this.method2();    &#125;&#125;</code></pre><p>5 Client客户端</p><pre><code>public class Client &#123;    public static void main(String[] args) &#123;        Component component = new ConcreteComponent();        //第一次修饰        component = new ConcreteDecoratorA(component);        //第二次修饰        component = new ConcreteDecoratorB(component);        //修饰后运行        component.operation();    &#125;&#125;</code></pre><p>这里说一下装饰过程，首先生成了具体被装饰类component，第一次生成装饰器A，其内部的组件对象为原始的component,然后生成装饰器B，此时其内部组件对应的是componentA,在调用componentB的operation时，会先调用父类decorator的方法operation，该方法会调用当前存储的对象componentA的operation方法，这样实现了一级一级的传递过程。</p><h1 id="四-代理模式"><a href="#四-代理模式" class="headerlink" title="四 代理模式"></a>四 代理模式</h1><p><a href="https://www.cnblogs.com/daniels/p/8242592.html">https://www.cnblogs.com/daniels/p/8242592.html</a> 记录较为清楚</p><p>代理模式分为静态代理和动态代理</p><p>动态代理类如下：</p><pre><code>package main.java.proxy.impl;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxyHandler implements InvocationHandler &#123;private Object object;public DynamicProxyHandler(final Object object) &#123;    this.object = object;&#125;@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;    System.out.println(&quot;买房前准备&quot;);    Object result = method.invoke(object, args);    System.out.println(&quot;买房后装修&quot;);    return result;&#125;&#125;</code></pre><p>测试类如下：</p><pre><code>package main.java.proxy.test;import main.java.proxy.BuyHouse;import main.java.proxy.impl.BuyHouseImpl;import main.java.proxy.impl.DynamicProxyHandler;import java.lang.reflect.Proxy;public class DynamicProxyTest &#123;    public static void main(String[] args) &#123;    BuyHouse buyHouse = new BuyHouseImpl();    BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new            Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));    proxyBuyHouse.buyHosue();&#125;&#125;</code></pre><p>注意Proxy.newProxyInstance()方法接受三个参数：<br>ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法。</p><h1 id="五-原型模式"><a href="#五-原型模式" class="headerlink" title="五 原型模式"></a>五 原型模式</h1><p>这个模式要注意两个地方</p><p>1 深拷贝和浅拷贝，使用clone是深拷贝，但this.MemberwiseClone是拷贝的对象是拷贝的引用为浅拷贝，要一层一层的深拷贝。</p><p>2 要注意实现Cloneable 接口，调用super.Clone方法</p><h1 id="六-外观模式"><a href="#六-外观模式" class="headerlink" title="六 外观模式"></a>六 外观模式</h1><p>spring mvc就是一个外观模式的例子，在维护一个大型系统时。开发外观类与之对接可以降低偶合。</p><h1 id="七-策略模式"><a href="#七-策略模式" class="headerlink" title="七 策略模式"></a>七 策略模式</h1><h1 id="八-模板方法（与策略模式很像）"><a href="#八-模板方法（与策略模式很像）" class="headerlink" title="八 模板方法（与策略模式很像）"></a>八 模板方法（与策略模式很像）</h1><p>模板模式关注统一算法的不同实现，策略模式关注不同算法。</p><p>模板模式将不变的行为放到超类中。</p><p>可看servlet源码</p><h1 id="九-建造者模式（生成器模式）"><a href="#九-建造者模式（生成器模式）" class="headerlink" title="九 建造者模式（生成器模式）"></a>九 建造者模式（生成器模式）</h1><h1 id="十-适配器模式"><a href="#十-适配器模式" class="headerlink" title="十 适配器模式"></a>十 适配器模式</h1><p>模式说明：</p><ul><li>包装类 = 适配器Adapter；</li><li>被包装对象 = 适配者Adaptee = 被适配的类</li></ul><p>作用：</p><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MagaGenericServlet implements Servlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象类继承了Servlet类，对于需要实现的内容进行空实现 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;&#x2F;login&quot;)</span><br><span class="line">public class LoginServlet1 extends MagaGenericServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;我被执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;设计模式分为三大类：&lt;/p&gt;
&lt;p&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。&lt;/p&gt;
&lt;p&gt;结构型模</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统常见问题</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同步和异步的区别"><a href="#1-同步和异步的区别" class="headerlink" title="1 同步和异步的区别"></a>1 同步和异步的区别</h1><p>同步和异步通常用来形容一次方法调用</p><ul><li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li><li>异步方法调用更像一个消息传递，一旦开始，方法调用就回立即返回，调用者就可以继续后续的操作。异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。<h1 id="2-进程和线程的区别，谁调度的进程"><a href="#2-进程和线程的区别，谁调度的进程" class="headerlink" title="2 进程和线程的区别，谁调度的进程"></a>2 进程和线程的区别，谁调度的进程</h1></li></ul><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、数据段和堆栈段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的话费远比进程要小很多，同时创建一个线程的开销也比进程小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。但是如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。<h1 id="3-死锁的条件，如何检查死锁"><a href="#3-死锁的条件，如何检查死锁" class="headerlink" title="3 死锁的条件，如何检查死锁"></a>3 死锁的条件，如何检查死锁</h1></li></ol><ul><li>死锁的定义： 多个进程因为竞争资源而造成一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</li><li>死锁的必要条件：互斥、不剥夺、请求和保持、循环等待</li><li>解决死锁：破坏条件，资源剥夺、撤销进程，进程回退</li><li>用银行家算法预防和避免死锁。</li></ul><h1 id="4-调度算法有哪些"><a href="#4-调度算法有哪些" class="headerlink" title="4 调度算法有哪些"></a>4 调度算法有哪些</h1><p>先来先服务、最短寻道时间、扫描算法、Look算法</p><h1 id="5-进程的状态转换图及转换事件"><a href="#5-进程的状态转换图及转换事件" class="headerlink" title="5 进程的状态转换图及转换事件"></a>5 进程的状态转换图及转换事件</h1><h1 id="6-进程的通信机制"><a href="#6-进程的通信机制" class="headerlink" title="6 进程的通信机制"></a>6 进程的通信机制</h1><p>临界区、互斥量、信号量、事件</p><p>管道、具名管道、消息队列、共享内存、信号量</p><ul><li>管道： 父子进程通过管道通信，管道是一种两个进程间单向通信的机制，因为管道传递数据的单向性，管道又被称为半双工管道，管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。（没有名字、大小受限、没有格式的字节流）</li><li>具名管道：FIFO，提供一个路径名与之关联，存在与文件系统中，这样即使与创建FIFO的进程不存在亲缘关系的进程，只要可以访问路径，就能够通过彼此的FIFO通信。因此，通过FIFO不相关进程也能交换数据</li><li>消息队列：消息队列用与同一机器上的进程间通信，与管道类似，是一个系统内核中保存消息的队列，在内核中以消息链表的形式出现。消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。</li><li>共享内存：共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的程序间共享和传递数据的一种非常有效的方式。不同进程间的内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的内存空间中，所有进程都可以访问共享内存中的地址。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及统一进程内不同线程之间的同步手段。</li></ul><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">内存管理</a></p><p><a href="https://blog.csdn.net/qq_43684985/article/details/109255207">文件管理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-同步和异步的区别&quot;&gt;&lt;a href=&quot;#1-同步和异步的区别&quot; class=&quot;headerlink&quot; title=&quot;1 同步和异步的区别&quot;&gt;&lt;/a&gt;1 同步和异步的区别&lt;/h1&gt;&lt;p&gt;同步和异步通常用来形容一次方法调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步方法调用一</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统相关概念</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统（operating-System，-OS）"><a href="#1-操作系统（operating-System，-OS）" class="headerlink" title="1 操作系统（operating System， OS）"></a>1 操作系统（operating System， OS）</h1><p>操作系统是计算机系统中最基本的系统软件</p><h2 id="1-1-操作系统作用"><a href="#1-1-操作系统作用" class="headerlink" title="1.1 操作系统作用"></a>1.1 操作系统作用</h2><ol><li>管理分配资源，组织调度计算机的工作<ul><li>处理机管理（进程管理）</li><li>存储器管理（内存）</li><li>文件管理（文件系统）</li><li>设备管理（I/O）</li></ul></li><li>为用户和其他软件提供接口和环境。<ul><li>命令接口：用户利用这些命令来组织和控制作业的运行<ul><li>交互式命令接口（联机）</li><li>批处理命令接口（脱机）</li></ul></li><li>程序接口：系统调用，请求操作系统服务。<h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2 操作系统特征"></a>1.2 操作系统特征</h2></li></ul></li><li>并发：两个或多个事件在同一时间间隔内发生。通过分时实现。</li><li>共享：指系统中的资源可供内存中多个并发的进程共同使用。<ul><li>互斥共享方式</li><li>同时访问方式</li></ul></li><li>虚拟： 把一个物理上的实体变为若干个逻辑上的对应物。</li><li>异步：并发执行时，由于资源有限，进程的执行不是一贯到底而是走走停停，以不可预知的速度向前推进。<h2 id="1-3-操作系统的运行机制"><a href="#1-3-操作系统的运行机制" class="headerlink" title="1.3 操作系统的运行机制"></a>1.3 操作系统的运行机制</h2></li><li>内核态：操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。内核态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令,包括：<ul><li>时钟管理：计时中断实现进程切换</li><li>中断机制</li><li>原语：<ul><li>处于操作系统的最底层，是最接近硬件的部分</li><li>操作不可中断（关闭中断，让其所有动作执行完在打开中断）</li><li>运行时间较短且调用频繁。</li></ul></li><li>系统控制的数据结构及处理：<ul><li>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理： 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理：缓冲区管理、设备分配和回收等<blockquote><p>系统调用运行在系统的内核态，为了获取操作系统的服务，用户程序必须使用系统调用，系统调用会转换为内核态并且调用操作系统。</p></blockquote></li></ul></li></ul></li><li>用户态：只使用了机器指令中的一个子集，将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</li><li>中断：<ul><li>中断，外中断，来自CPU执行指令以外的事件的发生。（外设请求、人为干预）</li><li>异常，内中断，源自CPU执行指令内部的事件。（指令中断、硬件故障、软件中断）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统（operating-System，-OS）&quot;&gt;&lt;a href=&quot;#1-操作系统（operating-System，-OS）&quot; class=&quot;headerlink&quot; title=&quot;1 操作系统（operating System， OS）&quot;&gt;&lt;/a&gt;1 </summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:31:33.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="1-查询优化"><a href="#1-查询优化" class="headerlink" title="1 查询优化"></a>1 查询优化</h2><p>查询优化分为代数优化和物理优化</p><p>简单来说，代数优化是优化查询的次数，尽可能将选择操作先做。</p><p>物理优化，可以理解为建立索引。</p><h2 id="2-字符集"><a href="#2-字符集" class="headerlink" title="2 字符集"></a>2 字符集</h2><ol><li><p>查看字符集编码设置</p><p> <code>mysql&gt; show variables like &#39;%character%&#39;;</code></p></li><li><p>设置字符集编码</p><p> <code>mysql&gt; set names &#39;utf8&#39;;</code></p></li></ol><h2 id="3-大表优化"><a href="#3-大表优化" class="headerlink" title="3 大表优化"></a>3 大表优化</h2><p><a href="https://segmentfault.com/a/1190000006158186">https://segmentfault.com/a/1190000006158186</a></p><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><p>限定数据的范围</p><p> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p></li><li><p>读/写分离</p><p> 经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p>分区</p><ul><li><p>垂直分区</p><p>  根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>  简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p><p>  垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>  垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p></li><li><p>水平分区</p><p>  保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>  水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p>  水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p><p>  水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p>  下面补充一下数据库分片的两种常见方案：</p><ul><li>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库优化&quot;&gt;&lt;a href=&quot;#数据库优化&quot; class=&quot;headerlink&quot; title=&quot;数据库优化&quot;&gt;&lt;/a&gt;数据库优化&lt;/h1&gt;&lt;h2 id=&quot;1-查询优化&quot;&gt;&lt;a href=&quot;#1-查询优化&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
