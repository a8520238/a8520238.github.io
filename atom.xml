<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lgz_blog</title>
  
  <subtitle>Hey!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T12:46:40.765Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lgz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/28/java/Java%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/"/>
    <id>http://example.com/2021/02/28/java/Java%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</id>
    <published>2021-02-28T12:46:40.765Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的静态分派和动态分派"><a href="#Java的静态分派和动态分派" class="headerlink" title="Java的静态分派和动态分派"></a>Java的静态分派和动态分派</h1><p>由来：Class文件就在编译过程中，一切方法都只是符号引用，而不是实际地址（直接引用）。直到类加载时期，甚至到运行期间才能确定目标方法的直接引用。这个特性给Java带来了强大的动态扩展能力。</p><h2 id="1-解析"><a href="#1-解析" class="headerlink" title="1 解析"></a>1 解析</h2><ul><li>解析阶段将符号引用转换为直接引用</li><li>解析能成立的前提：方法在程序真正执行之前就有一个可确定的调用版本，并且这个调用版本在运行期是不可变的。也就是调用目标在编译期就要确定下来。</li><li>Java语言中符合”编译期可知，运行期不可变”，可以分为静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们不可能通过继承或别的方式重写其他版本，因此他们适合在类加载阶段进行解析。</li><li><strong>静态方法、私有方法、实例构造器、父类方法。这些方法称为非虚方法，它们在类加载的时候就会把符号引用解析为该方法的直接引用。与之相反，其他方法称为虚方法（除去final方法）。</strong></li></ul><h2 id="2-分派"><a href="#2-分派" class="headerlink" title="2 分派"></a>2 分派</h2><h3 id="2-1-静态分派"><a href="#2-1-静态分派" class="headerlink" title="2.1 静态分派"></a>2.1 静态分派</h3><p>可以将父类成为变量的静态类型，继承的子类为变量的实际类型。</p><p>静态类型和实际类型在程序中都可以发生一些变化。</p><p>区别：</p><ul><li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译器可知。</li><li>实际类型变化的结果在运行期才确定，编译器在编译期并不知道一个对象的实际类型是什么。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line">static abstract class Human&#123;</span><br><span class="line">&#125;</span><br><span class="line">static class Man extends Human&#123;</span><br><span class="line">&#125;</span><br><span class="line">static class Woman extends Human&#123;</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Human guy)&#123;</span><br><span class="line">System.out.println(&quot;hello,guy!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Man guy)&#123;</span><br><span class="line">System.out.println(&quot;hello,gentlemen!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Woman guy)&#123;</span><br><span class="line">System.out.println(&quot;hello,lady!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Human man&#x3D;new Man();</span><br><span class="line">Human woman&#x3D;new Woman();</span><br><span class="line">sayHello(man);</span><br><span class="line">sayHello(woman);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">hello,guy!</span><br><span class="line">hello,guy!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子说明：<strong>编译器在重载时是通过参数的静态类型而不是实际类型作为判定的依据</strong>。并且静态类型在编译期可知，因此，编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。<strong>换句话说因为该方法是重载。</strong> </p><blockquote><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用就是方法重载。</p></blockquote><h3 id="2-2-动态分派"><a href="#2-2-动态分派" class="headerlink" title="2.2 动态分派"></a>2.2 动态分派</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">static abstract class Human&#123;</span><br><span class="line">protected abstract void sayHello();</span><br><span class="line">&#125;</span><br><span class="line">static class Man extends Human&#123; </span><br><span class="line">@Override</span><br><span class="line">protected void sayHello() &#123; </span><br><span class="line">System.out.println(&quot;man say hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">static class Woman extends Human&#123; </span><br><span class="line">@Override</span><br><span class="line">protected void sayHello() &#123; </span><br><span class="line">System.out.println(&quot;woman say hello!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Human man&#x3D;new Man();</span><br><span class="line">Human woman&#x3D;new Woman();</span><br><span class="line">man.sayHello();</span><br><span class="line">woman.sayHello();</span><br><span class="line">man&#x3D;new Woman();</span><br><span class="line">man.sayHello(); </span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">man say hello!</span><br><span class="line">woman say hello!</span><br><span class="line">woman say hello!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面描述Java虚拟机是如何根据实际类型来分派方法执行版本:</p><ol><li>invokevirtual指令的多态查找过程</li></ol><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。</li><li>否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。</li></ul><ol start="2"><li>本质</li></ol><ul><li>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，<strong>所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上</strong>，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ul><ol start="3"><li>实际操作</li></ol><ul><li>为了保证性能，实际操作中不会出现对方法进行频繁的搜索。</li><li>对这种情况，最常用的”稳定优化“手段就是为类在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable），使用虚方法表索引来代替元数据查找以提高性能。</li><li>虚方法表：<ul><li>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实际入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实际版本的入口地址。</li><li>为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。</li><li>方法表一般在类加载阶段的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</li></ul></li><li>虚方法表中的实际指向是在运行时赋值是给出的，因为加载父类时，不知道真实指向。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java的静态分派和动态分派&quot;&gt;&lt;a href=&quot;#Java的静态分派和动态分派&quot; class=&quot;headerlink&quot; title=&quot;Java的静态分派和动态分派&quot;&gt;&lt;/a&gt;Java的静态分派和动态分派&lt;/h1&gt;&lt;p&gt;由来：Class文件就在编译过程中，一切方法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/02/28/java/java%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2021/02/28/java/java%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98/</id>
    <published>2021-02-28T12:46:40.765Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-堆中的对象内存"><a href="#Java-堆中的对象内存" class="headerlink" title="Java 堆中的对象内存"></a>Java 堆中的对象内存</h1><h2 id="1-java-中的对象指向问题"><a href="#1-java-中的对象指向问题" class="headerlink" title="1 java 中的对象指向问题"></a>1 java 中的对象指向问题</h2><h3 id="1-1-方法区指向堆"><a href="#1-1-方法区指向堆" class="headerlink" title="1.1 方法区指向堆"></a>1.1 方法区指向堆</h3><p><code>private static User user=new User();</code> </p><ul><li><p>引用变量user是静态的，所以存放在方法区中，而真实的user对象存放在堆中。所以，这就形成了方法区指向堆。</p></li><li><p>或者类变量是静态的，也会指向堆。</p></li><li><p>或者是final修饰的类常量。</p></li></ul><h3 id="1-2-虚拟机线程栈指向堆"><a href="#1-2-虚拟机线程栈指向堆" class="headerlink" title="1.2 虚拟机线程栈指向堆"></a>1.2 虚拟机线程栈指向堆</h3><p>类的方法中的属性存放在虚拟机栈的局部变量表 中，对象实例同样存在在堆中。</p><h2 id="2-堆中对象的实例的布局"><a href="#2-堆中对象的实例的布局" class="headerlink" title="2 堆中对象的实例的布局"></a>2 堆中对象的实例的布局</h2><h3 id="2-1-对象内存模型"><a href="#2-1-对象内存模型" class="headerlink" title="2.1 对象内存模型"></a>2.1 对象内存模型</h3><p>java 中的对象内存布局：</p><ul><li>对象头 Header<ul><li>mark word ： 8 字节</li><li>class pointer ： 未指针压缩时 8 字节，压缩后 4 字节</li><li>数组 length （数组对象特有）： 4 字节</li></ul></li><li>对象实例数据 Instance Data ：</li><li>对齐填充 Padding ： 填充为 8 字节的整数倍</li></ul><p><img src="http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/88CB4B6F16FA4A71A606DA0E62EC8BE5/9123" alt="java 中的对象内存布局"></p><h3 id="2-2-Object-obj-new-Object-占用的字节"><a href="#2-2-Object-obj-new-Object-占用的字节" class="headerlink" title="2.2 Object obj = new Object() 占用的字节"></a>2.2 Object obj = new Object() 占用的字节</h3><p>实例数据为空，mark word 占 8 字节，其他：</p><ul><li>若开启了类指针压缩 则 class pointer 占4字节，然后 padding 填充 4 字节</li><li>若没开启，则 class pointer 占 8 字节，padding 不填充</li></ul><p>所以，一共占用 16 字节。</p><h2 id="3-堆中对象访问"><a href="#3-堆中对象访问" class="headerlink" title="3 堆中对象访问"></a>3 堆中对象访问</h2><h3 id="3-1-句柄访问"><a href="#3-1-句柄访问" class="headerlink" title="3.1 句柄访问"></a>3.1 句柄访问</h3><p>堆中划分出一块空间来存放 句柄池 , 即 方法区/栈帧 中的对象引用是存放的句柄地址，通过句柄池再在堆中查找对象的实际地址。</p><p><img src="http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/7EA3C812D0484F4583883EAF2DCE4445/2708" alt="句柄访问"></p><h3 id="3-2-直接指针访问-hot-spot"><a href="#3-2-直接指针访问-hot-spot" class="headerlink" title="3.2 直接指针访问 (hot spot)"></a>3.2 直接指针访问 (hot spot)</h3><p>堆中直接存放对象的实例数据，即 方法区/栈帧 中的对象引用直接指向堆实例的地址。</p><p><img src="http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/0F7750F4ACE14A5BB5B93239A0203931/2707" alt="直接指针访问"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-堆中的对象内存&quot;&gt;&lt;a href=&quot;#Java-堆中的对象内存&quot; class=&quot;headerlink&quot; title=&quot;Java 堆中的对象内存&quot;&gt;&lt;/a&gt;Java 堆中的对象内存&lt;/h1&gt;&lt;h2 id=&quot;1-java-中的对象指向问题&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java负数和浮点数</title>
    <link href="http://example.com/2021/02/27/java/java%E8%B4%9F%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>http://example.com/2021/02/27/java/java%E8%B4%9F%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h1><ol><li>负数是按照补码存储，运算也是按照补码运算<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; -3;</span><br><span class="line">System.out.println(&quot;二进制输出&quot;+Integer.toBinaryString(a));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;八进制输出&quot;+Integer.toOctalString(a));</span><br><span class="line">System.out.printf(&quot;八进制输出&quot;+&quot;%010o\n&quot;,a);</span><br><span class="line">&#x2F;&#x2F;按10位十六进制输出，向右靠齐，左边用0补齐</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二进制输出11111111111111111111111111111101</span><br><span class="line">八进制输出37777777775</span><br><span class="line">八进制输出37777777775</span><br></pre></td></tr></table></figure>java负数补码保存，所以对java负数进行&amp;操作时，其实是对补码进行&amp;操作</li></ol><ul><li>左右移动的时候，高位补1， 低位补0</li></ul><ol start="2"><li>1 &lt;&lt; -1</li></ol><ul><li>int 是32位，左移负数，意味着与0x1f与，也就是左移32-1位</li></ul><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><ol><li>float是单精度类型,精度是8位有效数字，取值范围是10的-38次方到10的38次方，float占用4个字节的存储空间</li><li>double是双精度类型，精度是17位有效数字，取值范围是10的-308次方到10的308次方，double占用8个字节的存储空间</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负数&quot;&gt;&lt;a href=&quot;#负数&quot; class=&quot;headerlink&quot; title=&quot;负数&quot;&gt;&lt;/a&gt;负数&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;负数是按照补码存储，运算也是按照补码运算&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="javaSE" scheme="http://example.com/categories/javaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://example.com/2021/02/27/%E5%B9%B6%E5%8F%91/15%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2021/02/27/%E5%B9%B6%E5%8F%91/15%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="15-线程池"><a href="#15-线程池" class="headerlink" title="15 线程池"></a>15 线程池</h1><h2 id="15-1-类结构"><a href="#15-1-类结构" class="headerlink" title="15.1 类结构"></a>15.1 类结构</h2><p><img src="http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/BA9AEA380C154DECA51845503BA23779/11588"></p><p><img src="http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/7724EC0F6ABB4ACBBEB4CC9D759642D0/11593"></p><h3 id="15-1-1-线程池的创建方法"><a href="#15-1-1-线程池的创建方法" class="headerlink" title="15.1.1 线程池的创建方法"></a>15.1.1 线程池的创建方法</h3><ol><li>通过Executor框架的工具类Executors来实现，生成ThreadPoolExecutor实例的方法</li></ol><ul><li>方法源码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建使用单个线程的线程池</span><br><span class="line">        ExecutorService es1 &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            es1.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;正在执行任务&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建使用固定线程数的线程池</span><br><span class="line">        ExecutorService es2 &#x3D; Executors.newFixedThreadPool(3);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            es2.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;正在执行任务&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个会根据需要创建新线程的线程池</span><br><span class="line">        ExecutorService es3 &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            es3.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;正在执行任务&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建拥有固定线程数量的定时线程任务的线程池</span><br><span class="line">        ScheduledExecutorService es4 &#x3D; Executors.newScheduledThreadPool(2);</span><br><span class="line">        System.out.println(&quot;时间：&quot; + System.currentTimeMillis());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            es4.schedule(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(&quot;时间：&quot;+System.currentTimeMillis()+&quot;--&quot;+Thread.currentThread().getName() + &quot;正在执行任务&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,3, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建只有一个线程的定时线程任务的线程池</span><br><span class="line">        ScheduledExecutorService es5 &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        System.out.println(&quot;时间：&quot; + System.currentTimeMillis());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            es5.schedule(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(&quot;时间：&quot;+System.currentTimeMillis()+&quot;--&quot;+Thread.currentThread().getName() + &quot;正在执行任务&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,3, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>阿里巴巴手册强制推荐不使用Executors类创建，原因：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。</li></ol><ul><li>正确创建方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static ExecutorService executor &#x3D; new ThreadPoolExecutor(10, 10,</span><br><span class="line">        60L, TimeUnit.SECONDS,</span><br><span class="line">        new ArrayBlockingQueue(10));</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>几点说明：</li></ol><ul><li>线程池支持获取线程执行的结果，在使用过程中，我们向线程池中提交任务（task）,是一个FutureTask类，这个类实现了RunnableFuture接口，该接口继承Future和Runnable接口。</li></ul><h2 id="15-2-Executor接口"><a href="#15-2-Executor接口" class="headerlink" title="15.2 Executor接口"></a>15.2 Executor接口</h2><ul><li>execute方法代表提交一个任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>正常启动线程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable()&#123;</span><br><span class="line">  &#x2F;&#x2F; do something</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>使用Executor<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor &#x3D; anExecutor;</span><br><span class="line">executor.execute(new RunnableTask1());</span><br><span class="line">executor.execute(new RunnableTask2());</span><br></pre></td></tr></table></figure></li><li>需要线程池同步执行每一个任务，实现如下接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DirectExecutor implements Executor &#123;</span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        r.run();&#x2F;&#x2F; 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，实现如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ThreadPerTaskExecutor implements Executor &#123;</span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        new Thread(r).start();  &#x2F;&#x2F; 每个任务都用一个新的线程来执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class SerialExecutor implements Executor &#123;</span><br><span class="line">    &#x2F;&#x2F; 任务队列</span><br><span class="line">    final Queue&lt;Runnable&gt; tasks &#x3D; new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    &#x2F;&#x2F; 这个才是真正的执行器</span><br><span class="line">    final Executor executor;</span><br><span class="line">    &#x2F;&#x2F; 当前正在执行的任务</span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化的时候，指定执行器</span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        this.executor &#x3D; executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span><br><span class="line">    public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">        tasks.offer(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (active &#x3D;&#x3D; null) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized void scheduleNext() &#123;</span><br><span class="line">        if ((active &#x3D; tasks.poll()) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 具体的执行转给真正的执行器 executor</span><br><span class="line">            executor.execute(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-3-ExecutorService"><a href="#15-3-ExecutorService" class="headerlink" title="15.3 ExecutorService"></a>15.3 ExecutorService</h2></li></ul><ol><li>定义方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor &#x3D; Executors.newFixedThreadPool(args...);</span><br><span class="line">ExecutorService executor &#x3D; Executors.newCachedThreadPool(args...);</span><br></pre></td></tr></table></figure></li><li>接口方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span><br><span class="line">    &#x2F;&#x2F; 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 线程池是否已关闭</span><br><span class="line">    boolean isShutdown();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span><br><span class="line">    &#x2F;&#x2F; 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span><br><span class="line">    boolean isTerminated();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 等待所有任务完成，并设置超时时间</span><br><span class="line">    &#x2F;&#x2F; 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span><br><span class="line">    &#x2F;&#x2F; 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span><br><span class="line">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提交一个 Callable 任务</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span><br><span class="line">    &#x2F;&#x2F; 因为 Runnable 的 run 方法本身并不返回任何东西</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提交一个 Runnable 任务</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有任务，返回 Future 类型的一个 list</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 也是执行所有任务，但是这里设置了超时时间</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span><br><span class="line">    &#x2F;&#x2F; 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                    long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p></blockquote></li></ol><p>使用方法举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            executorService.execute(new MyRunnable(i));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-FutureTask"><a href="#15-4-FutureTask" class="headerlink" title="15.4 FutureTask"></a>15.4 FutureTask</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future      Runnable</span><br><span class="line">   \           &#x2F;</span><br><span class="line">    \         &#x2F;</span><br><span class="line">   RunnableFuture</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">      FutureTask</span><br><span class="line"></span><br><span class="line">FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，</span><br><span class="line">所以每个 Runnable 通常都先包装成 FutureTask，</span><br><span class="line">然后调用 executor.execute(Runnable command) 将其提交给线程池</span><br></pre></td></tr></table></figure><ul><li>Runnable的run方法没有返回值，可通过下面的方法在submit中指定第二个参数作为返回值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></pre></td></tr></table></figure></li><li>也可以使用Callable，它和Runnable的区别在于run没有返回值，而Callable的call方法有返回值，同时，如果运行出现异常，call方法会抛出异常。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-4-1-future的作用"><a href="#15-4-1-future的作用" class="headerlink" title="15.4.1 future的作用"></a>15.4.1 future的作用</h3>Future表示一个可能还没有完成的异步任务的结果<br>示例如下，获取线程结果的写法</li></ul><ol><li>不用future的写法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BumThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000*3);</span><br><span class="line">System.out.println(&quot;包子准备完毕&quot;);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public class ColdDishThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">System.out.println(&quot;凉菜准备完毕&quot;);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等凉菜 -- 必须要等待返回的结果，所以要调用join方法</span><br><span class="line">Thread t1 &#x3D; new ColdDishThread();</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等包子 -- 必须要等待返回的结果，所以要调用join方法</span><br><span class="line">Thread t2 &#x3D; new BumThread();</span><br><span class="line">t2.start();</span><br><span class="line">t2.join();</span><br><span class="line"></span><br><span class="line">long end &#x3D; System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;准备完毕时间：&quot;+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>采用future写法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等凉菜 </span><br><span class="line">Callable ca1 &#x3D; new Callable()&#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public String call() throws Exception &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return &quot;凉菜准备完毕&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;String&gt; ft1 &#x3D; new FutureTask&lt;String&gt;(ca1);</span><br><span class="line">new Thread(ft1).start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等包子 -- 必须要等待返回的结果，所以要调用join方法</span><br><span class="line">Callable ca2 &#x3D; new Callable()&#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public Object call() throws Exception &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000*3);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return &quot;包子准备完毕&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;String&gt; ft2 &#x3D; new FutureTask&lt;String&gt;(ca2);</span><br><span class="line">new Thread(ft2).start();</span><br><span class="line"></span><br><span class="line">System.out.println(ft1.get());</span><br><span class="line">System.out.println(ft2.get());</span><br><span class="line"></span><br><span class="line">long end &#x3D; System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;准备完毕时间：&quot;+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="15-5-AbstractExecutorService"><a href="#15-5-AbstractExecutorService" class="headerlink" title="15.5 AbstractExecutorService"></a>15.5 AbstractExecutorService</h2><p>AbstractExecutorService抽象类实现了Executor接口。</p><ul><li>需要获取结果(FutureTask),用submit方法，不需要获取结果，可以用execute方法。</li><li><T> Future<T>submit(Callable<T> task)， 第一个<T>说明这是一个泛型方法， Future<T>表示submit方法返回的类型为泛型接口类型</li><li>源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span><br><span class="line">    &#x2F;&#x2F; 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span><br><span class="line">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">        return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">        return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提交任务</span><br><span class="line">    public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 1\. 将任务包装成 FutureTask</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">        &#x2F;&#x2F; 2\. 交给执行器执行，execute 方法由具体的子类来实现</span><br><span class="line">        &#x2F;&#x2F; 前面也说了，FutureTask 间接实现了Runnable 接口。</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 1\. 将任务包装成 FutureTask</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);</span><br><span class="line">        &#x2F;&#x2F; 2\. 交给执行器执行</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 1\. 将任务包装成 FutureTask</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">        &#x2F;&#x2F; 2\. 交给执行器执行</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span><br><span class="line">    &#x2F;&#x2F; 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span><br><span class="line">    &#x2F;&#x2F; 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span><br><span class="line">    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                            boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 任务数</span><br><span class="line">        int ntasks &#x3D; tasks.size();</span><br><span class="line">        if (ntasks &#x3D;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures&#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span><br><span class="line">        &#x2F;&#x2F; 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span><br><span class="line">        &#x2F;&#x2F; 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs &#x3D;</span><br><span class="line">            new ExecutorCompletionService&lt;T&gt;(this);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span><br><span class="line">            ExecutionException ee &#x3D; null;</span><br><span class="line">            long lastTime &#x3D; timed ? System.nanoTime() : 0;</span><br><span class="line">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it &#x3D; tasks.iterator();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            &#x2F;&#x2F; 提交了一个任务，所以任务数量减 1</span><br><span class="line">            --ntasks;</span><br><span class="line">            &#x2F;&#x2F; 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span><br><span class="line">            int active &#x3D; 1;</span><br><span class="line"></span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                &#x2F;&#x2F; ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span><br><span class="line">                &#x2F;&#x2F; BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span><br><span class="line">                Future&lt;T&gt; f &#x3D; ecs.poll();</span><br><span class="line">                &#x2F;&#x2F; 为 null，说明刚刚提交的第一个线程还没有执行完成</span><br><span class="line">                &#x2F;&#x2F; 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span><br><span class="line">                if (f &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    if (ntasks &gt; 0) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span><br><span class="line">                    &#x2F;&#x2F; 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span><br><span class="line">                    &#x2F;&#x2F; 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 2018-02-23 感谢读者 newmicro 的 comment，</span><br><span class="line">                    &#x2F;&#x2F;  这里的 active &#x3D;&#x3D; 0，说明所有的任务都执行失败，那么这里是 for 循环出口</span><br><span class="line">                    else if (active &#x3D;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    &#x2F;&#x2F; 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span><br><span class="line">                    else if (timed) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 带等待的 poll 方法</span><br><span class="line">                        f &#x3D; ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        &#x2F;&#x2F; 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span><br><span class="line">                        if (f &#x3D;&#x3D; null)</span><br><span class="line">                            throw new TimeoutException();</span><br><span class="line">                        long now &#x3D; System.nanoTime();</span><br><span class="line">                        nanos -&#x3D; now - lastTime;</span><br><span class="line">                        lastTime &#x3D; now;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span><br><span class="line">                    &#x2F;&#x2F; take() 方法会阻塞，直到有元素返回，说明有任务结束了</span><br><span class="line">                    else</span><br><span class="line">                        f &#x3D; ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * 我感觉上面这一段并不是很好理解，这里简单说下。</span><br><span class="line">                 * 1\. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span><br><span class="line">                 *     那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span><br><span class="line">                 * 2\. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”</span><br><span class="line">                       这件事情上</span><br><span class="line">                 * 3\. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，</span><br><span class="line">                       等待获取第一个执行结果</span><br><span class="line">                 * 4\. 如果所有的任务都执行失败，也就是说 future 都返回了，</span><br><span class="line">                       但是 f.get() 抛出异常，那么从 active &#x3D;&#x3D; 0 分支出去(感谢 newmicro 提出)</span><br><span class="line">                         &#x2F;&#x2F; 当然，这个需要看下面的 if 分支。</span><br><span class="line">                 *&#x2F;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 有任务结束了</span><br><span class="line">                if (f !&#x3D; null) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 返回执行结果，如果有异常，都包装成 ExecutionException</span><br><span class="line">                        return f.get();</span><br><span class="line">                    &#125; catch (ExecutionException eex) &#123;</span><br><span class="line">                        ee &#x3D; eex;</span><br><span class="line">                    &#125; catch (RuntimeException rex) &#123;</span><br><span class="line">                        ee &#x3D; new ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#x2F;&#x2F; 注意看 for 循环的范围，一直到这里</span><br><span class="line"></span><br><span class="line">            if (ee &#x3D;&#x3D; null)</span><br><span class="line">                ee &#x3D; new ExecutionException();</span><br><span class="line">            throw ee;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 方法退出之前，取消其他的任务</span><br><span class="line">            for (Future&lt;T&gt; f : futures)</span><br><span class="line">                f.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return doInvokeAny(tasks, false, 0);</span><br><span class="line">        &#125; catch (TimeoutException cannotHappen) &#123;</span><br><span class="line">            assert false;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                           long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        return doInvokeAny(tasks, true, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的任务，返回任务结果。</span><br><span class="line">    &#x2F;&#x2F; 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span><br><span class="line">    &#x2F;&#x2F; 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span><br><span class="line">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 这个很简单</span><br><span class="line">            for (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                &#x2F;&#x2F; 包装成 FutureTask</span><br><span class="line">                RunnableFuture&lt;T&gt; f &#x3D; newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                &#x2F;&#x2F; 提交任务</span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            for (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                if (!f.isDone()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 这是一个阻塞方法，直到获取到值，或抛出了异常</span><br><span class="line">                        &#x2F;&#x2F; 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span><br><span class="line">                        &#x2F;&#x2F; 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; catch (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; catch (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span><br><span class="line">            &#x2F;&#x2F; 这个方法返回是真正的返回，任务都结束了</span><br><span class="line">            return futures;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 为什么要这个？就是上面说的有异常的情况</span><br><span class="line">            if (!done)</span><br><span class="line">                for (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 带超时的 invokeAll，我们找不同吧</span><br><span class="line">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null || unit &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            long lastTime &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Future&lt;T&gt;&gt; it &#x3D; futures.iterator();</span><br><span class="line">            &#x2F;&#x2F; 每提交一个任务，检测一次是否超时</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                execute((Runnable)(it.next()));</span><br><span class="line">                long now &#x3D; System.nanoTime();</span><br><span class="line">                nanos -&#x3D; now - lastTime;</span><br><span class="line">                lastTime &#x3D; now;</span><br><span class="line">                &#x2F;&#x2F; 超时</span><br><span class="line">                if (nanos &lt;&#x3D; 0)</span><br><span class="line">                    return futures;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                if (!f.isDone()) &#123;</span><br><span class="line">                    if (nanos &lt;&#x3D; 0)</span><br><span class="line">                        return futures;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span><br><span class="line">                        &#x2F;&#x2F; 因为上面其实已经用掉了一些时间了</span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; catch (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; catch (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">                        return futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    long now &#x3D; System.nanoTime();</span><br><span class="line">                    nanos -&#x3D; now - lastTime;</span><br><span class="line">                    lastTime &#x3D; now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            return futures;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!done)</span><br><span class="line">                for (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-6-ThreadPoolExecutor"><a href="#15-6-ThreadPoolExecutor" class="headerlink" title="15.6 ThreadPoolExecutor"></a>15.6 ThreadPoolExecutor</h2></li><li>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</li><li>定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。</li><li>线程池中的构件如下图<br><img src="http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/3BEF41BF84C1400194353C861C56A56B/11710"></li></ul><ol><li>通常用Executors这个工具类快速创建一个线程池，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最后会导向这个方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#x2F;&#x2F; 这几个参数都是必须要有的</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>corePoolSize: 核心线程数</li><li>maximumPoolSize: 最大线程数，线程池允许创建的最大线程数。</li><li>workQueue：任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</li><li>keepAliveTime：空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 allowCoreThreadTimeOut(true)使核心线程数内的线程也可以被回收。</li><li>threadFactory：用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</li><li>handler: 当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</li></ul><ol start="2"><li>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span><br><span class="line">&#x2F;&#x2F; 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 000 11111111111111111111111111111</span><br><span class="line">&#x2F;&#x2F; 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1&#x3D;536870911</span><br><span class="line">&#x2F;&#x2F; 以我们现在计算机的实际情况，这个数量还是够用的</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们说了，线程池的状态存放在高 3 位中</span><br><span class="line">&#x2F;&#x2F; 运算结果为 111跟29个0：111 00000000000000000000000000000</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 000 00000000000000000000000000000</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 001 00000000000000000000000000000</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 010 00000000000000000000000000000</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 011 00000000000000000000000000000</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">&#x2F;&#x2F; 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Bit field accessors that don&#39;t require unpacking ctl.</span><br><span class="line"> * These depend on the bit layout and on workerCount being never negative.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">private static boolean runStateLessThan(int c, int s) &#123;</span><br><span class="line">    return c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean runStateAtLeast(int c, int s) &#123;</span><br><span class="line">    return c &gt;&#x3D; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isRunning(int c) &#123;</span><br><span class="line">    return c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li><li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个<blockquote><p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p></blockquote></li><li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li><li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li><li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li><li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后<blockquote><p>任务是 Runnable（内部变量名叫 task 或 command），线程是 Worker。</p></blockquote></li></ul><ol start="3"><li>Worker也就是实际做任务的线程，使用的是AQS<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">    extends AbstractQueuedSynchronizer</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6138294804551838833L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个是真正的线程，任务靠你啦</span><br><span class="line">    final Thread thread;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span><br><span class="line">    &#x2F;&#x2F; 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span><br><span class="line">    &#x2F;&#x2F; 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">        this.firstTask &#x3D; firstTask;</span><br><span class="line">        &#x2F;&#x2F; 调用 ThreadFactory 来创建一个新的线程</span><br><span class="line">        this.thread &#x3D; getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里调用了外部类的 runWorker 方法</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...&#x2F;&#x2F; 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>核心方法execute<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        &#x2F;&#x2F; 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        &#x2F;&#x2F; 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        &#x2F;* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        &#x2F;&#x2F; 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        &#x2F;&#x2F; 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    &#x2F;&#x2F; 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    &#x2F;&#x2F; 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里面addWorker(Runnable firstTask,boolean core)方法很重要<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span><br><span class="line">&#x2F;&#x2F; 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界限，也就说创建这个线程的时候，</span><br><span class="line">&#x2F;&#x2F;         如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span><br><span class="line">&#x2F;&#x2F;         如果是 false，代表使用最大线程数 maximumPoolSize 作为界限</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这个非常不好理解</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span><br><span class="line">        &#x2F;&#x2F; 1\. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span><br><span class="line">        &#x2F;&#x2F; 2\. firstTask !&#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 3\. workQueue.isEmpty()</span><br><span class="line">        &#x2F;&#x2F; 简单分析下：</span><br><span class="line">        &#x2F;&#x2F; 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span><br><span class="line">        &#x2F;&#x2F; 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span><br><span class="line">        &#x2F;&#x2F; 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span><br><span class="line">        &#x2F;&#x2F; 这是因为 SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span><br><span class="line">            &#x2F;&#x2F; 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            &#x2F;&#x2F; 由于有并发，重新再读取一下 ctl</span><br><span class="line">            c &#x3D; ctl.get();</span><br><span class="line">            &#x2F;&#x2F; 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span><br><span class="line">            &#x2F;&#x2F; 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span><br><span class="line">            &#x2F;&#x2F; 那么需要回到外层的for循环</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* </span><br><span class="line">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span><br><span class="line">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; worker 是否已经启动</span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 是否已将这个 worker 添加到 workers 这个 HashSet 中</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        &#x2F;&#x2F; 把 firstTask 传给 worker 的构造方法</span><br><span class="line">        w &#x3D; new Worker(firstTask);</span><br><span class="line">        &#x2F;&#x2F; 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span><br><span class="line">            &#x2F;&#x2F; 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                int c &#x3D; ctl.get();</span><br><span class="line">                int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span><br><span class="line">                &#x2F;&#x2F; 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; worker 里面的 thread 可不能是已经启动的</span><br><span class="line">                    if (t.isAlive())</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    &#x2F;&#x2F; 加到 workers 这个 HashSet 中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    &#x2F;&#x2F; largestPoolSize 用于记录 workers 中的个数的最大值</span><br><span class="line">                    &#x2F;&#x2F; 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 添加成功的话，启动这个线程</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                &#x2F;&#x2F; 启动线程</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回线程是否启动成功</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>下面是addWorkFailed的处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; workers 中删除掉相应的 worker</span><br><span class="line">&#x2F;&#x2F; workCount 减 1</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w !&#x3D; null)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        &#x2F;&#x2F; rechecks for termination, in case the existence of this worker was holding up termination</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>worker中的线程start后，其run方法会调用runWorker方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Worker 类的 run() 方法</span><br><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span><br><span class="line">&#x2F;&#x2F; 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F; 该线程的第一个任务(如果有的话)</span><br><span class="line">    Runnable task &#x3D; w.firstTask;</span><br><span class="line">    w.firstTask &#x3D; null;</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环调用 getTask 获取任务</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();          </span><br><span class="line">            &#x2F;&#x2F; 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 这是一个钩子方法，留给需要的子类实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 到这里终于可以执行任务了</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 这里不允许抛出 Throwable，所以转换为 Error</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 置空 task，准备 getTask 获取下一个任务</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 累加完成的任务数</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                &#x2F;&#x2F; 释放掉 worker 的独占锁</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果到这里，需要执行线程关闭：</span><br><span class="line">        &#x2F;&#x2F; 1\. 说明 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭</span><br><span class="line">        &#x2F;&#x2F; 2\. 任务执行过程中发生了异常</span><br><span class="line">        &#x2F;&#x2F; 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span><br><span class="line">        &#x2F;&#x2F; 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span><br><span class="line">        &#x2F;&#x2F; 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>接下来是getTask()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此方法有三种可能：</span><br><span class="line">&#x2F;&#x2F; 1\. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span><br><span class="line">&#x2F;&#x2F;      它们会一直等待任务</span><br><span class="line">&#x2F;&#x2F; 2\. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span><br><span class="line">&#x2F;&#x2F; 3\. 如果发生了以下条件，此方法必须返回 null:</span><br><span class="line">&#x2F;&#x2F;    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span><br><span class="line">&#x2F;&#x2F;    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span><br><span class="line">&#x2F;&#x2F;    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line">        &#x2F;&#x2F; 两种可能</span><br><span class="line">        &#x2F;&#x2F; 1\. rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; workQueue.isEmpty()</span><br><span class="line">        &#x2F;&#x2F; 2\. rs &gt;&#x3D; STOP</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            &#x2F;&#x2F; CAS 操作，减少工作线程数</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean timed;      &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line">            &#x2F;&#x2F; 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span><br><span class="line">            timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span><br><span class="line">            &#x2F;&#x2F; 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span><br><span class="line">            &#x2F;&#x2F; 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span><br><span class="line">            &#x2F;&#x2F;    换句话说，返回 null 意味着关闭线程。</span><br><span class="line">            &#x2F;&#x2F; 那是因为有可能开发者调用了 setMaximumPoolSize() 将线程池的 maximumPoolSize 调小了，那么多余的 Worker 就需要被关闭</span><br><span class="line">            if (wc &lt;&#x3D; maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                break;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">            &#x2F;&#x2F; compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; wc &lt;&#x3D; maximumPoolSize 同时没有超时</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 到 workQueue 中获取任务</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果此 worker 发生了中断，采取的方案是重试</span><br><span class="line">            &#x2F;&#x2F; 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法。</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span><br><span class="line">            &#x2F;&#x2F; 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span><br><span class="line">            timedOut &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>回到execute(Runnable command)方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        &#x2F;&#x2F; 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        &#x2F;&#x2F; 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        &#x2F;* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        &#x2F;&#x2F; 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        &#x2F;&#x2F; 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    &#x2F;&#x2F; 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    &#x2F;&#x2F; 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>拒绝策略：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行拒绝策略</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public CallerRunsPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不管怎样，直接抛出 RejectedExecutionException 异常</span><br><span class="line">&#x2F;&#x2F; 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span><br><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public AbortPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                             &quot; rejected from &quot; +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不做任何处理，直接忽略掉这个任务</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public DiscardPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个相对霸道一点，如果线程池没有被关闭的话，</span><br><span class="line">&#x2F;&#x2F; 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public DiscardOldestPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-6-Executors"><a href="#15-6-Executors" class="headerlink" title="15.6 Executors"></a>15.6 Executors</h2></li></ol><ul><li>Executors是个工具类，所有方法都是static的</li><li>生成一个固定大小的线程池<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这里，最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</li></ul><p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p><ul><li>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</li></ul><p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>java 线程池有哪些关键属性</li></ol><ul><li>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</li><li>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</li><li>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。</li><li>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</li><li>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有<strong>抛出 RejectedExecutionException 异常</strong>、<strong>忽略任务</strong>、<strong>使用提交任务的线程来执行此任务</strong>和<strong>将队列中等待最久的任务删除，然后提交此任务</strong>这四种策略，默认为抛出异常。</li></ul><ol start="2"><li>线程池中线程创建的时机</li></ol><ul><li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li><li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li><li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。<blockquote><p>核心线程不会停止，非核心到达keepAliveTime后销毁<br>如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。因为后面的任务直接往队列塞就行了，此时 maximumPoolSize 参数就没有什么意义。</p></blockquote></li></ul><ol start="3"><li>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</li></ol><ul><li>见上文Executors</li></ul><ol start="4"><li>任务执行过程中发生异常怎么处理？</li></ol><ul><li>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</li></ul><ol start="5"><li>什么时候会执行拒绝策略？</li></ol><ul><li>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li><li>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;15-线程池&quot;&gt;&lt;a href=&quot;#15-线程池&quot; class=&quot;headerlink&quot; title=&quot;15 线程池&quot;&gt;&lt;/a&gt;15 线程池&lt;/h1&gt;&lt;h2 id=&quot;15-1-类结构&quot;&gt;&lt;a href=&quot;#15-1-类结构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="java并发编程" scheme="http://example.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql底层架构</title>
    <link href="http://example.com/2021/02/27/Mysql%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2021/02/27/Mysql%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL架构"><a href="#1-MySQL架构" class="headerlink" title="1 MySQL架构"></a>1 MySQL架构</h1><p><a href="https://www.itzhai.com/articles/insight-into-the-underlying-architecture-of-mysql-buffer-and-disk.html">Mysql底层架构</a></p><p><a href="https://www.jb51.net/article/101062.htm">函数sync、fsync与fdatasync的总结整理</a></p><p><a href="https://www.jianshu.com/p/8991cbca3854">覆盖索引与回表</a></p><p><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">Doublewrite Buffer与redo log</a></p><p><a href="https://www.cnblogs.com/better-farther-world2099/p/9290966.html">InnoDB事务日志（redo log 和 undo log）详解</a></p><ol><li><p>相关概念：</p><ul><li>内存结构： buffer pool、log buffer、change buffer, buffer pool的页淘汰机制是怎样的</li><li>磁盘结构：系统表结构、独立表空间、通用表空间、undo表空间、redo log;</li></ul></li><li><p>为什么MySQL使用B+树？</p><ul><li>哈希表虽然可以提供O(1)的单行数据操作性能，但却不能很好的支持排序和范围查找，会导致全表扫描；</li><li>B树可以再非叶子节点存储数据，但是这可能会导致查询连续数据的时候增加更多的I/O操作；</li><li>而B+树数据都存放在叶子节点，叶子节点通过指针相互连接，可以减少顺序遍历时产生的额外随机I/O</li></ul></li><li><p>为什么使用自增主键</p><ul><li>自增主键的插入是递增顺序插入的，每次添加记录都是追加的，不涉及到记录的挪动，不会触发叶子节点的分裂，而一般业务字段做主键，往往都不是有序插入的，写成本比较高，所以我们更倾向于使用自增字段作为主键。</li></ul></li><li><p>聚集索引</p><ul><li>当在表上面定义了PRIMARY KEY之后，InnoDB会把它作为聚集索引。</li><li>如果您没有为表定义PRIMARY KEY，则MySQL会找到第一个不带null值的UNIQUE索引，并其用作聚集索引；</li><li>如果表没有PRIMARY KEY或没有合适的UNIQUE索引，则InnoDB 内部会生成一个隐藏的聚集索引GEN_CLUST_INDEX，作为行ID，行ID是一个6字节的字段，随着数据的插入而自增。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MySQL架构&quot;&gt;&lt;a href=&quot;#1-MySQL架构&quot; class=&quot;headerlink&quot; title=&quot;1 MySQL架构&quot;&gt;&lt;/a&gt;1 MySQL架构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.itzhai.com/articles/i</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://example.com/2021/02/27/Mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/02/27/Mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><p>Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。</p><p>哈希索引对应哈希表，InnoDB BTree 对应 B+ Tree</p><p><a href="https://www.cnblogs.com/l199616j/p/11232392.html">Mysql索引详解</a></p><h2 id="1-MyISAM-与-InnoDB-Index的区别"><a href="#1-MyISAM-与-InnoDB-Index的区别" class="headerlink" title="1 MyISAM 与 InnoDB Index的区别"></a>1 MyISAM 与 InnoDB Index的区别</h2><ul><li>MyISAMl（非聚集索引）: B+ 树叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li><li>InnoDB(聚集索引), 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></li><li>聚集索引适用的场合：<ul><li>包含大量非重复值的列。</li><li>使用下列运算符返回一个范围值的查询：BETWEEN、&gt;、&gt;=、&lt; 和 &lt;=。</li><li>被连续访问的列。</li><li>返回大型结果集的查询。</li><li>经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。</li><li>OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。</li></ul></li></ul><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/3D230F580DE94664934DB386CE5D48C8/3566" alt="应用场景"></p><p><a href="https://blog.csdn.net/alexdamiao/article/details/51934917">MYSQL索引：对聚簇索引和非聚簇索引的认识</a></p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2 索引"></a>2 索引</h2><ul><li>索引：索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li></ul><h3 id="2-1-索引的优点"><a href="#2-1-索引的优点" class="headerlink" title="2.1 索引的优点"></a>2.1 索引的优点</h3><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><blockquote><p>使用索引的原因：访问磁盘块时，若访问非键字段，需要遍历表空间 On。添加所用可以使用二分查找，降低到logN</p></blockquote><h3 id="2-2-索引的缺点"><a href="#2-2-索引的缺点" class="headerlink" title="2.2 索引的缺点"></a>2.2 索引的缺点</h3><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h3 id="2-3-索引的使用"><a href="#2-3-索引的使用" class="headerlink" title="2.3 索引的使用"></a>2.3 索引的使用</h3><p>添加：</p><ol><li>INDEX indexName (Field_name(length))</li><li>ALTER TABLE table_name ADD INDEX index_name (column_list) (普通索引)</li><li>CREATE INDEX index_name ON table_name (column_list)</li><li>CREATE UNIQUE INDEX index_name ON table_name (column_list) (UNIQUE索引)</li></ol><p>删除：</p><ol><li>DROP INDEX [indexName] ON [table_name];</li><li>alter table [table_name] drop index [index_name] ;</li><li>alter table [table_name] drop primary key ;</li></ol><blockquote><p>如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p></blockquote><p>查看：</p><ol><li>SHOW INDEX FROM [table_name];</li><li>show keys from [table_name];</li></ol><h1 id="2-4-针对存储性质的讲解"><a href="#2-4-针对存储性质的讲解" class="headerlink" title="2.4 针对存储性质的讲解"></a>2.4 针对存储性质的讲解</h1><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2 id="3-索引的数据结构B-Tree和B-Tree"><a href="#3-索引的数据结构B-Tree和B-Tree" class="headerlink" title="3 索引的数据结构B-Tree和B+Tree"></a>3 索引的数据结构B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.</p><h3 id="3-1-B树"><a href="#3-1-B树" class="headerlink" title="3.1 B树"></a>3.1 B树</h3><p>B树也就是二叉搜索树，也有说法是B树与B-树等价</p><p><a href="https://www.jianshu.com/p/1775b4ff123a">B树和B-树的剖析（建树过程）</a></p><h3 id="3-2-B-Tree"><a href="#3-2-B-Tree" class="headerlink" title="3.2 B-Tree"></a>3.2 B-Tree</h3><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/8F052C172C834AFC8BFF711812E724BE/3601" alt="B-树存储"><br><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606" alt="B-树键结构"></p><p>B-树的键区间为开区间，非叶子节点可结束</p><h3 id="3-3-B-Tree-Mysql"><a href="#3-3-B-Tree-Mysql" class="headerlink" title="3.3 B+Tree(Mysql)"></a>3.3 B+Tree(Mysql)</h3><ol><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的K个关键字。</li><li>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ol><p><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/DB87125DAF1E40B8B1FFFDD842163FD3/3597" alt="B+树存储"><br><img src="http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606" alt="B+树键结构"></p><h4 id="3-3-1-B-树的搜索方法"><a href="#3-3-1-B-树的搜索方法" class="headerlink" title="3.3.1 B+树的搜索方法"></a>3.3.1 B+树的搜索方法</h4><ul><li>一种是按叶节点自己拉起的链表顺序搜索。</li><li>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</li></ul><h3 id="3-4-B树和B-树的区别"><a href="#3-4-B树和B-树的区别" class="headerlink" title="3.4 B树和B+树的区别"></a>3.4 B树和B+树的区别</h3><ol><li><p>B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。</p><p> 而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。</p></li><li><p>因为B树键位置不定，且在整个树结构中只出现一次。虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。</p></li><li><p>B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</p></li><li><p>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。 </p></li><li><p>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</p></li></ol><h3 id="3-5-B-树的优点和缺点"><a href="#3-5-B-树的优点和缺点" class="headerlink" title="3.5 B+树的优点和缺点"></a>3.5 B+树的优点和缺点</h3><ol><li>优点</li></ol><ul><li>单次请求涉及的磁盘IO次数少（出度d大， 且非叶子节点不包含表数据，树的高度小）</li><li>查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）；</li><li>遍历效率高（从符合条件的某个叶子节点开始遍历即可）；</li></ul><ol start="2"><li>缺点</li></ol><ul><li>主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片；</li><li>即使主键是有序递增的，大量写请求的分布仍是随机的；</li></ul><ol start="3"><li>解释缺点</li></ol><ul><li>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</li><li>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）</li></ul><p>作者：奈文摩尔ST<br>链接：<a href="https://www.jianshu.com/p/06f9f7f41fdb">https://www.jianshu.com/p/06f9f7f41fdb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><blockquote><p>聚簇优点：物理存储的顺序导致磁盘读取的次数减少</p></blockquote><blockquote><p>B/B+优点：相比二叉搜索树，一个盘块存储的key多，一个读取多个key。读取总的盘块次数减少，时间减少。</p></blockquote><h2 id="4-索引分类"><a href="#4-索引分类" class="headerlink" title="4 索引分类"></a>4 索引分类</h2><ol><li>普通索引</li><li>唯一索引：与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：</li><li>全文索引：（FULLTEXT）： <strong>TODO</strong><ul><li>定义：全文检索是对大数据文本进行索引，在建立的索引中对要查找的单词进行进行搜索，定位哪些文本数据包括要搜索的单词。因此，全文检索的全部工作就是建立索引和在索引中搜索定位，所有的工作都是围绕这两个来进行的。<blockquote><p>如果可能，请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。</p></blockquote></li></ul></li><li>多列索引（组合索引：<br> MySQL能在多个列上创建索引。一个索引可以由最多15个列组成。（在CHAR和VARCHAR列上，你也可以使用列的前缀作为一个索引的部分)。<ul><li>一个多重列索引可以认为是包含通过合并(concatenate)索引列值创建的值的一个排序数组。</li><li>多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格（获得结果集记录数最少）的索引。</li><li>在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li></ul></li></ol><blockquote><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引。</p></blockquote><h3 id="4-1-hash索引和B-树索引区别"><a href="#4-1-hash索引和B-树索引区别" class="headerlink" title="4.1 hash索引和B+树索引区别"></a>4.1 hash索引和B+树索引区别</h3><p><a href="https://blog.csdn.net/qq_44590469/article/details/97877397">Hash索引和B+树索引有什么区别或者说优劣势</a></p><h3 id="4-2-最左匹配原则（针对联合索引）"><a href="#4-2-最左匹配原则（针对联合索引）" class="headerlink" title="4.2 最左匹配原则（针对联合索引）"></a>4.2 最左匹配原则（针对联合索引）</h3><p><a href="https://blog.csdn.net/sinat_41917109/article/details/88944290">讲得不错的最左匹配原则</a></p><h2 id="4-3-索引建立的注意事项"><a href="#4-3-索引建立的注意事项" class="headerlink" title="4.3 索引建立的注意事项"></a>4.3 索引建立的注意事项</h2><ol><li>最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</li><li>尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。</li><li>索引列不能参与计算，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = ‘2016-06-06’ 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP(‘2016-06-06’)。</li><li>尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</li><li>单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。</li></ol><p><a href="https://blog.csdn.net/ss123mlk/article/details/106902596">sql优化：explain关键字</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql索引&quot;&gt;&lt;a href=&quot;#Mysql索引&quot; class=&quot;headerlink&quot; title=&quot;Mysql索引&quot;&gt;&lt;/a&gt;Mysql索引&lt;/h1&gt;&lt;p&gt;Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。&lt;/p&gt;
&lt;p&gt;哈希索引对应哈希表，</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql难点语法</title>
    <link href="http://example.com/2021/02/27/Mysql%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2021/02/27/Mysql%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql难点语法"><a href="#Mysql难点语法" class="headerlink" title="Mysql难点语法"></a>Mysql难点语法</h1><h2 id="1-group-by"><a href="#1-group-by" class="headerlink" title="1 group by"></a>1 group by</h2><p>group by 要与having共用， 不能与where，因为where中不能有聚集函数做为条件表达式</p><p>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数</p><h2 id="2-数据库中的union与union-all的区别"><a href="#2-数据库中的union与union-all的区别" class="headerlink" title="2 数据库中的union与union all的区别"></a>2 数据库中的union与union all的区别</h2><p>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All</p><p> 两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</p><p> union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 </p><p> Union All：对两个结果集进行并集操作，包括重复行，不进行排序； </p><h2 id="3-连表查询比子查询快"><a href="#3-连表查询比子查询快" class="headerlink" title="3 连表查询比子查询快"></a>3 连表查询比子查询快</h2><h2 id="4-按某一属性排序并生成行号序列"><a href="#4-按某一属性排序并生成行号序列" class="headerlink" title="4 按某一属性排序并生成行号序列"></a>4 按某一属性排序并生成行号序列</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row_number() over(partition by customer_id </span><br><span class="line">order by order_date desc)</span><br></pre></td></tr></table></figure><h2 id="5-using连接查询"><a href="#5-using连接查询" class="headerlink" title="5 using连接查询"></a>5 using连接查询</h2><p> sql/92标准可以使用using关键字来简化连接查询，但是只是在查询满足下面两个条件时，才能使</p><p>用using关键字进行简化。</p><ul><li>1.查询必须是等值连接。</li><li>2.等值连接中的列必须具有相同的名称和数据类型。</li></ul><h2 id="6-case-when"><a href="#6-case-when" class="headerlink" title="6 case when"></a>6 case when</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">    when ...</span><br><span class="line">    whem ...</span><br><span class="line">    else ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql难点语法&quot;&gt;&lt;a href=&quot;#Mysql难点语法&quot; class=&quot;headerlink&quot; title=&quot;Mysql难点语法&quot;&gt;&lt;/a&gt;Mysql难点语法&lt;/h1&gt;&lt;h2 id=&quot;1-group-by&quot;&gt;&lt;a href=&quot;#1-group-by&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://example.com/2021/02/27/RabbitMQ/"/>
    <id>http://example.com/2021/02/27/RabbitMQ/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MQ的三个作用"><a href="#1-MQ的三个作用" class="headerlink" title="1 MQ的三个作用"></a>1 MQ的三个作用</h1><ol><li>异步</li><li>解耦，消息统一分发</li><li>流量削峰</li></ol><h1 id="2-AMQP事物机制控制"><a href="#2-AMQP事物机制控制" class="headerlink" title="2 AMQP事物机制控制"></a>2 AMQP事物机制控制</h1><ol><li>txSelect, txCommit, txRollback</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MQ的三个作用&quot;&gt;&lt;a href=&quot;#1-MQ的三个作用&quot; class=&quot;headerlink&quot; title=&quot;1 MQ的三个作用&quot;&gt;&lt;/a&gt;1 MQ的三个作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;解耦，消息统一分发&lt;/li&gt;
&lt;li&gt;流量削峰&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="http://example.com/2021/02/27/dubbo/"/>
    <id>http://example.com/2021/02/27/dubbo/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.765Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo是一款高性能的Java RPC框架</p><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=72">ZooKeeper+Dubbo分布式架构基础教程</a></p><ol><li>面向接口的的远程方法调用，智能容错和负载均衡，服务自动注册和发现<h1 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1 RPC"></a>1 RPC</h1></li></ol><ul><li>A服务器的方法调用B服务器的方法，不在同一个内存空间。<ol><li>客户端调用</li><li>序列化</li><li>发送消息</li><li>发序列化</li><li>调用本地服务</li><li>服务处理</li><li>返回结果</li><li>将结果序列化</li><li>返回消息</li><li>反序列化</li><li>返回调用结果<h1 id="2-RMI"><a href="#2-RMI" class="headerlink" title="2 RMI"></a>2 RMI</h1></li></ol></li><li>java原生支持的远程调用，采用JRMP作为通信协议</li><li>client、server、registy注册中心</li></ul><ol><li>大致原理：服务端在注册中心注册服务，客户端从注册中心获取服务具体信息，客户端调用服务端执行服务。</li><li>步骤<ol><li>创建远程接口，继承Remote</li><li>实现远程接口，并且继承UnicastRemoteObject</li><li>启动RMI注册服务，指定端口号</li><li>创建要被访问的远程对象的实例</li><li>把远程对象实例注册到RMI注册服务器上</li></ol></li></ol><h1 id="3-dubbo高可用"><a href="#3-dubbo高可用" class="headerlink" title="3 dubbo高可用"></a>3 dubbo高可用</h1><ol><li>服务路由（包含一条路由规则）<ul><li>dubbo提供了三种服务路由实现（条件路由ConditionRouter、脚本路由ScriptRouter、标签路由TagRouter）</li></ul></li><li>条件路由规则的格式：<ul><li>服务消费者匹配条件 =&gt; 服务提供者匹配条件</li><li>host = 10.20.153.10 =&gt; host = 10.20.153.11</li><li>该条规则表示IP为10.20.153.10的服务消费者止咳调用IP为10.20.153.11机器上的服务，不可调用其他机器上的服务。</li><li>如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。</li><li>包括黑名单、白名单、读写分离、前后天分离</li></ul></li><li>集群容错<ul><li>FailoverCluster,某个服务器产生异常，重试其他服务器，可以设置重试次数。</li><li>Failfast Cluter快速失败，只调用一次，立即报错。通常用于非幂等性的写操作</li></ul></li><li>负载均衡（面试题）<ul><li>随机权重分配，无状态</li><li>轮训服务器，有状态</li><li>活跃计数器随机</li><li>一致性哈希，为IP分配固定的服务器</li></ul></li><li>dubbo降级服务<ul><li>服务降级就是指在由于非主业务异常导致的服务不可用时（服务器宕机/网络超时/并发数太高等），可以返回默认值，避免异常影响主业务的处理</li></ul></li></ol><blockquote><p>zookeeper 和 redis 用于消息中心的很重要的原因是知道断开</p></blockquote><p>Dubbo SPI流程：名字–&gt;文件–&gt;实现类–&gt;对象–&gt;依赖注入–&gt;AOP–&gt;完整的一个对象</p><blockquote><p>Dubbo的依赖注入与spring的区别，注入的是一个属性的代理对象，根据实际要用时传入的url中的实际对象赋真正的值，也就是set的时候并没有确定最终的对象。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dubbo是一款高性能的Java RPC框架&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BA411q7ia?p=72&quot;&gt;ZooKeeper+Dubbo分布式架构基础教程&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向接口的的</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>AQS并发工具类</title>
    <link href="http://example.com/2021/02/27/%E5%B9%B6%E5%8F%91/13%20AQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2021/02/27/%E5%B9%B6%E5%8F%91/13%20AQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h1><h2 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h2><p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p><p>调用latch.await()的方法的线程会阻塞，直到所有任务完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Driver2 &#123; &#x2F;&#x2F; ...</span><br><span class="line">    void main() throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch doneSignal &#x3D; new CountDownLatch(N);</span><br><span class="line">        Executor e &#x3D; Executors.newFixedThreadPool(8);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建 N 个任务，提交给线程池来执行</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; ++i) &#x2F;&#x2F; create and start threads</span><br><span class="line">            e.execute(new WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 等待所有的任务完成，这个方法才会返回</span><br><span class="line">        doneSignal.await();           &#x2F;&#x2F; wait for all to finish</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WorkerRunnable implements Runnable &#123;</span><br><span class="line">    private final CountDownLatch doneSignal;</span><br><span class="line">    private final int i;</span><br><span class="line"></span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, int i) &#123;</span><br><span class="line">        this.doneSignal &#x3D; doneSignal;</span><br><span class="line">        this.i &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            &#x2F;&#x2F; 这个线程的任务完成了，调用 countDown 方法</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">        &#125; &#x2F;&#x2F; return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doWork() &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们将一个较大的任务进行拆分，然后开启多个线程执行，等所有线程都执行完了以后，再往下执行其他操作。</p><p>下面的列子，用了两个CountDownLatch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123; &#x2F;&#x2F; ...</span><br><span class="line">    void main() throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch startSignal &#x3D; new CountDownLatch(1);</span><br><span class="line">        CountDownLatch doneSignal &#x3D; new CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; ++i) &#x2F;&#x2F; create and start threads</span><br><span class="line">            new Thread(new Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span><br><span class="line">        doSomethingElse();            &#x2F;&#x2F; don&#39;t let run yet</span><br><span class="line">        &#x2F;&#x2F; 因为这里 N &#x3D;&#x3D; 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span><br><span class="line">        startSignal.countDown();      &#x2F;&#x2F; let all threads proceed</span><br><span class="line">        doSomethingElse();</span><br><span class="line">        &#x2F;&#x2F; 等待所有任务结束</span><br><span class="line">        doneSignal.await();           &#x2F;&#x2F; wait for all to finish</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Worker implements Runnable &#123;</span><br><span class="line">    private final CountDownLatch startSignal;</span><br><span class="line">    private final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">        this.startSignal &#x3D; startSignal;</span><br><span class="line">        this.doneSignal &#x3D; doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span><br><span class="line">            &#x2F;&#x2F; 等大家都准备好了，再打开这个门栓</span><br><span class="line">            startSignal.await();</span><br><span class="line">            doWork();</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">        &#125; &#x2F;&#x2F; return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doWork() &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来说，就是有m个线程是做任务的，有n个线程在某个栅栏上等待这m个线程做完任务，直到所有m个任务完成后，n个线程同时同时通过栅栏。</p><h2 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h2><p><a href="https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/currency/Java%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%979%EF%BC%9AAQS%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0.md">源码分析</a></p><h1 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h1><ul><li>CyclicBarrier意思是周期性栅栏、</li><li>CountDownLatch是基于AQS的共享模式的使用，而CyclicBarrier是基于Condition来实现</li></ul><p><img src="http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/93D8DE706E794E0D9AEA7493D09A07E1/11264"></p><ul><li>由上图可知CyclicBarrier的源码最重要的是await()方法</li></ul><h2 id="2-1-源码分析"><a href="#2-1-源码分析" class="headerlink" title="2.1 源码分析"></a>2.1 源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrier &#123;</span><br><span class="line">    &#x2F;&#x2F; 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&quot;一代&quot;，或者&quot;一个周期&quot;</span><br><span class="line">    private static class Generation &#123;</span><br><span class="line">        boolean broken &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** The lock for guarding barrier entry *&#x2F;</span><br><span class="line">    private final ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; CyclicBarrier 是基于 Condition 的</span><br><span class="line">    &#x2F;&#x2F; Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span><br><span class="line">    private final Condition trip &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参与的线程数</span><br><span class="line">    private final int parties;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span><br><span class="line">    private final Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前所处的“代”</span><br><span class="line">    private Generation generation &#x3D; new Generation();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span><br><span class="line">    &#x2F;&#x2F; 还没有到栅栏的线程数 &#x3D; parties - 已经到栅栏的数量</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">        if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">        this.parties &#x3D; parties;</span><br><span class="line">        this.count &#x3D; parties;</span><br><span class="line">        this.barrierCommand &#x3D; barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CyclicBarrier(int parties) &#123;</span><br><span class="line">        this(parties, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>开启新一代<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先，需要唤醒所有的在栅栏上等待的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    &#x2F;&#x2F; 更新 count 的值</span><br><span class="line">    count &#x3D; parties;</span><br><span class="line">    &#x2F;&#x2F; 重新生成“新一代”</span><br><span class="line">    generation &#x3D; new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开启新一代，类似于重新实例化一个CyclicBarrier实例</p></blockquote></li><li>打破一个栅栏</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置状态 broken 为 true</span><br><span class="line">    generation.broken &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F; 重置 count 为初始值 parties</span><br><span class="line">    count &#x3D; parties;</span><br><span class="line">    &#x2F;&#x2F; 唤醒所有已经在等待的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>await方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不带超时机制</span><br><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); &#x2F;&#x2F; cannot happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 带超时机制，如果超时抛出 TimeoutException 异常</span><br><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    return dowait(true, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    &#x2F;&#x2F; 先要获取到锁，然后在 finally 中要记得释放锁</span><br><span class="line">    &#x2F;&#x2F; 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        final Generation g &#x3D; generation;</span><br><span class="line">        &#x2F;&#x2F; 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">        &#x2F;&#x2F; 检查中断状态，如果中断了，抛出 InterruptedException 异常</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; index 是这个 await 方法的返回值</span><br><span class="line">        &#x2F;&#x2F; 注意到这里，这个是从 count 递减后得到的值</span><br><span class="line">        int index &#x3D; --count;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; tripped</span><br><span class="line">            boolean ranAction &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span><br><span class="line">                final Runnable command &#x3D; barrierCommand;</span><br><span class="line">                if (command !&#x3D; null)</span><br><span class="line">                    command.run();</span><br><span class="line">                &#x2F;&#x2F; 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span><br><span class="line">                ranAction &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 唤醒等待的线程，然后开启新的一代</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    &#x2F;&#x2F; 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span><br><span class="line">                    &#x2F;&#x2F; 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        &#x2F;&#x2F; 如果是最后一个线程调用 await，那么上面就返回了</span><br><span class="line">        &#x2F;&#x2F; 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos &#x3D; trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span><br><span class="line">                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 打破栅栏</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    &#x2F;&#x2F; 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 到这里，说明 g !&#x3D; generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span><br><span class="line">                    &#x2F;&#x2F; 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span><br><span class="line">                    &#x2F;&#x2F; 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span><br><span class="line">                    &#x2F;&#x2F; 而是之后抛出 BrokenBarrierException 异常</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              &#x2F;&#x2F; 唤醒后，检查栅栏是否是“破的”</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这个 for 循环除了异常，就是要从这里退出了</span><br><span class="line">            &#x2F;&#x2F; 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span><br><span class="line">            &#x2F;&#x2F; 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g !&#x3D; generation 的</span><br><span class="line">            &#x2F;&#x2F; 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span><br><span class="line">            &#x2F;&#x2F; 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span><br><span class="line">            &#x2F;&#x2F; 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span><br><span class="line">            if (g !&#x3D; generation)</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果醒来发现超时了，打破栅栏，抛出异常</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    static class PreTaskThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String task;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        public PreTaskThread(String task, CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.cyclicBarrier &#x3D; cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; 假设总共三个关卡</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Random random &#x3D; new Random();</span><br><span class="line">                    Thread.sleep(random.nextInt(1000));</span><br><span class="line">                    System.out.println(String.format(&quot;关卡%d的任务%s完成&quot;, i, task));</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                cyclicBarrier.reset(); &#x2F;&#x2F; 重置屏障</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;本关卡所有前置任务完成，开始游戏...&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载地图数据&quot;, cyclicBarrier)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载人物模型&quot;, cyclicBarrier)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载背景音乐&quot;, cyclicBarrier)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3 Semaphore"></a>3 Semaphore</h1></li><li><p>Semaphore类似一个资源池（可以类比线程池），每个线程需要调用acquire()方法获取资源，然后才能执行，需要release资源，让给其他的线程用。</p></li><li><p>总结来说， Semaphore是AQS中共享锁的使用，因为每个线程共享一个池。</p></li><li><p>Semaphore同时支持公平锁和非公平锁。</p></li></ul><ol><li>acquire<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">public void acquireUninterruptibly() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public void acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line">public void acquireUninterruptibly(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void acquireUninterruptibly() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对比公平和非公平的tryAcquireShared方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 公平策略：</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available &#x3D; getState();</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 非公平策略：</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available &#x3D; getState();</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果tryAcquireShared(arg) 返回小于 0 ， 说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;从这里醒来后，会尝试获得锁，如果能获得，继续向后传递，不过不能则阻塞。</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>release<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 任务介绍，释放一个资源</span><br><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; getState();</span><br><span class="line">        int next &#x3D; current + releases;</span><br><span class="line">        &#x2F;&#x2F; 溢出，当然，我们一般也不会用这么大的数</span><br><span class="line">        if (next &lt; current) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-ReentrantReadWriterLock"><a href="#4-ReentrantReadWriterLock" class="headerlink" title="4 ReentrantReadWriterLock"></a>4 ReentrantReadWriterLock</h1></li></ol><ul><li>一个缓存的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是一个关于缓存操作的故事</span><br><span class="line">class CachedData &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    volatile boolean cacheValid;</span><br><span class="line">    &#x2F;&#x2F; 读写锁实例</span><br><span class="line">    final ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    void processCachedData() &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取读锁</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        if (!cacheValid) &#123; &#x2F;&#x2F; 如果缓存过期了，或者为 null</span><br><span class="line">            &#x2F;&#x2F; 释放掉读锁，然后获取写锁 (后面会看到，没释放掉读锁就获取写锁，会发生死锁情况)</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if (!cacheValid) &#123; &#x2F;&#x2F; 重新判断，因为在等待写锁的过程中，可能前面有其他写线程执行过了</span><br><span class="line">                    data &#x3D; ...</span><br><span class="line">                    cacheValid &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 获取读锁 (持有写锁的情况下，是允许获取读锁的，称为 “锁降级”，反之不行。)</span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 释放写锁，此时还剩一个读锁</span><br><span class="line">                rwl.writeLock().unlock(); &#x2F;&#x2F; Unlock write, still hold read</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放读锁</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ReentrantReadWriterLock分为读锁和写锁两个实例，读锁时共享锁，可被多个线程同时使用，写锁是独占锁。持有写锁的线程可以继续获取读锁，反之不行。</li></ul><h2 id="4-1-源码分析-属性"><a href="#4-1-源码分析-属性" class="headerlink" title="4.1 源码分析-属性"></a>4.1 源码分析-属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    &#x2F;&#x2F; 下面这块说的就是将 state 一分为二，高 16 位用于共享模式，低16位用于独占模式</span><br><span class="line">    static final int SHARED_SHIFT   &#x3D; 16;</span><br><span class="line">    static final int SHARED_UNIT    &#x3D; (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    static final int MAX_COUNT      &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">    static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">    &#x2F;&#x2F; 取 c 的高 16 位值，代表读锁的获取次数(包括重入)</span><br><span class="line">    static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    &#x2F;&#x2F; 取 c 的低 16 位值，代表写锁的重入次数，因为写锁是独占模式</span><br><span class="line">    static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个嵌套类的实例用来记录每个线程持有的读锁数量(读锁重入)</span><br><span class="line">    static final class HoldCounter &#123;</span><br><span class="line">        &#x2F;&#x2F; 持有的读锁数</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 线程 id</span><br><span class="line">        final long tid &#x3D; getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ThreadLocal 的子类</span><br><span class="line">    static final class ThreadLocalHoldCounter</span><br><span class="line">        extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line">        public HoldCounter initialValue() &#123;</span><br><span class="line">            return new HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * 组合使用上面两个类，用一个 ThreadLocal 来记录当前线程持有的读锁数量</span><br><span class="line">      *&#x2F; </span><br><span class="line">    private transient ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于缓存，记录&quot;最后一个获取读锁的线程&quot;的读锁重入次数，</span><br><span class="line">    &#x2F;&#x2F; 所以不管哪个线程获取到读锁后，就把这个值占为已用，这样就不用到 ThreadLocal 中查询 map 了</span><br><span class="line">    &#x2F;&#x2F; 算不上理论的依据：通常读锁的获取很快就会伴随着释放，</span><br><span class="line">    &#x2F;&#x2F;   显然，在 获取-&gt;释放 读锁这段时间，如果没有其他线程获取读锁的话，此缓存就能帮助提高性能</span><br><span class="line">    private transient HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一个获取读锁的线程(并且其未释放读锁)，以及它持有的读锁数量</span><br><span class="line">    private transient Thread firstReader &#x3D; null;</span><br><span class="line">    private transient int firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化 readHolds 这个 ThreadLocal 属性</span><br><span class="line">        readHolds &#x3D; new ThreadLocalHoldCounter();</span><br><span class="line">        &#x2F;&#x2F; 为了保证 readHolds 的内存可见性</span><br><span class="line">        setState(getState()); &#x2F;&#x2F; ensures visibility of readHolds</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>state 的高 16 位代表读锁的获取次数，包括重入次数，获取到读锁一次加 1，释放掉读锁一次减 1</li><li>state 的低 16 位代表写锁的获取次数，因为写锁是独占锁，同时只能被一个线程获得，所以它代表重入次数</li><li>每个线程都需要维护自己的 HoldCounter，记录该线程获取的读锁次数，这样才能知道到底是不是读锁重入，用 ThreadLocal 属性 readHolds 维护</li><li>cachedHoldCounter 有什么用？其实没什么用，但能提示性能。将最后一次获取读锁的线程的 HoldCounter 缓存到这里，这样比使用 ThreadLocal 性能要好一些，因为 ThreadLocal 内部是基于 map 来查询的。但是 cachedHoldCounter 这一个属性毕竟只能缓存一个线程，所以它要起提升性能作用的依据就是：通常读锁的获取紧随着就是该读锁的释放。我这里可能表达不太好，但是大家应该是懂的吧。</li><li>firstReader 和 firstReaderHoldCount 有什么用？其实也没什么用，但是它也能提示性能。将”第一个”获取读锁的线程记录在 firstReader 属性中，这里的第一个不是全局的概念，等这个 firstReader 当前代表的线程释放掉读锁以后，会有后来的线程占用这个属性的。firstReader 和 firstReaderHoldCount 使得在读锁不产生竞争的情况下，记录读锁重入次数非常方便快速</li><li>如果一个线程使用了 firstReader，那么它就不需要占用 cachedHoldCounter</li><li>个人认为，读写锁源码中最让初学者头疼的就是这几个用于提升性能的属性了，使得大家看得云里雾里的。主要是因为 ThreadLocal 内部是通过一个 ThreadLocalMap 来操作的，会增加检索时间。而很多场景下，执行 unlock 的线程往往就是刚刚最后一次执行 lock 的线程，中间可能没有其他线程进行 lock。还有就是很多不怎么会发生读锁竞争的场景。</li></ol><h2 id="4-2-读锁"><a href="#4-2-读锁" class="headerlink" title="4.2 读锁"></a>4.2 读锁</h2><ol><li>读锁ReadLock的lock流程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ReadLock</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; AQS</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>下面这段代码，有两种获取读锁的场景，一种是新来的，一种是排队排到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line"></span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; exclusiveCount(c) 不等于 0，说明有线程持有写锁，</span><br><span class="line">    &#x2F;&#x2F;    而且不是当前线程持有写锁，那么当前线程获取读锁失败</span><br><span class="line">    &#x2F;&#x2F;         （另，如果持有写锁的是当前线程，是可以继续获取读锁的）</span><br><span class="line">    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 读锁的获取次数</span><br><span class="line">    int r &#x3D; sharedCount(c);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 读锁获取是否需要被阻塞，稍后细说。为了进去下面的分支，假设这里不阻塞就好了</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; 判断是否会溢出 (2^16-1，没那么容易溢出的)</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; 下面这行 CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;&#x2F;   进到这里就是获取到了读锁</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">        if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; r &#x3D;&#x3D; 0 说明此线程是第一个获取读锁的，或者说在它前面获取读锁的都走光光了，它也算是第一个吧</span><br><span class="line">            &#x2F;&#x2F;  记录 firstReader 为当前线程，及其持有的读锁数量：1</span><br><span class="line">            firstReader &#x3D; current;</span><br><span class="line">            firstReaderHoldCount &#x3D; 1;</span><br><span class="line">        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">            &#x2F;&#x2F; 进来这里，说明是 firstReader 重入获取读锁（这非常简单，count 加 1 结束）</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 前面我们说了 cachedHoldCounter 用于缓存最后一个获取读锁的线程</span><br><span class="line">            &#x2F;&#x2F; 如果 cachedHoldCounter 缓存的不是当前线程，设置为缓存当前线程的 HoldCounter</span><br><span class="line">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line">            else if (rh.count &#x3D;&#x3D; 0) </span><br><span class="line">                &#x2F;&#x2F; 到这里，那么就是 cachedHoldCounter 缓存的是当前线程，但是 count 为 0，</span><br><span class="line">                &#x2F;&#x2F; 大家可以思考一下：这里为什么要 set ThreadLocal 呢？(当然，答案肯定不在这块代码中)</span><br><span class="line">                &#x2F;&#x2F;   既然 cachedHoldCounter 缓存的是当前线程，</span><br><span class="line">                &#x2F;&#x2F;   当前线程肯定调用过 readHolds.get() 进行初始化 ThreadLocal</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; count 加 1</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; return 大于 0 的数，代表获取到了共享锁</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往下看</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>readerShouldBlock() 返回 true，2 种情况：</p><ul><li><p>在 FairSync 中说的是 hasQueuedPredecessors()，即阻塞队列中有其他元素在等待锁。也就是说，公平模式下，新来的要排队</p></li><li><p>在 NonFairSync 中说的是 apparentlyFirstQueuedIsExclusive()，即判断阻塞队列中 head 的第一个后继节点是否是来获取写锁的，如果是的话，让这个写锁先来，避免写锁饥饿。</p><blockquote><p>作者给写锁定义了更高的优先级，所以如果碰上获取写锁的线程马上就要获取到锁了，获取读锁的线程不应该和它抢。</p></blockquote><blockquote><p>如果 head.next 不是来获取写锁的，那么可以随便抢，因为是非公平模式，大家比比 CAS 速度</p></blockquote></li></ul></li><li><p>compareAndSetState(c, c + SHARED_UNIT) 这里 CAS 失败，存在竞争。可能是和另一个读锁获取竞争，当然也可能是和另一个写锁获取操作竞争。</p></li></ul><p>随后进入fullTryAcquireShared中尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 1\. 刚刚我们说了可能是因为 CAS 失败，如果就此返回，那么就要进入到阻塞队列了，</span><br><span class="line"> *    想想有点不甘心，因为都已经满足了 !readerShouldBlock()，也就是说本来可以不用到阻塞队列的，</span><br><span class="line"> *    所以进到这个方法其实是增加 CAS 成功的机会</span><br><span class="line"> * 2\. 在 NonFairSync 情况下，虽然 head.next 是获取写锁的，我知道它等待很久了，我没想和它抢，</span><br><span class="line"> *    可是如果我是来重入读锁的，那么只能表示对不起了</span><br><span class="line"> *&#x2F;</span><br><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 别忘了这外层有个 for 循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        &#x2F;&#x2F; 如果其他线程持有了写锁，自然这次是获取不到读锁了，乖乖到阻塞队列排队吧</span><br><span class="line">        if (exclusiveCount(c) !&#x3D; 0) &#123;</span><br><span class="line">            if (getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">                return -1;</span><br><span class="line">            &#x2F;&#x2F; else we hold the exclusive lock; blocking here</span><br><span class="line">            &#x2F;&#x2F; would cause deadlock.</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">              * 进来这里，说明：</span><br><span class="line">              *  1\. exclusiveCount(c) &#x3D;&#x3D; 0：写锁没有被占用</span><br><span class="line">              *  2\. readerShouldBlock() 为 true，说明阻塞队列中有其他线程在等待</span><br><span class="line">              *</span><br><span class="line">              * 既然 should block，那进来这里是干什么的呢？</span><br><span class="line">              * 答案：是进来处理读锁重入的！</span><br><span class="line">              * </span><br><span class="line">              *&#x2F;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; firstReader 线程重入读锁，直接到下面的 CAS</span><br><span class="line">            if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">                &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    rh &#x3D; cachedHoldCounter;</span><br><span class="line">                    if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; cachedHoldCounter 缓存的不是当前线程</span><br><span class="line">                        &#x2F;&#x2F; 那么到 ThreadLocal 中获取当前线程的 HoldCounter</span><br><span class="line">                        &#x2F;&#x2F; 如果当前线程从来没有初始化过 ThreadLocal 中的值，get() 会执行初始化</span><br><span class="line">                        rh &#x3D; readHolds.get();</span><br><span class="line">                        &#x2F;&#x2F; 如果发现 count &#x3D;&#x3D; 0，也就是说，纯属上一行代码初始化的，那么执行 remove</span><br><span class="line">                        &#x2F;&#x2F; 然后往下两三行，乖乖排队去</span><br><span class="line">                        if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                    &#x2F;&#x2F; 排队去。</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;**</span><br><span class="line">              * 这块代码我看了蛮久才把握好它是干嘛的，原来只需要知道，它是处理重入的就可以了。</span><br><span class="line">              * 就是为了确保读锁重入操作能成功，而不是被塞到阻塞队列中等待</span><br><span class="line">              *</span><br><span class="line">              * 另一个信息就是，这里对于 ThreadLocal 变量 readHolds 的处理：</span><br><span class="line">              *    如果 get() 后发现 count &#x3D;&#x3D; 0，居然会做 remove() 操作，</span><br><span class="line">              *    这行代码对于理解其他代码是有帮助的</span><br><span class="line">              *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line"></span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里 CAS 成功，那么就意味着成功获取读锁了</span><br><span class="line">            &#x2F;&#x2F; 下面需要做的是设置 firstReader 或 cachedHoldCounter</span><br><span class="line"></span><br><span class="line">            if (sharedCount(c) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果发现 sharedCount(c) 等于 0，就将当前线程设置为 firstReader</span><br><span class="line">                firstReader &#x3D; current;</span><br><span class="line">                firstReaderHoldCount &#x3D; 1;</span><br><span class="line">            &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 下面这几行，就是将 cachedHoldCounter 设置为当前线程</span><br><span class="line">                if (rh &#x3D;&#x3D; null)</span><br><span class="line">                    rh &#x3D; cachedHoldCounter;</span><br><span class="line">                if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                    rh &#x3D; readHolds.get();</span><br><span class="line">                else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter &#x3D; rh;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回大于 0 的数，代表获取到了读锁</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>firstReader 是每次将读锁获取次数从 0 变为 1 的那个线程。<br>能缓存到 firstReader 中就不要缓存到 cachedHoldCounter 中。</p></blockquote><ol start="2"><li><p>读锁释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ReadLock</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sync</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared(); &#x2F;&#x2F; 这句代码其实唤醒 获取写锁的线程，往下看就知道了</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sync</span><br><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">        if (firstReaderHoldCount &#x3D;&#x3D; 1)</span><br><span class="line">            &#x2F;&#x2F; 如果等于 1，那么这次解锁后就不再持有锁了，把 firstReader 置为 null，给后来的线程用</span><br><span class="line">            &#x2F;&#x2F; 为什么不顺便设置 firstReaderHoldCount &#x3D; 0？因为没必要，其他线程使用的时候自己会设值</span><br><span class="line">            firstReader &#x3D; null;</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断 cachedHoldCounter 是否缓存的是当前线程，不是的话要到 ThreadLocal 中取</span><br><span class="line">        HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">            rh &#x3D; readHolds.get();</span><br><span class="line"></span><br><span class="line">        int count &#x3D; rh.count;</span><br><span class="line">        if (count &lt;&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这一步将 ThreadLocal remove 掉，防止内存泄漏。因为已经不再持有读锁了</span><br><span class="line">            readHolds.remove();</span><br><span class="line"></span><br><span class="line">            if (count &lt;&#x3D; 0)</span><br><span class="line">                &#x2F;&#x2F; 就是那种，lock() 一次，unlock() 好几次的逗比</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; count 减 1</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        &#x2F;&#x2F; nextc 是 state 高 16 位减 1 后的值</span><br><span class="line">        int nextc &#x3D; c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            &#x2F;&#x2F; 如果 nextc &#x3D;&#x3D; 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都空了</span><br><span class="line">            &#x2F;&#x2F; 此时这里返回 true 的话，其实是帮助唤醒后继节点中的获取写锁的线程</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-写锁"><a href="#4-3-写锁" class="headerlink" title="4.3 写锁"></a>4.3 写锁</h2></li><li><p>写锁获取</p></li></ol><ul><li>写锁是独占锁</li><li>如果有读锁被占用，写锁获取是要进入到阻塞队列中等待的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; WriteLock</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; AQS</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; 如果 tryAcquire 失败，那么进入到阻塞队列等待</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sync</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line"></span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    int w &#x3D; exclusiveCount(c);</span><br><span class="line">    if (c !&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 看下这里返回 false 的情况：</span><br><span class="line">        &#x2F;&#x2F;   c !&#x3D; 0 &amp;&amp; w &#x3D;&#x3D; 0: 写锁可用，但是有线程持有读锁(也可能是自己持有)</span><br><span class="line">        &#x2F;&#x2F;   c !&#x3D; 0 &amp;&amp; w !&#x3D;0 &amp;&amp; current !&#x3D; getExclusiveOwnerThread(): 其他线程持有写锁</span><br><span class="line">        &#x2F;&#x2F;   也就是说，只要有读锁或写锁被占用，这次就不能获取到写锁</span><br><span class="line">        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里不需要 CAS，仔细看就知道了，能到这里的，只可能是写锁重入，不然在上面的 if 就拦截了</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果写锁获取不需要 block，那么进行 CAS，成功就代表获取到了写锁</span><br><span class="line">    if (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        return false;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>writerShouldBlock()判定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是非公平模式，那么 lock 的时候就可以直接用 CAS 去抢锁，抢不到再排队</span><br><span class="line">    final boolean writerShouldBlock() &#123;</span><br><span class="line">        return false; &#x2F;&#x2F; writers can always barge</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    final boolean writerShouldBlock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果是公平模式，那么如果阻塞队列有线程等待的话，就乖乖去排队</span><br><span class="line">        return hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>写锁释放<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; WriteLock</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AQS</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1\. 释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 2\. 如果独占锁释放&quot;完全&quot;，唤醒后继节点</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sync </span><br><span class="line">&#x2F;&#x2F; 释放锁，是线程安全的，因为写锁是独占锁，具有排他性</span><br><span class="line">&#x2F;&#x2F; 实现很简单，state 减 1 就是了</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    int nextc &#x3D; getState() - releases;</span><br><span class="line">    boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0;</span><br><span class="line">    if (free)</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    &#x2F;&#x2F; 如果 exclusiveCount(nextc) &#x3D;&#x3D; 0，也就是说包括重入的，所有的写锁都释放了，</span><br><span class="line">    &#x2F;&#x2F; 那么返回 true，这样会进行唤醒后继节点的操作。</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-锁降级"><a href="#4-4-锁降级" class="headerlink" title="4.4 锁降级"></a>4.4 锁降级</h2></li></ol><ul><li><p>如果线程持有读锁，那么写锁也需要等待</p></li><li><p>在非公平模式下，为了提高吞吐量，lock的时候会先CAS竞争一下，能成功就代表读锁获取成功了，但是如果发现head.next是获取写锁的线程，就不会去做CAS操作。</p></li><li><p>持有写锁的线程，去获取读锁的过程称为锁降级。这样，线程就同时持有写锁和读锁。</p></li><li><p>锁升级是不被允许的，线程持有读锁的话，在没释放的情况不能获取写锁，因为会发生死锁。</p></li></ul><blockquote><p>如果线程 a 先获取了读锁，然后获取写锁，那么线程 a 就到阻塞队列休眠了，自己把自己弄休眠了，而且可能之后就没人去唤醒它了。</p></blockquote><h1 id="5-Exchanger"><a href="#5-Exchanger" class="headerlink" title="5 Exchanger"></a>5 Exchanger</h1><p><a href="https://www.jianshu.com/p/990ae2ab1ae0">java exchanger必知必会</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-CountDownLatch&quot;&gt;&lt;a href=&quot;#1-CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;1 CountDownLatch&quot;&gt;&lt;/a&gt;1 CountDownLatch&lt;/h1&gt;&lt;h2 id=&quot;1-1-使用场景&quot;</summary>
      
    
    
    
    <category term="java并发编程" scheme="http://example.com/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql初学笔记</title>
    <link href="http://example.com/2021/02/27/mysql%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/02/27/mysql%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql笔记-（关系型数据库）"><a href="#mysql笔记-（关系型数据库）" class="headerlink" title="mysql笔记 （关系型数据库）"></a>mysql笔记 （关系型数据库）</h1><h2 id="一-使用终端操纵数据库"><a href="#一-使用终端操纵数据库" class="headerlink" title="一 使用终端操纵数据库"></a>一 使用终端操纵数据库</h2><h3 id="1-登录数据库"><a href="#1-登录数据库" class="headerlink" title="1. 登录数据库"></a>1. 登录数据库</h3><p>mysql -uroot -p</p><h3 id="2-查询所有数据库"><a href="#2-查询所有数据库" class="headerlink" title="2. 查询所有数据库"></a>2. 查询所有数据库</h3><p>show database;</p><h3 id="3-选中某一数据库操作"><a href="#3-选中某一数据库操作" class="headerlink" title="3. 选中某一数据库操作"></a>3. 选中某一数据库操作</h3><p>use database;</p><h3 id="4-查询"><a href="#4-查询" class="headerlink" title="4.查询"></a>4.查询</h3><p>select * from admin where admin_Id = 1</p><h3 id="5-退出"><a href="#5-退出" class="headerlink" title="5.退出"></a>5.退出</h3><p>exit;或quit;</p><h3 id="6-创建数据库"><a href="#6-创建数据库" class="headerlink" title="6.创建数据库"></a>6.创建数据库</h3><p>create database name;</p><h3 id="7-查看数据库中的数据表"><a href="#7-查看数据库中的数据表" class="headerlink" title="7.查看数据库中的数据表"></a>7.查看数据库中的数据表</h3><p>show tables;</p><h3 id="8-创建数据表"><a href="#8-创建数据表" class="headerlink" title="8.创建数据表"></a>8.创建数据表</h3><p>创建宠物数据表</p><pre><code>CREATE TABLE pet (name VARCHAR(20),owner VARCHAR(20),sex CHAR(1),birth DATE);</code></pre><h3 id="9-查看创建好的数据表"><a href="#9-查看创建好的数据表" class="headerlink" title="9. 查看创建好的数据表"></a>9. 查看创建好的数据表</h3><p>decribe pet;</p><h3 id="10-查看表中记录"><a href="#10-查看表中记录" class="headerlink" title="10 查看表中记录"></a>10 查看表中记录</h3><p>select * from pet;</p><h3 id="11-插入记录"><a href="#11-插入记录" class="headerlink" title="11.插入记录"></a>11.插入记录</h3><pre><code>INSERT INFO petVALUES (&#39;pp&#39;,&#39;mm&#39;,&#39;f&#39;,&#39;1999-03-26&#39;);</code></pre><h3 id="12-mysql-常用数据类型"><a href="#12-mysql-常用数据类型" class="headerlink" title="12.mysql 常用数据类型"></a>12.mysql 常用数据类型</h3><p>数值<br>类型|大小|范围（有符号|范围(无符号)|用途<br>-|:-:|:-:|:-:|:-:|-</p><p>日期/时间</p><p>字符串</p><p>数据类型选择 日期按照格式 数值和字符串按照大小</p><h3 id="13-删除数据"><a href="#13-删除数据" class="headerlink" title="13. 删除数据"></a>13. 删除数据</h3><p>delete from pet where name =’pp’;</p><h3 id="14-修改数据"><a href="#14-修改数据" class="headerlink" title="14.修改数据"></a>14.修改数据</h3><p>update pet set name=’旺财’ where owner = ‘mm’;</p><h3 id="15-mysql建表约束条件"><a href="#15-mysql建表约束条件" class="headerlink" title="15.mysql建表约束条件"></a>15.mysql建表约束条件</h3><p>1.主键约束</p><pre><code>id int(11) primary key</code></pre><p>它能够唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束就可以使该字段不重复且不为空。</p><p>可以有多个主键，主键联合约束。只要联合的主键值加起来不同即可。但联合主键每一个都不能为空。</p><ol start="2"><li><p>自增约束</p><p> primary key auto_increment<br>与主键约束搭配起来进行自增</p></li></ol><p>忘记添加主键，创建后添加</p><pre><code>alter table user4 add primary key(id);</code></pre><p>输出表结构主键</p><pre><code>alter table user4 drop primary key;</code></pre><p>修改字段主键约束</p><pre><code>alter table user4 modify id int primary key;</code></pre><ol start="3"><li>外键约束</li></ol><p><a href="https://blog.csdn.net/wdd199801140310/article/details/102984378">有主从表|主外键关系时删除表和删除数据</a></p><p>涉及到两个表，一个是主表，一个是副标，或父表，子表，外键设置在副表上</p><pre><code>create table classes(    id int primary key,    name varchar(20));create table students(    id int primary key,    name varchar(20),    class_id int,    foreign key(class_id) references classes(id));</code></pre><p>副表中的外键值要参照主表， 1.主表中没有的数据值，副表不能使用。2.被副表引用的主表值不允许被删除。</p><ol start="4"><li>唯一约束</li></ol><p>约束修饰的字段的值不可以重复</p><pre><code>name carchar(20) uniquealter table user add unique(name); </code></pre><p>可以unique(name, id)<br>这两个件在一起不重复就可以。</p><p>删除唯一约束</p><pre><code>alter table user drop index name</code></pre><p>modify 添加</p><pre><code>alter table user modify name varchar(20 unique);</code></pre><ol start="5"><li>非空约束</li></ol><p>修饰的字段不能为空</p><pre><code>create table user (    id int,    name varchar(20) not null);</code></pre><p>单独插入会报错</p><pre><code>insert into user (name) values &#39;list&#39;;</code></pre><ol start="6"><li>默认约束</li></ol><p>插入字段时，如果没有传值，使用默认值</p><pre><code>age int default 20</code></pre><h3 id="16-数据库设计三大设计范式"><a href="#16-数据库设计三大设计范式" class="headerlink" title="16.数据库设计三大设计范式"></a>16.数据库设计三大设计范式</h3><p>1.第一范式 1NF</p><p>数据表中的所有字段都是不可分割的原子值</p><pre><code>create table user (    id int primary key,    name varchar(20),    address varchar(30));</code></pre><p>字段值还可以继续拆分， 就不满足第一范式, 上表不满足第一范式</p><pre><code>create table user (    id int primary key,    name varchar(20),    cuntry varchar(30),    province varchar(30),    city varchar(30));</code></pre><p>上表拆分比较详细，满足第一范式。</p><p>范式设计一般来说越详细越好，但还是要根据具体工程。</p><ol start="2"><li>第二范式</li></ol><p>必须是满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖主键</p><p>如果出现不完全依赖，只可能发生在联合主键的情况下。某字段只依赖其中一个主键。</p><p>如果实在要这样，设计成外键关联，拆分表。</p><p>3.第三范式 3NF</p><p>必须先满足第二范式，除开主键列的其他列之间不能有传递依赖。不能有冗余依赖。需要拆分。</p><h3 id="17-查询联系"><a href="#17-查询联系" class="headerlink" title="17.查询联系"></a>17.查询联系</h3><p>学生表<br>Student<br>学号<br>姓名<br>性别<br>出生年月日<br>所在班级</p><pre><code>create table student &#123;    sno varchar(20) primary key,    sname varcher(20) not null,    ssex varchar(10) not null,    sbirthday datatime,    class varchar(20)&#125;</code></pre><p>成绩表<br>Score<br>学号<br>课程号<br>成绩</p><pre><code>create table score(    sno varchar(20) not null,    cno varchar(20) not null,    degree decimal,    foreign key(sno) references student(sno),    foreign key(cno) references course(cno),    primary key(sno, cno));</code></pre><p>查询所有记录 select * from student;</p><p>查询指定记录，（某些字段）， select sname, ssex, class from student;</p><p>查询不重复的depart列<br>select distinct depart from teacher;</p><p>查询区间<br>select * from score where degree between 60 and 80;<br>或者运算符比较<br>select * from score where degree &gt; 60 and degree &lt; 80;</p><p>查询或关系<br>select * from score where degree in (85, 86, 88);</p><p>查询表中性别为女的同学记录<br>select * from student where class=’95031’ or ssex=’女’;</p><p>以class降序查询<br>select * from student order by class desc;<br>默认升序或者arc</p><p>以cno升序，degree 降序查询所有记录<br>select * from score order by cno asc, degree desc;</p><p>查询总人数 count<br>select count(*) from student where class=’95031’;</p><p>查询最高分<br>select sno,cno from score where degree=(selectmax(degree) from score);</p><p>查询每门课的平均成绩</p><p>select avg(degree) from score where cno=’3-105’</p><p>select cno,avg(degree) from score group by cno;</p><p>查询score表中至少有两名学生选修的并以3开头的课程</p><p>select cno, avg(degree),count(*)) from score group by  cno having count(cno)&gt;=2 and cno like ‘3%’;</p><p>查询分数大于70小于90的sno列</p><p>select sno,degree from score where degree&gt;70 and degree &lt; 90;<br>或者用between and</p><p>多表查询</p><p>查询所有学生的sname, cno和degree</p><p>select sname,con,degree from student,score where student.sno=score.sno;</p><p>三表关联查询(重点)<br>通过字段相等联查</p><p>select sname,cname,degree from student,course,score where student.sno=score.sno and course.cno=score.cno;</p><p>查询’95031’班学生每门课的平均分</p><p>select cno,avg(degree) from score where sno in (select sno from student where class=’95031’) group by cno;</p><ol start="18"><li>查询”3-105”课程的成绩高于”109”号同学 “3-105”成绩的所有同学的记录。</li></ol><p>select * from score where cno= ‘3-105’ and degree &gt; (select degree from score where sno=’109’ and cno=’3-105’);</p><p>查询和学号为108、101的同学同年出生的所有学生的sno\sname和sbirthday列</p><p>select * from student where year(sbirthday) in (select year(sbirthday) from student where sno in (108, 101));</p><p>查询 “张旭” 教师任课的学生成绩</p><p>select * from score where cno =(select cno from course where tno= (select * from teacger where tname= ‘张旭’));</p><p>查询选修某课程的同学人数多于5人的教师姓名。</p><p>select tname from teacher where tno = (select tno from course where cno = (select cno from score groupby cno having count(*) &gt; 5;));</p><p>查询95033班和95031班全体学生的记录。</p><p>select * from student where class in (‘95031’, ‘95033’);</p><p>查询存在成绩在85分以上的课程的cno</p><p>select * from score where degree&gt;85;</p><p>查询出 “计算机系” 教师所有课程的成绩表</p><p>select * from score where cno in (select cno from course where tno in (select tno from teacher where depart= ‘计算机系’;));</p><p>查询 “计算机系” 与 “电子工程系”不同职称的教师的tnam和prof</p><p>union 求并集</p><p>select * from teacher where depart = ‘计算机系’ and prof not in (select prof from teacher where depart = ‘电子工程系’)<br>union<br>select * from teacher where depart = ‘电子工程系’ and prof not in (select prof from teacher where depart = ‘计算机系’)</p><p>查询选修编号为 “3-105”课程且成绩至少高于选修课程 “3-245”的同学的cno,sno和degree,并且按degree从高到低排序</p><p>select * from score where cno = ‘3-105’ and degree &gt; any(select degree from score where cno = ‘3-245’) order by degree desc;</p><p>查询选修编号为 “3-105”<br>且成绩高于选修编号为 “3-245” 的同学的 cnp\sno 和 degree</p><p>select * from score where cno= ‘3-105’ and degree&gt;all(select degree from score where cno=’3-245’);</p><p>查询所有教师和同学的name,sex和birthday</p><p>select tname as name,tsex as sex,tbirthday as birthday from teacher<br>union<br>select sname,ssex,sbirthday from student</p><p>查询成绩比该课程平均成绩低的同学的成绩表</p><p>select * from score a where degree &lt; (select avg(degree) from score b where a.cno=b.cno);</p><p>查询至少有两名男生的班号</p><p>select class from student where ssex= ‘男’ group by class having count(*)&gt;1;</p><p>查询student 表中最大值和最小sbirthday日期值</p><p>select max(sbirthday) as ‘最大’，min(sbirthday) as ‘最小’ from student;</p><h3 id="18-SQL的四中连接查询"><a href="#18-SQL的四中连接查询" class="headerlink" title="18 SQL的四中连接查询"></a>18 SQL的四中连接查询</h3><p>内连接<br>inner join 或者 join</p><p>外连接<br>1.左连接 left join 或者 left outer join</p><p>2.右连接 right join 或 outer join</p><p>3.完全外连接 full join 或者 full outer join</p><pre><code>create table person(    id int,    name varchar(20),    cardId int);create table card(    id int,    name varchar(20),);</code></pre><p>insert into person values();</p><p>inner join查询<br>select * from person inner join card on person.cardId = card.id;</p><p>内联查询，就是两章表中的数据，通过某个字段相对，查询出相关记录数据。</p><p>left join（左外连接）</p><p>select * from person left join card on person.cardId=card.id;</p><p>左外连接吧左边表里的所有数据取出来，右边表有相等显示出来，没有就会补null</p><p>right join（右外连接）</p><p>select * from person right (outer) join card on person.cardId=card.id;</p><p>同左外连接，左右互换</p><p>full join(全外链接)</p><p>select * from person full join card on person.cardId=card.id;</p><p>mysql不支持full join<br>求出两边表的并集</p><p>mysql通过union实现</p><p>select * from person left join card on person.cardId=card.id<br>union<br>select * from person right join card on person.cardId=card.id;</p><h3 id="20-mysql-事务"><a href="#20-mysql-事务" class="headerlink" title="20.mysql 事务"></a>20.mysql 事务</h3><p>mysql中，事务湿气重一个最小的不可分割的单元，事务能够保证一个业务的完整性。</p><p>多条mysql同时成功或者同时失败的要求。</p><p>mysql是默认开起事务的</p><p>默认事务开启的作用</p><p>当我们去执行一个sql语句时，效果立刻体现，不会回滚。</p><p>回滚是rollback；</p><p>设置自动提交为false<br>set autocommit=0;</p><p>begin或者start transaction 开启一个事务，之后可以回滚<br>直到commit</p><p>事务的四大特征</p><p>A.原子性：事务是最小单位，不可以分割</p><p>C.一致性：事务要求，同一事物中的sql语句必须同时成功或失败</p><p>I。隔离性：事务1和事务2之间具有隔离性。</p><p>D.持久性：事物一旦结束（commit,rollback），就不可以返回。</p><p>事务开启</p><p>1.修改默认提交 set autocommit=0;</p><p>2.begin</p><p>3.start transaction</p><p>事务的隔离性</p><p>1.read uncommited (读未提交)</p><p>事务对数据进行操作，在操作过程中，事务没有被提交，但是b可以看见a操作的结果。</p><p>查看隔离级别mysql8.0</p><p>系统级别</p><p>select @@global.transaction_isolation;</p><p>会话级别</p><p>select @@transaction_isolation</p><p>设置</p><p>set global transaction isolation level read uncommited;</p><p>这种读未提交的叫做脏读</p><p>2.read commited<br>(读已经提交)</p><p>3.repeatable read<br>(可以重复读)</p><p>4.serializable<br>(串行化)</p><h2 id="二-使用可视化工具操纵数据库"><a href="#二-使用可视化工具操纵数据库" class="headerlink" title="二 使用可视化工具操纵数据库"></a>二 使用可视化工具操纵数据库</h2><h2 id="三-在编程语言中使用数据库"><a href="#三-在编程语言中使用数据库" class="headerlink" title="三 在编程语言中使用数据库"></a>三 在编程语言中使用数据库</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql笔记-（关系型数据库）&quot;&gt;&lt;a href=&quot;#mysql笔记-（关系型数据库）&quot; class=&quot;headerlink&quot; title=&quot;mysql笔记 （关系型数据库）&quot;&gt;&lt;/a&gt;mysql笔记 （关系型数据库）&lt;/h1&gt;&lt;h2 id=&quot;一-使用终端操纵数</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloudalibaba</title>
    <link href="http://example.com/2021/02/27/springcloudalibaba/"/>
    <id>http://example.com/2021/02/27/springcloudalibaba/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-nacos实时QPS"><a href="#1-nacos实时QPS" class="headerlink" title="1 nacos实时QPS"></a>1 nacos实时QPS</h1><p>服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户端，由客户端进行服务限流降级等操作。客户端的操作行为也会被推送到服务端，从而形成QPS</p><h1 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h1><ol><li>服务发现组件nacos</li><li>配置中心组件nacos</li><li>断路保护组件sentinel</li><li>远程组件dubbo,而原来是Openfeign</li><li>seata分布式事务</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-nacos实时QPS&quot;&gt;&lt;a href=&quot;#1-nacos实时QPS&quot; class=&quot;headerlink&quot; title=&quot;1 nacos实时QPS&quot;&gt;&lt;/a&gt;1 nacos实时QPS&lt;/h1&gt;&lt;p&gt;服务端内部保存滑动时间窗口，存储当前一秒QPS，会推送到客户</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloud_netflix</title>
    <link href="http://example.com/2021/02/27/springcloud_netflix/"/>
    <id>http://example.com/2021/02/27/springcloud_netflix/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springcloud生态"><a href="#springcloud生态" class="headerlink" title="springcloud生态"></a>springcloud生态</h1><p><a href="https://www.bilibili.com/video/BV1jJ411S7xr?p=15">springcloud</a></p><h2 id="1-4-个问题"><a href="#1-4-个问题" class="headerlink" title="1 4 个问题"></a>1 4 个问题</h2><ol><li>API （解决网关）</li><li>HTTP， RPC（解决分布式通讯）</li><li>注册和发现（解决高可用）</li><li>熔断机制（进行服务降级）</li></ol><p>微服务：将单一的应用程序划分成一组小的服务</p><blockquote><p>mycat 数据库读写分离  elastic search</p></blockquote><p>spring cloud netflix</p><p>spring cloud 中国社区·</p><p>eureca是对应zookeeper的</p><h2 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2 Eureka"></a>2 Eureka</h2><p>是Netflix的一个子模块，是一个机遇rest的服务</p><ol><li>导入依赖</li><li>编写配置文件</li><li>开启这个功能@Enable</li><li>配置类</li></ol><p>eureka好死不如赖活着</p><p>eureka与zookeeper区别</p><p>CAP三选二<br>C 强一致性<br>A 可用性<br>P 分区容错性</p><p>zookeeper保证的是CP，enreka保证的是AP</p><blockquote><p>面试题，两者的区别</p></blockquote><h2 id="3-ribbon"><a href="#3-ribbon" class="headerlink" title="3 ribbon"></a>3 ribbon</h2><ol><li>spring cloud ribbon 是基于netflix实现的一套客户端负载均衡工具</li></ol><p>nginx是集中时，由nginx决定分发给谁</p><p>ribbon是进程时，由消费方通过注册中心获取所有可用，通过算法决定如何选择。</p><blockquote><p>feign是面向接口版本的ribbon, 也是负载均衡的</p></blockquote><h2 id="4-Hystrix"><a href="#4-Hystrix" class="headerlink" title="4 Hystrix"></a>4 Hystrix</h2><p>Hystrix 可以提供服务熔断和服务降级</p><p>服务熔断机制是对应雪崩效应的一种微服务链路保护机制</p><p>相关概念，备份，服务降级</p><p>服务熔断是提供者，服务降级是消费者</p><p>降级是客户端的，因为后台为了释放资源已经关闭了，可以用feign配合hystrix来进行</p><p>服务熔断：服务端，某个服务超时或者异常，引起熔断，保险丝</p><p>服务降级：客户端，从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再会被调用，不走服务器。此时在客户端，我们可以准备一个FallbackFactory，返回一个默认的值，但整体服务水平下降了。</p><h1 id="5-路由网关-zuul"><a href="#5-路由网关-zuul" class="headerlink" title="5 路由网关 zuul"></a>5 路由网关 zuul</h1><ol><li>身份验证和安全性</li><li>监控</li><li>动态路由</li><li>压力测试</li><li>减载</li><li>静态响应处理</li><li>多区域弹性</li></ol><blockquote><p>统一路由，统一权限认证</p></blockquote><p>通过配置文件对请求进行路由和过滤</p><h1 id="6-spring-cloud-config"><a href="#6-spring-cloud-config" class="headerlink" title="6 spring cloud config"></a>6 spring cloud config</h1><p>config为微服务架构中的微服务提供集中化的外部配置支持 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springcloud生态&quot;&gt;&lt;a href=&quot;#springcloud生态&quot; class=&quot;headerlink&quot; title=&quot;springcloud生态&quot;&gt;&lt;/a&gt;springcloud生态&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilib</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/02/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903490196619272">操作系统内存管理</a></p><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">图解内存管理</a>(重点)</p><h1 id="1-存储区体系"><a href="#1-存储区体系" class="headerlink" title="1 存储区体系"></a>1 存储区体系</h1><p>主存（RAM）是一件非常重要的资源，不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多。</p><h2 id="1-1-分层存储器体系-memory-hierarchy"><a href="#1-1-分层存储器体系-memory-hierarchy" class="headerlink" title="1.1 分层存储器体系(memory hierarchy)"></a>1.1 分层存储器体系(memory hierarchy)</h2><p><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/DCDF99335BF54511A72AC2890C6F17FD/14946" alt="存储层次结构"></p><h2 id="1-2-无存储抽象"><a href="#1-2-无存储抽象" class="headerlink" title="1.2 无存储抽象"></a>1.2 无存储抽象</h2><p>将物理内存暴露给进程的缺点：</p><ol><li>如果用户程序可以寻址内存的每个字节，他们就可以很容易的破坏操作系统，从而使系统停止运行。</li><li>难以运行多个程序（地址冲突）</li></ol><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><blockquote><p>MMU(内存管理单元)：硬件组件负责处理CPU的内存访问请求</p></blockquote><h2 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h2><p>更好的支持多道程序并发执行，提高系统性能。进程之间共享的不仅仅是处理机，还有主存储器。如果不对内存进行管理，容易导致内存数据的混乱。</p><h2 id="2-2-内存管理功能"><a href="#2-2-内存管理功能" class="headerlink" title="2.2 内存管理功能"></a>2.2 内存管理功能</h2><ul><li>内存空间的分配与回收</li><li>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</li><li>内存空间的扩充：虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li><li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li><li>程序装入和链接<h2 id="2-3-逻辑地址空间和物理地址空间"><a href="#2-3-逻辑地址空间和物理地址空间" class="headerlink" title="2.3 逻辑地址空间和物理地址空间"></a>2.3 逻辑地址空间和物理地址空间</h2></li><li>编译后，每个目标模块都是从0号单元开始编址（逻辑地址），链接程序顺序依次按各个模块的相对地址构成从0号单元开始编址的逻辑地址空间。</li><li>物理地址空间指内存中物理单元的集合。通过物理地址在主存中存取数据。</li><li>当装入程序将可执行代码装入内存时，必须通过地址转换讲逻辑地址转换成物理地址，这个过程称为地址重定位<h2 id="2-4-内存保护"><a href="#2-4-内存保护" class="headerlink" title="2.4 内存保护"></a>2.4 内存保护</h2></li></ul><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p><ul><li>设置上下限寄存器存放主存中的上下限地址判断是否越界。</li><li>采用重定位寄存器（基址寄存器，存放最小的物理地址值）和界地址寄存器（限长寄存器，存放逻辑地址的最大值）。<h1 id="3-管理方式"><a href="#3-管理方式" class="headerlink" title="3 管理方式"></a>3 管理方式</h1></li></ul><h2 id="3-0-逻辑地址与物理地址的转换"><a href="#3-0-逻辑地址与物理地址的转换" class="headerlink" title="3.0 逻辑地址与物理地址的转换"></a>3.0 逻辑地址与物理地址的转换</h2><ol><li>ALU需要某个逻辑地址的内存的内容</li><li>内存管理单元（MMU）寻找在逻辑地址和物理地址之间的映射，如果没有就从内存中找。（操作系统完成）</li><li>控制器从总线发送在物理内存内容的请求</li><li>内存发送物理地址给CPU</li></ol><h2 id="3-1-连续分配管理方式"><a href="#3-1-连续分配管理方式" class="headerlink" title="3.1 连续分配管理方式"></a>3.1 连续分配管理方式</h2><ol><li>单一连续分配：分配到内存固定区域，只适合单任务系统</li><li>固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不相等。内部碎片（已经被分配出去（能明确是哪个线程），却不能被利用的内存空间）<ul><li>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</li></ul></li><li>动态分区分配：按程序的需要进程动态划分。外部碎片（还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。）<ul><li>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br><a href="https://www.cnblogs.com/sjlove/archive/2013/06/05/3119683.html">外部碎片和内部碎片</a><h2 id="3-2-空闲内存管理"><a href="#3-2-空闲内存管理" class="headerlink" title="3.2 空闲内存管理"></a>3.2 空闲内存管理</h2>在进行内存动态分配时，操作系统必须对其进行管理。一般来说，有两种监控内存使用的方式</li></ul></li></ol><ul><li>位图（bitmap）（基于表的）：使用位图方法时，内存被划分为分配单元，每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。位图的大小取决于内存和分配单元的大小。</li><li>位图的分配：找到连续的0。</li><li>空闲列表（free lists）（基于链的）：维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点会包含进程或者是两个进程间的空闲区域。</li><li>空闲列表的分配：（动态分区分配算法）<br><br>(如果为进程和空闲区维护各自独立的链表，就能集中精力只检查空闲区而不是进程，但这种分配速度的提高的一个不可避免的代价就是增加复杂度和内存释放速度变慢，因为必须将一个回收的段从进程链表中删除并插入空闲区链表)<ol><li>首次适配：从头开始扫描，直到找到一个足够大的空闲区</li><li>下次适配：从上次结束的地方开始扫描</li><li>最佳适配：从头到尾扫描，找到能容纳进程的最小空闲区。会产生大量无用的小缓冲区。</li><li>最差适配：总是分配最大的内存区域（不会分裂出小缓冲区）</li><li>快速适配：为常用大小的空闲区维护单独的链表。<br>[位图和空闲链表]<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">https://blog.csdn.net/qq_22238021/article/details/80175461</a>)</li></ol></li></ul><h2 id="3-3-非连续分配管理方式"><a href="#3-3-非连续分配管理方式" class="headerlink" title="3.3 非连续分配管理方式"></a>3.3 非连续分配管理方式</h2><p>对于内存的连续分配，总是会有碎片的产生，内存利用率低，而且执行碎片整理的方法也都是有开销的。因此，非连续内存分配就能很好的解决碎片问题，也是操作系统中用的最多的内存分配方法。<br>非连续分配（分页/分段）允许一个程序分散地装入到不相邻的内存分区中去。</p><h3 id="3-3-1-基本分页存储管理方式"><a href="#3-3-1-基本分页存储管理方式" class="headerlink" title="3.3.1 基本分页存储管理方式"></a>3.3.1 基本分页存储管理方式</h3><p><a href="https://zhuanlan.zhihu.com/p/87514615">分页分段解释较好</a></p><p>内存分为固定的块，按物理结构划分，会有内部碎片</p><ol><li>基本概念<ul><li>页<ul><li>一定大小字节数内存单元，属于逻辑单元。进程中所有代码、数据等信息均按页进行存储，属于逻辑组织形式。每个页有页码及其他信息。</li></ul></li><li>页框<ul><li>对应页字节数的物理内存，属于物理单元，是实际存在于物理内存中的可用地址单元。页框相当于页的容器，进程运行过程中，可能会动态加载不同页进入页框，CPU则直接对页框进行存取。</li></ul></li><li>页表<ul><li>既然有页和对应页框，那就必须有映射表将两者联系起来，而页表就是页和页框之间的映射表。换言之，知道页就可以查询到页框，知道页框，也可以查询到对应页。</li></ul></li><li>进程中的块称为页，内存中的块称为页框，外存以同样的单位进行划分，称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框。</li><li>地址结构 页号 + 页内偏移量</li><li>页表 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建3立一张页表，记录页面在内存中对应的物理块号。页表一般放在内存中。</li></ul></li><li>基本地址变换机构<br><br>页式管理中地址空间是一维的<br><br>两个主要问题：<ul><li>每次访问操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低</li><li>每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li></ul></li><li>具有快表的地址变换机构</li></ol><ul><li>若页表全部放在内存中，则存取一条数据或指令至少需要访问两次内存：一次访问页表，确定物理地址，第二次存取数据或指令</li><li>快表/联想寄存器/TLB 在地址变换机构中的一个具有并行查找能力的高速缓冲存储器。用来存放当前访问的若干页表项，以加速地址变换的过程。主存中的页表称为慢表。</li></ul><ol start="4"><li>两级页表<br><br>一级页号+二级页号+页内偏移</li><li>分页和分段的区别<ul><li>页是信息的物理单位，分页是为了减少内存碎片，提高内存利用率。分页仅仅是由于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它包含一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统确定，逻辑地址的划分是由寄存器实现的，因而一个系统只能有一种大小的页面。段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<h3 id="3-3-2-基本分段存储管理模式"><a href="#3-3-2-基本分段存储管理模式" class="headerlink" title="3.3.2 基本分段存储管理模式"></a>3.3.2 基本分段存储管理模式</h3></li></ul></li></ol><p>内存块的大小不固定，按逻辑结构划分，会有外部碎片。</p><h1 id="4-内存扩充"><a href="#4-内存扩充" class="headerlink" title="4 内存扩充"></a>4 内存扩充</h1><h2 id="4-1-覆盖"><a href="#4-1-覆盖" class="headerlink" title="4.1 覆盖"></a>4.1 覆盖</h2><p>在较小的内存中运行较大的内存，将没有调用关系的程序放在一个分区。可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分里即将访问的段放进覆盖区，其他段放在外存。<br><img src="http://note.youdao.com/yws/public/resource/375267987e6a5e59121a79328ccdf2bc/xmlnote/BE6AB4C1E94E42FD8718721D3956E4C3/15170"><br>B，D，E没有调用关系，也就是说，在调用B时，不可能同时调用D或E，所以共享一个覆盖区。早期用这个技术来节约内存。</p><h2 id="4-2-交换"><a href="#4-2-交换" class="headerlink" title="4.2 交换"></a>4.2 交换</h2><p>将暂时不能运行的程序送到外存，从而获得空闲内存空间。粒度是一个程序，需要操作系统支持，对程序员透明。</p><p>把处于等待状态的程序从内存移到辅存，把内存空间腾出来（换出）。把准备好竞争CPU运行的程序从辅存移到内存（换入）</p><ol><li>覆盖与交换的比较<ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间。</li><li>交换技术是在以内存中的程序大小为单位来进行的，一般一页以上。不需要程序员给出各个模块之间的逻辑覆盖结构。</li><li>覆盖和交换都有它的局限性，覆盖过于麻烦，而交换的粒度太大，以程序为单位。所以需要虚拟内存技术。</li></ul></li></ol><h2 id="4-3-虚拟内存"><a href="#4-3-虚拟内存" class="headerlink" title="4.3 虚拟内存"></a>4.3 虚拟内存</h2><p>随着软件的不断增大，需要运行的程序往往大到内存无法容纳。应用交换技术并不是很高效（交换几GB的内存）。</p><p>虚拟内存使用了外存上的空间来扩充内存的空间，通过一定的换入换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，导致平均访存时间下降，如果使用了不合适的替换算法，则会<br>大大降低系统性能。</p><ul><li>虚拟存储器：对物理存储器的抽象，允许程序申请大于实际物理存储的内存，提供一致性的地址空间。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统讲所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放要掉入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</li><li>内存管理单元（Memory Management Unit， MMU），MMU把虚拟地址映射为物理内存地址。</li></ul><h3 id="4-3-1-局部性原理"><a href="#4-3-1-局部性原理" class="headerlink" title="4.3.1 局部性原理"></a>4.3.1 局部性原理</h3><ul><li>时间局部性：如果一条指令被执行或某个数据被访问过，那么不久以后该指令可能再次执行，该数据可能再次被访</li><li>空间局部性：如果某个单元被访问过，那么不久之后它周围的空间也会被访问。<h3 id="4-3-2-特征"><a href="#4-3-2-特征" class="headerlink" title="4.3.2 特征"></a>4.3.2 特征</h3></li></ul><ol><li>多次性， 无需在作业时一次性全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性，无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出</li><li>虚拟性，从逻辑上扩充内存的容量，用户看到的内存容量，远大于实际的内存容量<h3 id="4-3-3-虚拟技术内存的实现"><a href="#4-3-3-虚拟技术内存的实现" class="headerlink" title="4.3.3 虚拟技术内存的实现"></a>4.3.3 虚拟技术内存的实现</h3></li><li>一定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序访问到的部分尚未调入内存，则产生中断</li><li>地址变换机构，逻辑地址到物理地址的变换</li></ol><h3 id="4-3-4-请求分页管理方式"><a href="#4-3-4-请求分页管理方式" class="headerlink" title="4.3.4 请求分页管理方式"></a>4.3.4 请求分页管理方式</h3><ol><li>页表机制</li></ol><ul><li>页号</li><li>物理块号</li><li>保护位：允许对该页做何种类型的访问（只读、可读写、）</li><li>驻留位：指示该页在内存还是在外存</li><li>访问字段A：记录本页在一段时间内被访问的次数，或多长时间未被访问（用于页面置换算法）</li><li>修改位M：标识该页在调入内存后收否被修改过</li><li>外存地址：该页在外存上的地址</li></ul><ol start="2"><li>缺页中断机构</li></ol><ul><li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成时唤醒），如果内存中有空闲块则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页。（若被淘汰页在内存期间被修改过，则要将其写回外存）</li></ul><ol start="3"><li>地址变换机构<br><img src="http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/8E649EF21B8F4CDCB559DDDAE97F147E/15122"></li></ol><h3 id="4-3-5-页面置换算法（决定应该换入哪页，换出哪页）"><a href="#4-3-5-页面置换算法（决定应该换入哪页，换出哪页）" class="headerlink" title="4.3.5 页面置换算法（决定应该换入哪页，换出哪页）"></a>4.3.5 页面置换算法（决定应该换入哪页，换出哪页）</h3><ol><li>最佳置换算法（OPT）：选择在最长时间内不在被访问的页面换出。实际上该算法无法使用</li><li>先进先出（FIFO）页面置换算法：淘汰最早进入内存的页面</li><li>最近最久未使用（LRU）置换算法：选择最长时间未访问的页面淘汰需要TLB实现（硬件支持 双向链表+hash</li><li>时钟（CLOCK）（Not Recently Used，NRU）置换算法：循环扫描缓冲区，像时钟的针一样转动。给每一帧关联一个使用位。当缺页错误出现时，首先检查指针指向的页面，如果R位是0就淘汰页面，并把新页面插入，然后表针前移；如果R位是1就清零前移。和第二次算法性能差不多，花费更少时间，实际使用的算法.</li><li>工作集置换算法，一个进程当前使用的页面的集合称为工作集。</li><li>工作集时钟页面置换算法</li><li>LFU（ Least Frequently Used，最不频繁使用）两个双向链表+hash</li><li>第二次机会页面置换算法：在FIFO基础上增加使用位，如果链首使用位是1则清零加入链尾。相比FIFO性能大大提高</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903490196619272&quot;&gt;操作系统内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_29677867/article/details/91038</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://example.com/2021/02/27/zookeeper/"/>
    <id>http://example.com/2021/02/27/zookeeper/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1 zookeeper"></a>1 zookeeper</h1><p><a href="https://www.bilibili.com/video/BV1BA411q7ia?p=31">zookeeper+Dubbo</a></p><p>包括数据发布订阅、负载均衡、命名服务、集群管理分布式锁、分布式队列等功能。</p><ol><li>zookeeper提供了分布式数据一致性解决方案</li></ol><p>一致性：</p><ul><li>强一致性：锁机制、如果数据不一致，不提供服务</li><li>最终一致性：数据最终同步即可，没有实时性要求</li></ul><ol start="2"><li>CAP原则（一致性、可用性和分区容错性）</li></ol><ul><li>一致性：指的是强一致性 (C)</li><li>可用性：服务一直处于可用状态 (A)</li><li>分区容错性：在遇到任何网络分区故障，仍需要对外提供一致性和可用性服务。(P)<br>3选2， 要么AP 要么CP</li></ul><ol start="2"><li><p>一致性协议</p><ul><li><p>2PC二阶段提交</p><ul><li>阶段一预执行，但事务没有提交</li><li>阶段二执行事务提交或者中断事务，如果所有参与者都返回ack，则执行事务，否则中断<blockquote><p>这一个过程需要协调者</p><br></blockquote></li></ul></li><li><p>二阶段提交的问题</p><ul><li>同步阻塞：协调者发送消息后需要阻塞</li><li>单点：如果协调者挂了，就完了</li><li>脑裂导致数据不一致：如果协调者与某个节点断开，有些节点提交了，有些没有不一致</li></ul></li><li><p>3PC阶段提交</p><ul><li>阶段1，协调者向所有参与者发送canCommit询问，能否响应事务请求，相当于网络测试</li><li>阶段2，如果阶段1所有节点都能通讯，所有都执行预提交，也就是preCommit操作预提交，如果某个节点返回no或等待超时，则则中断事务。</li><li>阶段3，doCommit，如果所有阶段2都成功，执行提交，发送提交请求，否则中断事务。</li></ul></li><li><p>3PC解决了同步阻塞和单点问题，一个是超时时间解决同步阻塞，一个是如果协调者在三阶段挂了，其他节点没收到commit会自动提交</p></li></ul></li><li><p>paxos算法</p><ul><li>基于消息传递且具有高度容错性的一种算法，是目前公认的解决分布式一致性问题的最有效的算法。</li><li>解决问题，在分布式系统中，如果产生宕机或网络异常，快速的正确的在集群内部解决数据一致性问题（过半理念）zookeeper基于 fast paxos版本</li><li>paxos中的四个角色<ul><li>client：产生提案者</li><li>peoposer：提案者</li><li>acceptor：决策者</li><li>learners: 学习者（只遵循最后的结果）</li></ul></li><li>paxos分为两个阶段<ul><li>阶段1：prepare阶段：准备解决</li><li>阶段2：accept阶段：同意阶段</li></ul></li><li>prepare阶段<ul><li>proposer做出一个提案，编号为n发送给所有acceptor。</li><li>第一次接受prepare请求：maxN被保存，同时响应</li><li>不是第一次，每个决策者保存一个最大提案号maxN,如果n小于maxN，证明提案已过时，拒绝。如果大于maxN，更新maxN，进行响应。</li><li>如果收到的响应过半，立刻进入第二阶段。</li></ul></li><li>accept阶段<ul><li>传递编号n和value， (n, value)，如果n大于等于maxN,同意提案，进行响应。如果小于，那么拒绝提案，不会响应。</li></ul></li></ul><ol><li> 活锁问题（解决办法，执行时间稍稍错开）</li></ol></li><li><p>zookeeper 使用的是ZAB（Fast Paxos），因为Paxos存在活锁和全序的问题</p></li></ol><ul><li>ZAB（zookeeper atomic broadcast）：是一种支持崩溃恢复的原子广播协议</li><li>Zookeeper使用单一主进程Leader处理客户端发送过来的所有事务请求（写清求）。当服务器数据发生变更后，会把请求包装成提案，发送给所有follower，只要follower达到半数，同意请求，之后leader通知所有follower，进行同步数据。读请求的话，leader会自己响应。</li><li>如果客户端发送到follower上的话，如果是读请求，follwer自己响应，否则是写清求的话，会将请求转发给leader，走leader的流程。</li></ul><ol start="5"><li>zookeeper的三种角色</li></ol><ul><li>leader：主要负责处理集群的写清求，并发起投票，只有超过半数的节点同意后才会提交该写请求</li><li>follower：处理读请求，响应结果。转发写清求得到leader,并在选举leader过程中参与投票。</li><li>observer：可以理解为没有投票权的follower，主要职责是协助follower处理读请求，当整个zk集群读请求负载很高时，增加。如果增加follower会增加写请求负载，因为follower也要投票。</li></ul><ol start="5"><li>zookeeper两种模式</li></ol><ul><li>恢复模式：当服务启动或领导崩溃后，zk进入恢复状态，选举leader，leader选出后，完成leader和其他机器的同步，当大多数server完成和leader的同步后，恢复模式结束。</li><li>广播模式：一旦leader已经和多数的Follower进行了状态同步后，进入广播模式。进入广播模式后，如果有新加入的服务器，会自动从leader中同步数据。leader在接收客户端请求后，会生成事务提案广播给其他机器，有超过半数以上的follower同意该提议后，再提交事务。</li><li>在ZAB的事务的二阶段提交中，移除了事务的中断，要么ack，要么放弃，leader无需等待所有的follower的ack.</li></ul><ol start="6"><li>zxid</li></ol><ul><li>zxid是64位长度的Long类型，其中高32位表示纪元epoch，低32位表示事务标识xid</li></ul><ol start="7"><li>leader选举原则<ol><li>zookeeper集群只有超过了半数以上的服务器启动，集群才能正常工作</li><li>在集群正常工作之前，myid小的服务器会给myid大服务器进行投票，持续到集群正常工作，选出leader</li><li>选出leader之后，之前的服务器的状态由looking改变为following,之后的服务器都是follower</li></ol></li><li>zab解决全序问题，因为事务执行顺序不同，导致结果不同，leader会创建一个队列，保证最终结果。</li></ol><blockquote><p>相关操作</p></blockquote><blockquote><ol><li>ls path watch 监听节点子节点的变化</li></ol></blockquote><blockquote><ol start="2"><li>get path watch 监听节点值的变化</li></ol></blockquote><blockquote><ol start="3"><li>监听的有效期只有一次</li></ol></blockquote><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h1><ol><li>配置中心</li></ol><ul><li>把配置信息存在节点中，通过监听来同步</li></ul><ol start="2"><li>负载均衡</li></ol><ul><li>新增服务器，让nginx知道服务器列表的更新。通过监听器监视servers子节点的状态变化。</li></ul><ol start="3"><li>命名服务</li></ol><ul><li>创建顺序节点保证唯一标识</li></ul><ol start="4"><li>DNS服务</li><li>集群管理<ol><li>集群控制：对集群中节点进行操作与控制</li><li>集群监控：对集群节点运行状态的收集</li></ol></li></ol><ul><li>zookeeper集群管理主要利用了watcher机制和创建临时节点来实现。比如机器上下线：<ul><li>新增机器的时候，将Agent部署到新增的机器上，当Agent部署启动时，会向zookeeper指定的节点下创建一个临时子节点，通过监视器，对机器的上下线进行监控。</li><li>当子节点创建完成后，机器会接受到”子节点变更事件”，即上限通知，就可以对新加入的机器开启相应的后台管理逻辑。监控中心同样可以获得到机器的运行状态信息。</li></ul></li></ul><ol start="6"><li>分布式锁<ol><li>数据库实现分布式锁，让不同的服务器操作同一个数据库。使用dblock.lock();添加一条记录，lock_name:db_lock_stock。注意这个lock_name是惟一的，如果已经存在，需要阻塞。</li><li>redis实现分布式锁，基于setnx（set if not exists），设置成功返回1，否则返回0.要注意设置过期时间，防止异常，expire name time。redis为了解决单点问题，官方推出了分布式锁redlock</li><li>zookeeper实现分布式锁<ul><li>原理：创建有序临时节点+watch监听来实现。每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己剩下的临时节点的序号是否是最小的。如果是最小的，将会获取到锁，执行相关操作，释放锁。如果不是最小的，会监听它的前一个节点，当它的前一个节点被删除时，它就会获得锁，依次类推。</li></ul></li></ol></li><li>分布式队列：跟分布式锁相似，监听之前的节点是否出列</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-zookeeper&quot;&gt;&lt;a href=&quot;#1-zookeeper&quot; class=&quot;headerlink&quot; title=&quot;1 zookeeper&quot;&gt;&lt;/a&gt;1 zookeeper&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>创建型模式</title>
    <link href="http://example.com/2021/02/27/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/27/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;noodle&quot;)) &#123;</span><br><span class="line">            Food noodle &#x3D; new LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(&quot;more&quot;);</span><br><span class="line">            return noodle;</span><br><span class="line">        &#125; else if (name.equals(&quot;chicken&quot;)) &#123;</span><br><span class="line">            Food chicken &#x3D; new HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(&quot;potato&quot;);</span><br><span class="line">            return chicken;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单工厂模式可以理解为根据类名，通过if else创建不同的类。一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><h1 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 工厂模式</h1><p>定义一个接口，接口中有方法，不同的实际类会实现这个接口，这个方法会创建对象，这样通过多态就可以创建对象。每个工厂可以生产多个产品。</p><h1 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3 抽象工厂模式"></a>3 抽象工厂模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简单工厂模式&quot;&gt;&lt;a href=&quot;#1-简单工厂模式&quot; class=&quot;headerlink&quot; title=&quot;1 简单工厂模式&quot;&gt;&lt;/a&gt;1 简单工厂模式&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>大话设计模式</title>
    <link href="http://example.com/2021/02/27/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/27/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>设计模式分为三大类：</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="一、简单工厂模式与工厂方法模式（重点可看大话设计模式）-https-blog-csdn-net-qq-34337272-article-details-80472071"><a href="#一、简单工厂模式与工厂方法模式（重点可看大话设计模式）-https-blog-csdn-net-qq-34337272-article-details-80472071" class="headerlink" title="一、简单工厂模式与工厂方法模式（重点可看大话设计模式） https://blog.csdn.net/qq_34337272/article/details/80472071"></a>一、简单工厂模式与工厂方法模式（重点可看大话设计模式） <a href="https://blog.csdn.net/qq_34337272/article/details/80472071">https://blog.csdn.net/qq_34337272/article/details/80472071</a></h1><h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h2><p>简单工厂模式实际上就是创建一个接口，这个接口有相关类的某种抽象功能或者特性，这个接口或父类的对象就是简单工厂中的产品。</p><p>在实际使用中，我们只需要创建某个类实现这个借口，或者继承父类，就可以创建子类对象，投入到简单工厂中。</p><p>再创建一个工厂类，这里可以采用两种办法，第一种使用switch，但就不符合开放封闭原则。第二种使用反射， obj = Class.forName(clazz.getName()).newInstance(); 这种方法可以在增加子类产品时不需要修改工厂类。</p><h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2 工厂方法模式"></a>2 工厂方法模式</h2><p>工厂方法模式是定义一个用于创建对象的接口，由子类对象决定实例化哪一个。</p><p>工厂方法模式与简单工厂的一个区别，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p><p>工厂方法模式，将工厂类进行抽象，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。换句话说，工厂方法模式中的要素有四个：</p><p>抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 </p><p>具体工厂(Concrete Factory)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 </p><p>抽象产品(AbstractProduct)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</p><p>具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应</p><p>这样，我们创建抽象类型的工厂类，其实际对象为具体工厂类（对应具体产品），可以将实现方法剥离。在调用时，我们只需要生成生产具体产品的具体工厂类，调用其中的统一方法即可。</p><h2 id="3-抽象工厂方法"><a href="#3-抽象工厂方法" class="headerlink" title="3 抽象工厂方法"></a>3 抽象工厂方法</h2><p>抽象工厂是生产一整套有产品的方法（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。</p><p>也就是说抽象工厂类中不再只有一抽象种产品，而是多个抽象产品。再创建具体工厂时要对两种产品做出@Override。每种抽象产品又有多个具体产品实现类。</p><p>举个例子，抽象工厂代表某军事工事，其能生产抽象产品枪和子弹，具体的工厂为某品牌工厂，在该具体工厂类中，其所重写的方法即是生产该品牌公司所生产的具体产品枪和子弹。</p><p>这样也有缺点，极有可能会违反抽象封闭原则，比如增加公司，这个问题可用反射解决。</p><h1 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h1><h2 id="1-预加载"><a href="#1-预加载" class="headerlink" title="1 预加载"></a>1 预加载</h2><p>还没有实例化该对象，该对象就已经加载到内存中。这种方法会造成内存的浪费。</p><pre><code>public class PreloadSingleton &#123;   public static PreloadSingleton instance = new PreloadSingleton();   //其他的类无法实例化单例类的对象   private PreloadSingleton() &#123;   &#125;;   public static PreloadSingleton getInstance() &#123;          return instance;   &#125;&#125;</code></pre><h2 id="2-懒加载（这里涉及到线程加锁保证安全问题）"><a href="#2-懒加载（这里涉及到线程加锁保证安全问题）" class="headerlink" title="2 懒加载（这里涉及到线程加锁保证安全问题）"></a>2 懒加载（这里涉及到线程加锁保证安全问题）</h2><p>用到该单例对象时再创建，可避免内存浪费，但不是线程安全的。</p><pre><code>public class Singleton &#123;   private static Singleton instance=null;   private Singleton()&#123;   &#125;;   public static Singleton getInstance()   &#123;          if(instance==null)          &#123;                 instance=new Singleton();          &#125;          return instance;   &#125;&#125;</code></pre><h1 id="三、装饰器模式"><a href="#三、装饰器模式" class="headerlink" title="三、装饰器模式"></a>三、装饰器模式</h1><p>装饰器模式中有四个类很重要。</p><p>1.Component（被装饰对象的基类）<br>   定义一个对象接口，可以给这些对象动态地添加职责。</p><p>2.ConcreteComponent（具体被装饰对象）<br>   定义一个对象，可以给这个对象添加一些职责。</p><p>3.Decorator（装饰者抽象类）<br>   维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。</p><p>4.ConcreteDecorator（具体装饰者）<br>   具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</p><p>以商城为例子，如下：</p><ol><li>Component抽象类</li></ol><pre><code>public abstract class Component &#123;    public abstract void operation();&#125;</code></pre><ol start="2"><li>ConretetComponent类（具体被装饰物类）</li></ol><pre><code>public class ConcreteComponent extends Component &#123;    @Override    public void operation() &#123;        System.out.println(&quot;具体对象的操作&quot;);    &#125;&#125;</code></pre><p>3 Decorator装饰类</p><pre><code>public abstract class Decorator extends Component &#123;    private Component component = null;    //通过构造函数传递给被修饰者    public Decorator(Component component) &#123;        this.component = component;    &#125;    //委托给被修饰者执行    @Override    public void operation() &#123;        if(component != null) &#123;            this.component.operation();        &#125;    &#125;&#125;</code></pre><p>4 ConcreteDecorator类（具体装饰类）</p><pre><code>public class ConcreteDecoratorA extends Decorator &#123;    //定义被修饰者    public ConcreteDecoratorA(Component component) &#123;        super(component);    &#125;    //定义自己的修饰方法    private void method1() &#123;        System.out.println(&quot;method1 修饰&quot;);    &#125;    @Override    public void operation() &#123;        this.method1();        super.operation();    &#125;&#125;public class ConcreteDecoratorB extends Decorator &#123;    //定义被修饰者    public ConcreteDecoratorB(Component component) &#123;        super(component);    &#125;    //定义自己的修饰方法    private void method2() &#123;        System.out.println(&quot;method2 修饰&quot;);    &#125;    @Override    public void operation() &#123;        super.operation();        this.method2();    &#125;&#125;</code></pre><p>5 Client客户端</p><pre><code>public class Client &#123;    public static void main(String[] args) &#123;        Component component = new ConcreteComponent();        //第一次修饰        component = new ConcreteDecoratorA(component);        //第二次修饰        component = new ConcreteDecoratorB(component);        //修饰后运行        component.operation();    &#125;&#125;</code></pre><p>这里说一下装饰过程，首先生成了具体被装饰类component，第一次生成装饰器A，其内部的组件对象为原始的component,然后生成装饰器B，此时其内部组件对应的是componentA,在调用componentB的operation时，会先调用父类decorator的方法operation，该方法会调用当前存储的对象componentA的operation方法，这样实现了一级一级的传递过程。</p><h1 id="四-代理模式"><a href="#四-代理模式" class="headerlink" title="四 代理模式"></a>四 代理模式</h1><p><a href="https://www.cnblogs.com/daniels/p/8242592.html">https://www.cnblogs.com/daniels/p/8242592.html</a> 记录较为清楚</p><p>代理模式分为静态代理和动态代理</p><p>动态代理类如下：</p><pre><code>package main.java.proxy.impl;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxyHandler implements InvocationHandler &#123;private Object object;public DynamicProxyHandler(final Object object) &#123;    this.object = object;&#125;@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;    System.out.println(&quot;买房前准备&quot;);    Object result = method.invoke(object, args);    System.out.println(&quot;买房后装修&quot;);    return result;&#125;&#125;</code></pre><p>测试类如下：</p><pre><code>package main.java.proxy.test;import main.java.proxy.BuyHouse;import main.java.proxy.impl.BuyHouseImpl;import main.java.proxy.impl.DynamicProxyHandler;import java.lang.reflect.Proxy;public class DynamicProxyTest &#123;    public static void main(String[] args) &#123;    BuyHouse buyHouse = new BuyHouseImpl();    BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new            Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));    proxyBuyHouse.buyHosue();&#125;&#125;</code></pre><p>注意Proxy.newProxyInstance()方法接受三个参数：<br>ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法。</p><h1 id="五-原型模式"><a href="#五-原型模式" class="headerlink" title="五 原型模式"></a>五 原型模式</h1><p>这个模式要注意两个地方</p><p>1 深拷贝和浅拷贝，使用clone是深拷贝，但this.MemberwiseClone是拷贝的对象是拷贝的引用为浅拷贝，要一层一层的深拷贝。</p><p>2 要注意实现Cloneable 接口，调用super.Clone方法</p><h1 id="六-外观模式"><a href="#六-外观模式" class="headerlink" title="六 外观模式"></a>六 外观模式</h1><p>spring mvc就是一个外观模式的例子，在维护一个大型系统时。开发外观类与之对接可以降低偶合。</p><h1 id="七-策略模式"><a href="#七-策略模式" class="headerlink" title="七 策略模式"></a>七 策略模式</h1><h1 id="八-模板方法（与策略模式很像）"><a href="#八-模板方法（与策略模式很像）" class="headerlink" title="八 模板方法（与策略模式很像）"></a>八 模板方法（与策略模式很像）</h1><p>模板模式关注统一算法的不同实现，策略模式关注不同算法。</p><p>模板模式将不变的行为放到超类中。</p><p>可看servlet源码</p><h1 id="九-建造者模式（生成器模式）"><a href="#九-建造者模式（生成器模式）" class="headerlink" title="九 建造者模式（生成器模式）"></a>九 建造者模式（生成器模式）</h1><h1 id="十-适配器模式"><a href="#十-适配器模式" class="headerlink" title="十 适配器模式"></a>十 适配器模式</h1><p>模式说明：</p><ul><li>包装类 = 适配器Adapter；</li><li>被包装对象 = 适配者Adaptee = 被适配的类</li></ul><p>作用：</p><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MagaGenericServlet implements Servlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象类继承了Servlet类，对于需要实现的内容进行空实现 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;&#x2F;login&quot;)</span><br><span class="line">public class LoginServlet1 extends MagaGenericServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;我被执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;设计模式分为三大类：&lt;/p&gt;
&lt;p&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。&lt;/p&gt;
&lt;p&gt;结构型模</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统常见问题</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同步和异步的区别"><a href="#1-同步和异步的区别" class="headerlink" title="1 同步和异步的区别"></a>1 同步和异步的区别</h1><p>同步和异步通常用来形容一次方法调用</p><ul><li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li><li>异步方法调用更像一个消息传递，一旦开始，方法调用就回立即返回，调用者就可以继续后续的操作。异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。<h1 id="2-进程和线程的区别，谁调度的进程"><a href="#2-进程和线程的区别，谁调度的进程" class="headerlink" title="2 进程和线程的区别，谁调度的进程"></a>2 进程和线程的区别，谁调度的进程</h1></li></ul><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、数据段和堆栈段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的话费远比进程要小很多，同时创建一个线程的开销也比进程小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。但是如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。<h1 id="3-死锁的条件，如何检查死锁"><a href="#3-死锁的条件，如何检查死锁" class="headerlink" title="3 死锁的条件，如何检查死锁"></a>3 死锁的条件，如何检查死锁</h1></li></ol><ul><li>死锁的定义： 多个进程因为竞争资源而造成一种僵局（互相等待），若无外力作用，所有的进程都无法向前推进。</li><li>死锁的必要条件：互斥、不剥夺、请求和保持、循环等待</li><li>解决死锁：破坏条件，资源剥夺、撤销进程，进程回退</li><li>用银行家算法预防和避免死锁。</li></ul><h1 id="4-调度算法有哪些"><a href="#4-调度算法有哪些" class="headerlink" title="4 调度算法有哪些"></a>4 调度算法有哪些</h1><p>先来先服务、最短寻道时间、扫描算法、Look算法</p><h1 id="5-进程的状态转换图及转换事件"><a href="#5-进程的状态转换图及转换事件" class="headerlink" title="5 进程的状态转换图及转换事件"></a>5 进程的状态转换图及转换事件</h1><h1 id="6-进程的通信机制"><a href="#6-进程的通信机制" class="headerlink" title="6 进程的通信机制"></a>6 进程的通信机制</h1><p>临界区、互斥量、信号量、事件</p><p>管道、具名管道、消息队列、共享内存、信号量</p><ul><li>管道： 父子进程通过管道通信，管道是一种两个进程间单向通信的机制，因为管道传递数据的单向性，管道又被称为半双工管道，管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。（没有名字、大小受限、没有格式的字节流）</li><li>具名管道：FIFO，提供一个路径名与之关联，存在与文件系统中，这样即使与创建FIFO的进程不存在亲缘关系的进程，只要可以访问路径，就能够通过彼此的FIFO通信。因此，通过FIFO不相关进程也能交换数据</li><li>消息队列：消息队列用与同一机器上的进程间通信，与管道类似，是一个系统内核中保存消息的队列，在内核中以消息链表的形式出现。消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。</li><li>共享内存：共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的程序间共享和传递数据的一种非常有效的方式。不同进程间的内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的内存空间中，所有进程都可以访问共享内存中的地址。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及统一进程内不同线程之间的同步手段。</li></ul><p><a href="https://blog.csdn.net/qq_29677867/article/details/91038642?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control#121__49">内存管理</a></p><p><a href="https://blog.csdn.net/qq_43684985/article/details/109255207">文件管理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-同步和异步的区别&quot;&gt;&lt;a href=&quot;#1-同步和异步的区别&quot; class=&quot;headerlink&quot; title=&quot;1 同步和异步的区别&quot;&gt;&lt;/a&gt;1 同步和异步的区别&lt;/h1&gt;&lt;p&gt;同步和异步通常用来形容一次方法调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步方法调用一</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统相关概念</title>
    <link href="http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统（operating-System，-OS）"><a href="#1-操作系统（operating-System，-OS）" class="headerlink" title="1 操作系统（operating System， OS）"></a>1 操作系统（operating System， OS）</h1><p>操作系统是计算机系统中最基本的系统软件</p><h2 id="1-1-操作系统作用"><a href="#1-1-操作系统作用" class="headerlink" title="1.1 操作系统作用"></a>1.1 操作系统作用</h2><ol><li>管理分配资源，组织调度计算机的工作<ul><li>处理机管理（进程管理）</li><li>存储器管理（内存）</li><li>文件管理（文件系统）</li><li>设备管理（I/O）</li></ul></li><li>为用户和其他软件提供接口和环境。<ul><li>命令接口：用户利用这些命令来组织和控制作业的运行<ul><li>交互式命令接口（联机）</li><li>批处理命令接口（脱机）</li></ul></li><li>程序接口：系统调用，请求操作系统服务。<h2 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2 操作系统特征"></a>1.2 操作系统特征</h2></li></ul></li><li>并发：两个或多个事件在同一时间间隔内发生。通过分时实现。</li><li>共享：指系统中的资源可供内存中多个并发的进程共同使用。<ul><li>互斥共享方式</li><li>同时访问方式</li></ul></li><li>虚拟： 把一个物理上的实体变为若干个逻辑上的对应物。</li><li>异步：并发执行时，由于资源有限，进程的执行不是一贯到底而是走走停停，以不可预知的速度向前推进。<h2 id="1-3-操作系统的运行机制"><a href="#1-3-操作系统的运行机制" class="headerlink" title="1.3 操作系统的运行机制"></a>1.3 操作系统的运行机制</h2></li><li>内核态：操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。内核态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令,包括：<ul><li>时钟管理：计时中断实现进程切换</li><li>中断机制</li><li>原语：<ul><li>处于操作系统的最底层，是最接近硬件的部分</li><li>操作不可中断（关闭中断，让其所有动作执行完在打开中断）</li><li>运行时间较短且调用频繁。</li></ul></li><li>系统控制的数据结构及处理：<ul><li>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理： 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理：缓冲区管理、设备分配和回收等<blockquote><p>系统调用运行在系统的内核态，为了获取操作系统的服务，用户程序必须使用系统调用，系统调用会转换为内核态并且调用操作系统。</p></blockquote></li></ul></li></ul></li><li>用户态：只使用了机器指令中的一个子集，将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</li><li>中断：<ul><li>中断，外中断，来自CPU执行指令以外的事件的发生。（外设请求、人为干预）</li><li>异常，内中断，源自CPU执行指令内部的事件。（指令中断、硬件故障、软件中断）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统（operating-System，-OS）&quot;&gt;&lt;a href=&quot;#1-操作系统（operating-System，-OS）&quot; class=&quot;headerlink&quot; title=&quot;1 操作系统（operating System， OS）&quot;&gt;&lt;/a&gt;1 </summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T12:46:40.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="1-查询优化"><a href="#1-查询优化" class="headerlink" title="1 查询优化"></a>1 查询优化</h2><p>查询优化分为代数优化和物理优化</p><p>简单来说，代数优化是优化查询的次数，尽可能将选择操作先做。</p><p>物理优化，可以理解为建立索引。</p><h2 id="2-字符集"><a href="#2-字符集" class="headerlink" title="2 字符集"></a>2 字符集</h2><ol><li><p>查看字符集编码设置</p><p> <code>mysql&gt; show variables like &#39;%character%&#39;;</code></p></li><li><p>设置字符集编码</p><p> <code>mysql&gt; set names &#39;utf8&#39;;</code></p></li></ol><h2 id="3-大表优化"><a href="#3-大表优化" class="headerlink" title="3 大表优化"></a>3 大表优化</h2><p><a href="https://segmentfault.com/a/1190000006158186">https://segmentfault.com/a/1190000006158186</a></p><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><p>限定数据的范围</p><p> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p></li><li><p>读/写分离</p><p> 经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p>分区</p><ul><li><p>垂直分区</p><p>  根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>  简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p><p>  垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>  垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p></li><li><p>水平分区</p><p>  保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>  水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p>  水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p><p>  水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p>  下面补充一下数据库分片的两种常见方案：</p><ul><li>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库优化&quot;&gt;&lt;a href=&quot;#数据库优化&quot; class=&quot;headerlink&quot; title=&quot;数据库优化&quot;&gt;&lt;/a&gt;数据库优化&lt;/h1&gt;&lt;h2 id=&quot;1-查询优化&quot;&gt;&lt;a href=&quot;#1-查询优化&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
