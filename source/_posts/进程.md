---
title: 进程
date: 2021-2-28
cover:
top_img:
categories: 操作系统
tags: 
mathjax: true
katex: true
---
# 1 程序与进程

进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数据）的真正运行实例。

进程结构一般由3部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享同一个代码段。数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数的参数，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括了进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。

- 进程是程序的一次执行
- 进程是一个程序及数据在处理机执行时所发生的活动
- 进程时系统进行资源分配和调度的独立单位。进程的独立运行由进程控制块PCB控制和管理。进程映像时静态的进程。程序段、相关数据、PCB三部分构成了进程映像。PCB进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。

# 2 进程状态
1. 运行状态：进程在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态
2. 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行
3. 阻塞状态：又称等待状态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入输出的完成。即使处理机空闲，该进程也不能运行。
4. 创建状态：进程正在被创建。
5. 结束状态：进程正从系统中消失。

# 3 linux系统进程启动过程

0号进程–>1号内核进程->1号内核线程–>1号用户进程–>getty进程–>shell进程

整个linux系统的所有进程也是一个树结构。树根时系统自动构造的，即在内核态下执行的0号进程，它是所有进程的祖先。由0号进程创建1号进程（内核态），1号负责执行内核的部分初始化工作及进行系统配置，并创建若干个用于告诉缓存和虚拟储存管理的内核线程。

随后1号进程调用execve（）运行可执行程序init，并演变成用户态1号进程，他按照系统配置文件/etc/initab的要求，完成系统的启动工作，创建编号为1号、2号等若干终端注册进程getty。当getty检测到来自终端的信号时， getty将通过 execve执行注册程序 login， 此时就可以通过用户名、密码登录。如果登录成功，login() 程序执行shell， shell进程接替 getty 进程的pid 取代getty进程。后续进程再通过shell产生。

# 4 进程的创建

创建状态：进程正在创建尚未就绪，经过几个创建步骤：申请空白PCB、向PCB写入控制和管理信息、然后为进程分配所需资源、最后转入就绪状态。

## 4.1 引起进程创建的事件
- 系统创建
    - 用户登录：分时系统中户登录都可以看成一个新的进程。系统为该终端创建一个新的进程并插入就绪队列
    - 作业调度：批处理作业中，当系统按照一定算法调度作业时，将该作业调入内存为其分配资源，提供服务。
- 用户请求：用户可以基于自己的需求创建进程

## 4.2 进程创建的过程

1. 为进程申请一个唯一的进程识别号和空白PCB（PCB是有限的，若PCB申请失败则创建失败）
2. 为进程分配资源、为新进程的程序、数据、用户栈分配内存空间（如果资源不足，并不是创建失败，而是处于等待状态，等待资源。
3. 初始化PCB，主要包括标志信息、状态信息、处理机信息等。
4. 如果就绪队列能够接受新进程，就将进程插入就绪队列中

## 4.3 Linux下的进程创建

父进程和子进程：除了0号进程，Linux系统中其他任何一个进程都是由其他进程创建的。而相对的，fork函数的调用方是父进程，创建的新进程是子进程。

fork函数不需要参数，返回值是一个进程标识符。

1. 对于父进程，fork函数返回创建子进程的ID
2. 子进程fork函数返回0
3. 创建出错的话fork函数返回-1

fork函数创建了一个新的进程，并从内核中为其分配一个可用的进程标识符PID，之后为其分配进程空间，并将父进程空间的内容复制到子进程空间，包括数据段和堆栈段，与父进程共享代码段。这时候系统中多了一个进程，父进程和子进程都接受系统的调度。由于复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。fork函数返回两次，分别在父进程和子进程中返回。
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(void){
    pid_t pid;
    pid = fork();
    if(pid<0){
        perror("fail to fork");
        exit(-1);
    }else if(pid ==0){
        printf("Subprocess, PID: %u", getpid());
    }else{
        printf("Parentprocess, PID: %u", getpid());
    }
    return 0;
}
```
子进程完全复制了父进程的地址空间，包括堆栈段和数据段。但是子进程并未复制代码段，而是共用代码段。
# 5 进程的结束

结束状态：进程从系统中消失，这可能因为正常结束或其他原因中断退出。进程结束时，系统首先置该进程为结束状态，然后进一步释放和回收资源。

## 5.1 进程结束的事件
1. 正常结束
2. 异常结束：出现某种错误导致无法运行：越界、非法指令、运行超时等
3. 外界干预：进程应外界请求而终止。
## 5.2 进程的终止过程
1. 根据被终止的标识符，检索PCB，从中读取进程状态
2. 若进程处于执行状态，立即终止并置标志为真
3. 若进程还有子孙进程，则终止子孙进程防止其不可控
4. 将终止进程的所有资源释放给系统或父进程
5. 将终止进程移除队列
## 5.3 进程的切换
1. 保留处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
4. 选择另一个进程执行，并更新其PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文。

# 6 孤儿进程和僵尸进程
在linux中，正常情况下子进程是通过父进程创建的，子进程和父进程的运行是一个异步的过程。父进程无法预料子进程在何时结束，于是就产生了孤儿进程和僵尸进程

## 6.1 孤儿进程
指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对他们完成状态收集工作。
## 6.2 僵尸进程
是指一个进程使用fork创建子进程，如果子进程退出，而父进程没有用wait或waitpid调用子进程的状态信息，子进程的进程描述符仍在系统中，这种进程被成为僵尸进程。

简单理解为，孤儿是父进程已退出而子进程未退出；而僵尸进程是父进程未退出而子进程先退出。

为了避免僵尸进程，需要父进程通过wait函数来回收子进程。

## 6.3 守护进程

在Linux系统的引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。守护进程是脱离于终端在后台运行的进程，守护进程脱离终端是为了避免进程在执行过程中在终端上显示并且不会被终端的信息打断。

守护进程是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。守护进程常常在系统引导装入时启动，在系统关闭时终止。Linux系统有很多的守护进程，大多数服务都是通过守护进程实现的。如作业规划进程、打印进程。

在Linux中每一个与用户交流的界面称为终端，每一个终端开始的进程都会依附于该终端，这个终端就被称为进程的控制终端，当控制终端被关闭时，相应的进程都会被关闭。但是守护进程可以突破这种限制，他从被执行是开始运转，整个系统关闭时才退出。如果想让某个进程不因为用户或终端等变化受到影响，那么就需要把一个进程变成一个守护进程。

# 7 进程通信

进程间通信就是不同进程间传播或交换信息。首先进程间可以通过传送、打开文件来实现，不同的进程通过一个或多个文件来传递信息。一般来说进程间通信不包括这种低级的通信方式。Linux操作系统几乎支持所有的UNIX系统进程通信方法：管道、消息队列、共享内存、信号量、套接字。

## 7.1 管道

父子进程通过管道通信，管道是一种两个进程间单向通信的机制。因为管道传递数据的单向性，管道又被称为半双工管道。管道这一特点决定了其使用的局限性。管道是最原始的一种通信方式。

无名管道的特点：
1. 数据只能由一个进程流向另一个进程（一个读管道和一个写管道）；如果要进行双工通信，则需要建立两个管道。
2. 管道只能用于父子通信或兄弟进程通信（有亲缘关系的进程）。

除了上述局限性，管道还有一些不足，比如管道没有名字（匿名管道）；管道的缓冲区大小受限（Linux下一般是4kb）；管道传输的是无格式的字节流等。这就需要管道输入方和输出方事先约定好数据格式。使用管道通信时，两端的进程向管道读写数据是通过创建管道时，系统设置的文件描述符进行的。本质上说管道也是一种文件，但它又和一般的文件不同，可以克服文件通信的一些问题。

通过管道通信的两个进程，一个向管道写数据，一个从中读数据。写入的数据每次都添加到管道缓冲区的末尾，读数据都是从缓冲区的头部读出。

## 7.2 具名管道

还有一种管道叫具名管道（FIFO）它的不同之处是它提供一个路径名与之关联，以FIFO的形式存在于文件系统中。这样即使与FIFO创建不存在亲缘关系的进程，只要可以访问路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程和创建FIFO的进程之间），因此通过FIFO不相关的进程也能交换数据。

有名管道的特点：
1. 它可以使互不相关的两个进程实现通信
2. 该管道可以通过路径名来指明，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当作普通文件一样读写，使用很方便。
3. FIFO严格遵守先进先出的规则，对于管道与FIFO，总是从开始处返回数据，而把数据添加到末尾。

![有名管道和无名管道的区别](http://note.youdao.com/yws/public/resource/eed1fa7701b0e40871bca24194444756/xmlnote/54BB3B539E804E7997F19381159A517F/14746)

## 7.3 消息队列

消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现。

消息队列与有名管道有不少相同之处，消息队列进行通信可以使不相关的进程，同时他们都是以发送和接受的方式来传递数据的。而且他们都有一个最大长度的限制。

与命名管道相比，消息队列的优势在于：
1. 消息队列可以独立于发送和接受进程存在，从而消除了同步命名管道打开和关闭时可能产生的的困难。
2. 可以同时通过发送消息以避免命名管道的同步和阻塞问题，而不需要由进程自己来提供同步方法
3. 接受程序可以通过消息类型有选择的接受数据，而不是向命名管道中那样，只能默认地接受。

事实上它是一种正在被淘汰的通信方式，完全可以用流管道和套接口的方式取代。

## 7.4 共享内存

共享内存允许两个不相关的程序访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据一种非常有效的方式。不同进程间的共享内存通常安排在同一物理内存中。进程可以将同一段内存共享到自己的地址空间中，所有进程都可以访问共享内存中的地址。

不过，共享内存未提供同步机制，需要进程自行进行同步操作。

共享内存的优缺点：
1. 优点：使用共享内存通信非常方便，而且函数接口简单，数据共享还使用进程间的数据不用传送，而是直接访问内存，加快了效率，并没有亲缘关系的要求。
2. 缺点：共享内存没有提供同步机制，这使得共享内存的通信往往要借助其他手段来完成。

## 7.5 信号量

共享内存是进程间通信的最快的方式，但是共享内存的同步问题自身无法解决（即进程该何时去共享内存取得数据，而何时不能取），但用信号量可以轻易解决这个问题。

# 8 进程调度

## 8.1 调度层次
进程调度分为三级调度，作业调度，中级调度，进程调度
1. 作业调度（高级调度）：主要任务是按照一定原则从外存中将处于后备状态的作业挑选一个或多个，分配内存、输入输出等资源，建立相应进程。使得他们拥有竞争处理机的权力（内存与辅存之间的调度），每个作业只调入一次，调出一次。具体过程：选择作业→bai分配资源→建立进程du（建立进程：申请空zhi白PCB → 分配资源 → 初始化PCB →插入进程就绪队列）
2. 内存调度。 进程的挂起与就绪。提高内存利用率和系统吞吐量。
3. 低级调度，按某种方法和策略从就绪队列中选取一个进程，为期分配处理机。
## 8.2 调度算法
1. 先来先服务算法（FCFS）
    - FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度
    - FCFS是不可剥夺算法，长作业会使后到的短作业长期等待
    - 算法简单，效率低，对长作业有利，有利于CPU繁忙性工作
2. 短作业优先（SJF，Short Job First）算法
    - 从后备队列中选择一个或若干个估计运行时间最短的作业掉入内存运行
    - 对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态
3. 优先级调度算法
    - 优先级调度算法每次从后备队列中选取优先级最高的一个或几个作业
    - 优先级调度可以剥夺时占有，也可以非剥夺式占有
4. 高响应比优先
    - 高响应比优先是对FCFS和SJF算法的一种平衡，计算每个作业的响应比
    - 响应比的计算为（等待时间 + 要求服务时间）/要求服务时间
5. 时间片轮转调度算法
    - 时间片轮转算法适用于分时系统，系统讲所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms
    - 受系统响应时间影响，队列进程数目，进程长短影响较大
6. 多级反馈队列调度算法
    - 多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展
    1. 设置多个就绪队列，为各个队列赋予优先级，1，2，3等
    2. 赋予各个队列中时间片大小不同，优先级高时间片越小
    3. 一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入2级队列的末尾，依次向下执行。
    4. 仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推
# 9 进程同步
1. 临界区
    - 虽然多个进程可以共享系统中的资源，但许多资源一次只能被一个进程使用，把一次仅允许一个进程使用的资源称为临界资源
2. 同步
    - 进程之间具有直接制约关系，进程之间需要按照一定的次序进行
3. 互斥
    - 进程之间的间接制约关系，不能同时访问临界区
4. 信号量
    - 信号量是一个整形变量，可以被定义为两个标准的原语wait(S),signal(S)即P，V操作
        - P操作 如果信号量大于0， 执行-1操作，如果等于0，执行等待信号量大于0
        - V操作 对信号量完成加1操作，唤醒睡眠的进程
```
typedef int semaphore
semaphore mutex = 1 
void P1(){
    P(&mutex);
    //临界区
    V(&mutex);
}
void P2(){
    P(&mutex);
    //临界区
    V(&mutex);
}
```
5. 管程
- 管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块
    - 使用信号量机制时，进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。
    - 管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用
    - 引入管程的目的：1. 把分散在各进程中的临界区集中起来进行管理；2. 防止进程有意无意的违反同步操作;3. 便于高级语言程序书写和验证。
6. 生产者-消费者问题
<br> 问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品
<br>
由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问
<br>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区
```
# define N 100
typedef int semahpore
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer(){
    while(True){
        int item = produceItem();
        P(&empty);
        P(&mutex);
        Item.push(item);
        V(&mutex);
        V(&full);
    }
}

void consumer(){
    while(True){
        P(&full);
        P(&mutex);
        int item = Item.top();
        Item.pop();
        consume(item);
        V(mutex);
        V(&empty())
    }
}
```
7. 读写者问题
<br>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行

用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁

```
typedef int semaphore
semaphore count = 0;
semaphore read_mutex = 1;
semaphore write_mutex = 1;

void read(){
    P(&read_mutex);
    count++;
    if(count==1) P(&write_mutex);
    V(&read_mutex);
    read();
    p(&read_mutex);
    count--;
    if(count==0) V(&write_mutex);
    V(&read_mutex);
}

void write(){
    P(&write_mutex);
    write();
    V(&write_mutex);
}
```
8. 哲学家进餐问题
<br>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根
<br>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待
```
typedef int semaphore
semaphore chop[5] = {1,1,1,1,1};
semaphore mutex = 1;

void process(){
    while(true){
        P(&mutex);
        P(chop[i]);
        P(chop[(i+1)%5]);
        V(&mutex);
        eat();
        V(chop[i]);
        V(chop[(i+1)%5]);
    }
}
```