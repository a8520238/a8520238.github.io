---
title: 网络安全
date: 2021-2-28
cover:
top_img:
categories: 计算机网络
tags: 
mathjax: true
katex: true
---
# 1 安全通信

1. 机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密
2. 报文完整性（message integrity） 确保没有被改动
3. 端点鉴别（end-point authentication） 确定通信双方
4. 运行安全性（operational security）

# 2 对称加密和非对称加密

1. 对称加密<br>
加密过程：
<br> 加密：原文 + 密匙 = 密文
<br> 解密：密文 - 密匙 = 原文
2. 非对称加密
<br>
使用不同的密钥进行加密和解密，对原文使用公钥加密，则只能使用对应的私钥才能解密。

# 3 Diffie-Hellman密钥交换算法

1. Alice 和 Bob 协商出两个数字 N 和 G 作为生成元
2. 现在 Alice 和 Bob 心中各自想一个数字出来，分别称为 A 和 B
3. 现在 Alice 将自己心里的这个数字 A 和 G 通过某些运算得出一个数 AG，然后发给 Bob；Bob 将自己心里的数 B 和 G 通过相同的运算得出一个数 BG，然后发给 Alice
4. Alice 可以通过 BG 和自己的 A 通过某些运算得到一个数 ABG，Bob 也可以通过 AG 和自己的 B 通过某些运算得到 ABG，这个数就是 Alice 和 Bob 共有的秘密

# 4 公开密钥加密

公钥用于加密，私钥用于解密。（RSA）

但是非对称加密算法无法确定通信双方的身份，会遭到中间人的攻击。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。

也就是你不知道你收到的公钥是不是伪造者发出的

# 5 报文完整性和数字签名

## 报文完整性

有两种攻击：1 针对被动攻击 ( 截获 ) : 加密 ;
2 针对主动攻击 ( 篡改 , 伪造 ) : 需要使用 鉴别 ;

密码散列函数的附加性质：找到任意两个不同的报文x和y使得`$H(x)=H(y)$`,在计算上是不可能的。

报文鉴别码：
1. Alice生成报文m并计算散列`$H(m)$`
2. 然后Alice将`$H(m)$`附加到报文m上，生成一个扩展报文（m, H(m)),并将该扩展报文发给Bob
3. Bob接收到一个扩展报文（m，h）并计算`$H(m)$`，如果`$H(m)=h$`,Bob会认为一切正常。

缺陷： 其他人可以生成虚假报文（m’, H(m’)),Bob无法发现这种行为。

为解决这种缺陷，需要鉴别密钥（authentication key），共享秘密s。（也就是对散列值加密）

1. Alice生成报文m, 用s级联m以生成m+s，并计算散列`$H(m+s)$`。`$H(m+s)$`称为报文鉴别码（Message Authentication Code，MAC）
2. 然后Alice将MAC附加到报文m上，生成一个扩展报文（m, H(m+s)),并将该扩展报文发给Bob
3. Bob接收到一个扩展报文（m，h）并计算`$H(m+s)$`，如果`$H(m+s)=h$`,Bob会认为一切正常。

# 6 数字签名

数字签名是一种在数字领域表明身份的密码技术。

用私钥加密数据，然后把加密的数据公布出去，这就是数字签名。

1. 公钥认证
<br> 证书就是公钥+签名，由第三方认证机构颁发。
<br> 证书认证的流程：
    1. Bob去可信任的认证机构正是本人真实身份，并提供自己的公钥
    2. Alice想和Bob通信时，先向认证机构请求Bob的公钥，认证机构会将一张证书（bob的公钥以及自己对其公钥的签名）发送给Alice
    3. Alice检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。
    4. Alice通过这个公钥加密数据，开始和Bob通信。
> 正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份。

# 7 HTTPS

HTTPS是身披SSL外壳的HTTP， 当HTTP加上加密处理和认证以及完整性保护后就是HTTPS。HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（secure socket layer）和TLS（transport layer security）协议代替。采用了SSL后，HTTP就有了HTTPS的加密、证书、和完整性保护这些功能。

1. Https为了兼顾安全与效率，同时使用了对称加密和非对称加密。
    - 数据是被对称加密传输的
    - 对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输
    - 对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。

2. HTTPS在传输过程中涉及到三个密钥：服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密
3. 一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
    - 客户端向服务器发起HTTPS请求，连接到服务器的443端口
    - 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
    - 服务器将自己的公钥发送给客户端。
    - 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
    - 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
    - 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
    - 然后服务器将加密后的密文发送给客户端。
    - 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。


4. SSL
    - SSL记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。
    - SSL握手协议：它建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

[网络安全](https://yqzzxlj.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/)

# 8 CSRF
![CSRF](http://note.youdao.com/yws/public/resource/ee0240bc38d981dd714fac885bebb768/xmlnote/BA662715544C491E8EDDB0F6D5038C4B/15384)
    - 登录受信任网站A，并在本地生成Cookie。
    - 在不登出A的情况下，访问危险网站B。

1. 防止CSRF原理
- 用户请求信息的时候，被骇客获取中间请求信息，当然也会获取token信息，但是因为骇客并不能阻止用户请求到目标网站。
- 用户请求目标网站之后，token已经被校验。所以骇客获取的token信息依然无用。
- 当时骇客如果在用户请求到目标网站之前先去请求到目标网站，token的作用就没有了。
2. 现在很多登陆选择基于token的登陆认证方案，一般也是把token缓存在localStorage里
    - 会话劫持"是一种常见攻击手段, 攻击者通过XSS注入获取非Http-Only的明文Cookies或者通过网络嗅探直接获取全部请求内容,从而得到Session标识的值
    - CSRF利用的是浏览器访问网页会自动携带该网页的cookie的特性来攻击，此攻击不会获取浏览器执行环境、cookie、token，将token加入HTTP头是用户自己的行为，不是浏览器自发行为，所以对于CSRF攻击而言，token是相对安全的；
    - 对于XSS攻击而言，攻击者已经可以注入脚本，完全获得代码执行环境，这个时候cookie和token都不安全了，相对而言，cookie还可以设置HttpOnly来防止js获取，但是token就完全裸奔了，攻击者就可以完成提问者所说的攻击了；

# 9 XSS
[美团XSS](https://tech.meituan.com/2018/09/27/fe-security.html)