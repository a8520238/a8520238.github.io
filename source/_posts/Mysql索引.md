---
title: mysql索引
date: 2021-2-28
cover:
top_img:
categories: 数据库
tags: 
mathjax: true
katex: true
---
# Mysql索引

Mysql索引使用的数据结构主要有BTree索引 和 哈希索引。

哈希索引对应哈希表，InnoDB BTree 对应 B+ Tree

[Mysql索引详解](https://www.cnblogs.com/l199616j/p/11232392.html)
## 1 MyISAM 与 InnoDB Index的区别

- MyISAMl（非聚集索引）: B+ 树叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
- InnoDB(聚集索引), 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。**
- 聚集索引适用的场合：
    + 包含大量非重复值的列。
    + 使用下列运算符返回一个范围值的查询：BETWEEN、>、>=、< 和 <=。
    + 被连续访问的列。
    + 返回大型结果集的查询。
    + 经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。
    + OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。

![应用场景](http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/3D230F580DE94664934DB386CE5D48C8/3566)

[MYSQL索引：对聚簇索引和非聚簇索引的认识](https://blog.csdn.net/alexdamiao/article/details/51934917)

## 2 索引

- 索引：索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

### 2.1 索引的优点

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
4. 在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

> 使用索引的原因：访问磁盘块时，若访问非键字段，需要遍历表空间 On。添加所用可以使用二分查找，降低到logN

### 2.2 索引的缺点

1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 2.3 索引的使用

添加：
1. INDEX indexName (Field_name(length))
2. ALTER TABLE table_name ADD INDEX index_name (column_list) (普通索引)
3. CREATE INDEX index_name ON table_name (column_list)
4. CREATE UNIQUE INDEX index_name ON table_name (column_list) (UNIQUE索引)

删除：
1. DROP INDEX [indexName] ON [table_name];
2. alter table [table_name] drop index [index_name] ;
3. alter table [table_name] drop primary key ;

> 如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。

查看：
1. SHOW INDEX FROM [table_name];
2. show keys from [table_name];

# 2.4 针对存储性质的讲解

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。


## 3 索引的数据结构B-Tree和B+Tree

目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.

### 3.1 B树

B树也就是二叉搜索树，也有说法是B树与B-树等价

[B树和B-树的剖析（建树过程）](https://www.jianshu.com/p/1775b4ff123a)
### 3.2 B-Tree
![B-树存储](http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/8F052C172C834AFC8BFF711812E724BE/3601)
![B-树键结构](http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606)

B-树的键区间为开区间，非叶子节点可结束

### 3.3 B+Tree(Mysql)

1. n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的K个关键字。
4. B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。
5. B+ 树中，数据对象的插入和删除仅在叶节点上进行。
6. B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

![B+树存储](http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/DB87125DAF1E40B8B1FFFDD842163FD3/3597)
![B+树键结构](http://note.youdao.com/yws/public/resource/eb2d7338ef2bc6c9d7d59695f6b5af22/xmlnote/782D81D3457C4232B921EF2A0FE13A6A/3606)

#### 3.3.1 B+树的搜索方法

- 一种是按叶节点自己拉起的链表顺序搜索。
- 一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。

### 3.4 B树和B+树的区别

1. B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。

    而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。
2. 因为B树键位置不定，且在整个树结构中只出现一次。虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。
3. B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。
4. B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。 
5. B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。

### 3.5 B+树的优点和缺点
1. 优点
- 单次请求涉及的磁盘IO次数少（出度d大， 且非叶子节点不包含表数据，树的高度小）
- 查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）；
- 遍历效率高（从符合条件的某个叶子节点开始遍历即可）；
2. 缺点
- 主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片；
- 即使主键是有序递增的，大量写请求的分布仍是随机的；

3. 解释缺点

- B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。对于大量的随机写也一样，举一个插入key跨度很大的例子，如7->1000->3->2000 ... 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.
- 从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）

作者：奈文摩尔ST
链接：https://www.jianshu.com/p/06f9f7f41fdb
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

> 聚簇优点：物理存储的顺序导致磁盘读取的次数减少

> B/B+优点：相比二叉搜索树，一个盘块存储的key多，一个读取多个key。读取总的盘块次数减少，时间减少。

## 4 索引分类

1. 普通索引
2. 唯一索引：与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
3. 主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：
4. 全文索引：（FULLTEXT）： **TODO**
    - 定义：全文检索是对大数据文本进行索引，在建立的索引中对要查找的单词进行进行搜索，定位哪些文本数据包括要搜索的单词。因此，全文检索的全部工作就是建立索引和在索引中搜索定位，所有的工作都是围绕这两个来进行的。
    > 如果可能，请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。
5. 多列索引（组合索引：
    MySQL能在多个列上创建索引。一个索引可以由最多15个列组成。（在CHAR和VARCHAR列上，你也可以使用列的前缀作为一个索引的部分)。
    - 一个多重列索引可以认为是包含通过合并(concatenate)索引列值创建的值的一个排序数组。
    - 多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格（获得结果集记录数最少）的索引。
    - 在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。


> 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引。

### 4.1 hash索引和B+树索引区别

[Hash索引和B+树索引有什么区别或者说优劣势](https://blog.csdn.net/qq_44590469/article/details/97877397)

### 4.2 最左匹配原则（针对联合索引）

[讲得不错的最左匹配原则](https://blog.csdn.net/sinat_41917109/article/details/88944290)

## 4.3 索引建立的注意事项

1. 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。
2. 尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
3. 索引列不能参与计算，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = '2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP('2016-06-06')。
4. 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
5. 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。

[sql优化：explain关键字](https://blog.csdn.net/ss123mlk/article/details/106902596)