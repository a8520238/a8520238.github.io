---
title: 大话设计模式
date: 2021-2-28
cover:
top_img:
categories: 设计模式
tags: 
mathjax: true
katex: true
---
# 引言

设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单列模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


# 一、简单工厂模式与工厂方法模式（重点可看大话设计模式） https://blog.csdn.net/qq_34337272/article/details/80472071

## 1 简单工厂模式
简单工厂模式实际上就是创建一个接口，这个接口有相关类的某种抽象功能或者特性，这个接口或父类的对象就是简单工厂中的产品。

在实际使用中，我们只需要创建某个类实现这个借口，或者继承父类，就可以创建子类对象，投入到简单工厂中。

再创建一个工厂类，这里可以采用两种办法，第一种使用switch，但就不符合开放封闭原则。第二种使用反射， obj = Class.forName(clazz.getName()).newInstance(); 这种方法可以在增加子类产品时不需要修改工厂类。

## 2 工厂方法模式
工厂方法模式是定义一个用于创建对象的接口，由子类对象决定实例化哪一个。

工厂方法模式与简单工厂的一个区别，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。

工厂方法模式，将工厂类进行抽象，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。换句话说，工厂方法模式中的要素有四个：

抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 

具体工厂(Concrete Factory)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 

抽象产品(AbstractProduct)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应

这样，我们创建抽象类型的工厂类，其实际对象为具体工厂类（对应具体产品），可以将实现方法剥离。在调用时，我们只需要生成生产具体产品的具体工厂类，调用其中的统一方法即可。

## 3 抽象工厂方法

抽象工厂是生产一整套有产品的方法（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。

也就是说抽象工厂类中不再只有一抽象种产品，而是多个抽象产品。再创建具体工厂时要对两种产品做出@Override。每种抽象产品又有多个具体产品实现类。

举个例子，抽象工厂代表某军事工事，其能生产抽象产品枪和子弹，具体的工厂为某品牌工厂，在该具体工厂类中，其所重写的方法即是生产该品牌公司所生产的具体产品枪和子弹。

这样也有缺点，极有可能会违反抽象封闭原则，比如增加公司，这个问题可用反射解决。

# 二、单例模式

## 1 预加载

还没有实例化该对象，该对象就已经加载到内存中。这种方法会造成内存的浪费。

    public class PreloadSingleton {
       public static PreloadSingleton instance = new PreloadSingleton();

       //其他的类无法实例化单例类的对象

       private PreloadSingleton() {

       };

       public static PreloadSingleton getInstance() {
              return instance;
       }
    }

## 2 懒加载（这里涉及到线程加锁保证安全问题）

用到该单例对象时再创建，可避免内存浪费，但不是线程安全的。

    public class Singleton {
       private static Singleton instance=null;
       private Singleton(){
       };

       public static Singleton getInstance()
       {
              if(instance==null)
              {
                     instance=new Singleton();
              }
              return instance;
       }
    }
    
# 三、装饰器模式

装饰器模式中有四个类很重要。

1.Component（被装饰对象的基类）
   定义一个对象接口，可以给这些对象动态地添加职责。
   
2.ConcreteComponent（具体被装饰对象）
   定义一个对象，可以给这个对象添加一些职责。
   
3.Decorator（装饰者抽象类）
   维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。
   
4.ConcreteDecorator（具体装饰者）
   具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。
   
以商城为例子，如下：

1. Component抽象类


    public abstract class Component {
        public abstract void operation();
    }

2. ConretetComponent类（具体被装饰物类）


    public class ConcreteComponent extends Component {
        @Override
        public void operation() {
            System.out.println("具体对象的操作");
        }
    
    }
3 Decorator装饰类


    public abstract class Decorator extends Component {
        private Component component = null;
        //通过构造函数传递给被修饰者
        public Decorator(Component component) {
            this.component = component;
        }
        //委托给被修饰者执行
        @Override
        public void operation() {
            if(component != null) {
                this.component.operation();
            }
        }
    }
    
4 ConcreteDecorator类（具体装饰类）

    public class ConcreteDecoratorA extends Decorator {

        //定义被修饰者
        public ConcreteDecoratorA(Component component) {
            super(component);
        }
        //定义自己的修饰方法
        private void method1() {
            System.out.println("method1 修饰");
        }
        @Override
        public void operation() {
            this.method1();
            super.operation();
        }
    }


    public class ConcreteDecoratorB extends Decorator {

        //定义被修饰者
        public ConcreteDecoratorB(Component component) {
            super(component);
        }

        //定义自己的修饰方法
        private void method2() {
            System.out.println("method2 修饰");
        }

        @Override
        public void operation() {
            super.operation();
            this.method2();
        }

    }
    
5 Client客户端

    public class Client {

        public static void main(String[] args) {
            Component component = new ConcreteComponent();
            //第一次修饰
            component = new ConcreteDecoratorA(component);
            //第二次修饰
            component = new ConcreteDecoratorB(component);
            //修饰后运行
            component.operation();
        }

    }
    
这里说一下装饰过程，首先生成了具体被装饰类component，第一次生成装饰器A，其内部的组件对象为原始的component,然后生成装饰器B，此时其内部组件对应的是componentA,在调用componentB的operation时，会先调用父类decorator的方法operation，该方法会调用当前存储的对象componentA的operation方法，这样实现了一级一级的传递过程。

# 四 代理模式
https://www.cnblogs.com/daniels/p/8242592.html 记录较为清楚

代理模式分为静态代理和动态代理

动态代理类如下：

    package main.java.proxy.impl;

    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;

    public class DynamicProxyHandler implements InvocationHandler {

    private Object object;

    public DynamicProxyHandler(final Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("买房前准备");
        Object result = method.invoke(object, args);
        System.out.println("买房后装修");
        return result;
    }
    }
    
测试类如下：

    package main.java.proxy.test;

    import main.java.proxy.BuyHouse;
    import main.java.proxy.impl.BuyHouseImpl;
    import main.java.proxy.impl.DynamicProxyHandler;

    import java.lang.reflect.Proxy;

    public class DynamicProxyTest {
        public static void main(String[] args) {
        BuyHouse buyHouse = new BuyHouseImpl();
        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new
                Class[]{BuyHouse.class}, new DynamicProxyHandler(buyHouse));
        proxyBuyHouse.buyHosue();
    }
    }
    
注意Proxy.newProxyInstance()方法接受三个参数：
ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的
Class<?>[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型
InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法。

# 五 原型模式

这个模式要注意两个地方

1 深拷贝和浅拷贝，使用clone是深拷贝，但this.MemberwiseClone是拷贝的对象是拷贝的引用为浅拷贝，要一层一层的深拷贝。

2 要注意实现Cloneable 接口，调用super.Clone方法

# 六 外观模式

spring mvc就是一个外观模式的例子，在维护一个大型系统时。开发外观类与之对接可以降低偶合。

# 七 策略模式

# 八 模板方法（与策略模式很像）

模板模式关注统一算法的不同实现，策略模式关注不同算法。

模板模式将不变的行为放到超类中。

可看servlet源码

# 九 建造者模式（生成器模式）

# 十 适配器模式

模式说明：
- 包装类 = 适配器Adapter；
- 被包装对象 = 适配者Adaptee = 被适配的类

作用：

把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。
```
public abstract class MagaGenericServlet implements Servlet {
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }
    @Override
    public ServletConfig getServletConfig() {
        return null;
    }
    @Override
    public String getServletInfo() {
        return null;
    }
    @Override
    public void destroy() {
    }
}
```

> 抽象类继承了Servlet类，对于需要实现的内容进行空实现 

```
@WebServlet("/login")
public class LoginServlet1 extends MagaGenericServlet {
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("我被执行了");
    }
}
```
