---
title: 持久层整合
date: 2021-2-28
cover:
top_img:
categories: spring
tags: 
mathjax: true
katex: true
---
# 1 持久层整合

# 1.1 为什么与持久层整合

- javaEE 需要持久层进行数据库的访问操作
- Myabatis jdbc 进行持久开发过程存在大量代码冗余
- spring基于模板设计模式对持久层进行了封装

# 1.2 spring与那些持久层整合

- JBDC
- Hibernate(JPA)
- Mybatis

# 2 Spring 与Mybatis 整合

1. 实体
2. 实体别名  配置繁琐
3. 表
4. 创建DAO接口
5. 实现Mapper文件
6. 注册Mapper文件  配置繁琐
7. MybatisAPI调用  代码冗余

# 2.1 Spirng和Mybatis的整合思路

SqlSessionFactoryBean
```
<bean id="dataSource" class=""/>

<bean id="ssfb" class="SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource">
    <property name="typeAliasesPackage" value=""> //别名，只需制定实体所对应的包，
    //Spring自动创建别名，即类名。
    <property name="mapperLocations">
        <list>
            <value> classpath:com.mapper/*Mapper.xml</value>
        </list>
    </property>
    //mapper注册
    //可以进行统配的设置， *Mapper.xml
</bean>
```
上述代码用于创建SqlSessionFactory

mybatis-config.xml 中的三个部分：
别名，连接池信息， mapper注册

通过上述注入，这个xml可以省略。

MapperScannerConfigure 获得session,通过getmapper获得实现类
```
<bean id = "scanner" class = "MapperScannerConfigure">
    <property name = "sqlSessionFactoryBeanName value="ssfb">
    <property name="basePackage"> //设置DAO接口所在的包
</bean>
``` 
注意MapperScannerConfigure所创建的DAO对象的id值是借口首单词字母小写

UserDAO --> userDAO

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/BBEE89B65E974FF2923F324AFF23C47B/4001)

# 2.3 Spring与Mybatis整合的开发步骤

- 配置文件
    + 创建SqlSessionFactory
    + DAO接口的实现类


> Spring与Mybatis整合后，为什么DAO不提交事务，也能插入到数据库

本质上控制连接对象（Connection）连接池（DataSource）
- Mybatis提供的连接池对象，
Connection.setAutoCommit(false)手工控制了事务，操作完成，手工提交
- 整合后，用外部连接池Druid做为连接池
上述值为true 保持自动控制事务，一条sql自动提交。

# 3 Spring的事务处理

# 3.1 什么是事务

保证业务操作完整性的一种数据库机制
ACID

控制事务都是基于Connection对象（非Spring）

# 3.2 Spring控制事务开发

> Spring是通过AOP的方式进行事务开发

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/7D379DF325F54ED4A76B800148D95B07/4055)

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/EED8B5DF3A46476E8EDD3E02BB4432E8/4059)

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/053E1FF54BC94DF2A47C70F34C71EEF3/4062)

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/E42620B2C1FC4337851D9FB246817E7A/4067)

# 4 Spring的事务属性

# 4.1 事务属性
1. 隔离属性
2. 传播属性
3. 只读属性
4. 超时属性
5. 异常属性

# 4.2 如何添加事务

@Transactional(isloation=, propagation, readOnly=, timeout=,  rollbackFor=, noRollBackFor=,)

# 4.3 事务属性详解

1. 隔离属性（ISLOATION）

    并发：多个事务在同一时间，访问了相同的数据
    
    通过隔离属性解决
    - 脏读 @Transactional(isloation=READ.COMMITTED), 读已提交。
    - 不可重复读 @Transactional(isolation.REPEATABLE_READ) 本质是一把行锁，可重复读。
    - 幻读
    @Transactional(isolation.SERIALIZABLE) 序列化读
    表锁
    
    ISOLATION_DEFAULT表示会调用不同数据库设置的默认隔离属性。
    
2. 传播属性（事务嵌套）(propagation)

    service 调用service的情况下有可能出现事务嵌套。
    
    大事务中融入了很多小的事务，他们彼此影响，最终导致外部大的事务，丧失了事务的原子性。
    
    ![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/95619778E7EA4A3DB6C658F3C116B954/4124) 
    
    required常用于增删改（传播属性的默认值）
    
    support用于查找
    
    required new 用于日志记录方法
    
    
3. 只读属性（readOnly）

- 针对于只进行查询操作的业务方法，可以加入只读属性，用于提升性能。

4. 超时属性

- 指定了事务等待的最长时间，当前事物访问数据时，有可能访问到被别的事务加锁的处理，本事务必须进行等待。
- @Transactional(timeout = 2)(秒)如果超市抛出异常。
- 超时属性的默认值-1，由对应数据库来指定。

5. 异常属性

Spring事务处理中默认对于RuntimeException及其子类， 采用的是回滚的策略。

默认对于Exception才用的是提交的策略。

修改

rollbackFor = {java.lang.Exception, xxx, xxx}

noRollbackFor = {java.lang.RuntimeException}

# 4.4基于标签和注解的事务配置的对比

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/667DFF572CF64004AE0ACD54FA566958/4182)

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/9D79563064904DEEA617DF77FA7C68D5/4179)


下面这种方式会自动匹配所有符合命名的方法

![](http://note.youdao.com/yws/public/resource/1f4682a8c41f4bbfefa91f24f452c92e/xmlnote/5EA7BD7050BF4AF0B6C5DD060A542062/4201)