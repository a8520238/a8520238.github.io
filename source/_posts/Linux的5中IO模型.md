---
title: BIO_NIO_AIO总结
date: 2020-10-29 16:06:54
cover:
top_img:
categories: IO
tags: 
mathjax: true
katex: true
---

# Linux 5中模型

## 1 阻塞式IO模型

当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

典型的阻塞IO的例子：
```
data = socket.read();
```
如果数据没有就绪，就会一直阻塞在read方法。

## 2 非阻塞IO模型

当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU就，而会一直占用CPU。

典型的非阻塞IO模型一般如下：
```
while(true) {
    data = socket.read();
    if (data != error) {
        处理数据
        break;
    }
}
```
- 非阻塞IO的缺点：在while循环中需要不断询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般很少使用这种方法来读取数据。

## 3 IO复用模型

多路复用IO模型是目前使用得比较多的模型，JAVA NIO实际上就是多路IO复用。

在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，只有真正的socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这里会导致用户线程的阻塞。

多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。对于多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。

- 多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。
- 要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。

在这里使用了反应器（Reactor）设计模式，如下图：
![](http://note.youdao.com/yws/public/resource/347e6a5d67e0fd43b8f066d5fb52a900/xmlnote/8A1410B068594ED1A69F9FE75623D2C9/8220)

通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型(也可以理解为同步非阻塞(数据准备到内核的过程非阻塞))。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。

代码：
```

void UserEventHandler::handle_event() 
{
 
    if(can_read(socket)) 
    {
 
        read(socket, buffer);
 
        process(buffer);
    
    }
 
}
 
 
 
{
 
    Reactor.register(new UserEventHandler(socket));
}



Reactor::handle_events() 
{
 
    while(1) 
    {
 
        sockets = select();
 
        for(socket in sockets) 
        {
 
            get_event_handler(socket).handle_event();
 
        }
 
    }
 
}
```

## 4 信号驱动IO模型

在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

## 5 异步IO模型
异步IO模型中，用户线程发起操作之后，立刻就可以去做其他的事。而另一方面，从内核的角度，当它收到一个asynchronous之后，会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。

也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。

注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。

> 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞(从内核read)。

[5种IO模型](https://www.cnblogs.com/dushangguzhousuoli/p/10822262.html)

[Reactor模式和Proactor模式](https://www.cnblogs.com/bitkevin/p/5724410.html)