---
title: JVM 内存结构
date: 2021-2-28
cover:
top_img:
categories: JVM
tags: 
mathjax: true
katex: true
---
# JVM内存区域划分

JVM运行时数据区分为：堆、方法区（元空间）、栈（虚拟机栈、本地方法栈）、程序计数器。

![JVM内存结构](http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/25ECF8708BF34031A26C258879912AFC/2427) 

## 1 程序计数器 Program Counter

- 线程私有，是当前线程的字节码行号指示器。
    + 如果线程执行 Java 方法，只是字节码指令的地址（行号指示器）；
    + 如果执行的是 Native 方法，计数器值为 Undefined。
    + 程序计数器保证了线程挂起和线程再次获得CPU使用权时，代码的运行顺序。
    + 程序计数器不会发生OOM异常。

## 2 虚拟机栈（线程栈） Java Virtual Machine Stacks

### 2.1 用途


- 线程私有，每个线程都维护一个与线程同时创建的虚拟机栈，线程调用的每个方法对应一个栈帧，栈帧中储存了一个方法的状态信息：
    + 局部变量表、操作数栈、动态链接、方法出口 等。

- 可能发生的异常：
    + ```StackOverflowError```：方法调用的深度超过了虚拟机栈深度。
    + `OutOfMemoryError`：虚拟机栈随着内容的增加会动态扩展内存，扩展到一定程度无法申请到足够的内存时抛出该异常。
- 使用 -Xss 设置栈大小，通常几百K就够用了。由于栈是线程私有的，线程数越多，占用栈空间越大。
 
### 2.2 局部变量表

- 局部变量表中存放：基本数据类型、对象引用（包括方法参数 和 局部变量）
- 变量槽 Variable Slot：
局部变量表的最小单位是 变量槽（Variable Slot），每个变量槽 32 位（4字节）。通过 index 的方式直接索引。
    + 普通方法 0 号位存放 this 指针，static 方法没有 this，所以直接存其他数据。
    + Slot 可以复用，当局部变量作用域失效时，可以被其他数据覆盖。

### 2.3 操作数栈

存在于JVM中， 用于辅助计算，存放用于计算的操作数。

## 3 本地方法栈

本地方法栈为 native 方法服务，其他与虚拟机栈类似。

native 方法比如：`String.extern()` 方法。

> hot spot 虚拟机中的 虚拟机栈 和 本地方法栈 是合在一起的。

## 4 Java 堆 Heap

### 4.1 堆的用途

- 堆在 JVM 启动时被创建，用于存放所有的对象实例、数组、String 对象等。
- Java 堆是 JVM 内存管理的最大区域，是垃圾回收的主要场所。
- Java 堆是线程共享的。

### 4.2 堆的结构    

堆中包括年轻代（YoungGen）、年轻代包括幸存区（Survivor）和出生区(Eden)、老年代(OldGen)。

- 年轻代存储新创建的对象。当年轻内存占满后，会触发 Minor GC，清理年轻代内存空间。
- 老年代存储长期存活的对象和大对象。年轻代中存储的对象，经过多次GC后仍然存活的会移动到老年代中进行存储。老年代空间占满后，会触发Full GC，清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出OutOfMemoryError异常。
> 大对象会直接进入老年代

### 4.3 Java 堆设置常用参数

- -Xms：设置Java应用程序启动时的初始堆大小
- -Xmx：设置Java应用程序能获得的最大堆大小
- -Xss：设置线程栈的大小
- -XX:MinHeapFreeRatio：设置堆空间最小空闲比例。当对空间的空闲内存小于这个数值时，JVM便会扩展堆空间
- -XX:MaxHeapFreeRatio：设置堆空间的最大空闲比例。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆
- -XX:NewSize：设置新生代的大小
- -XX:NewRatio：设置老年代与新生代的比例，它等于老年代大小除以新生代大小
- -XX:SurviorRatio：新生代中eden区与survivior区的比例
- -XX:MaxPermSize：设置最大的持久区的大小
- -XX:PermSize：设置永久区的初始值
- -XX:TargetSurvivorRatio：设置survivior区的可使用率。当survivior区的空间使用率达到这个数值时，会将对象送入老年代

> 永久代是hotspot虚拟机，也就是我们使用的java虚拟机的特有的概念，他不属于堆内存，是方法区的一种实现，各大厂商对方法区有各自的实现。永久代存放jvm运行时，需要的类，包含java库的类和方法，在触发full gc的情况下，永久代也会被进行垃圾回收。永久代的内存溢出也就是 pergen space。

> 1.8 后JVM移除了永久代，改为元空间。

### 4.4 堆中存的对象包括

对中存的是实例化的对象，其中包含实际对象中的各种值，有一个点要注意，堆中对象存有指向方法区方法的指针，调用方法时，通过该指针调用class对象。
## 5 方法区 Method Area

- 存放已被虚拟机加载的 类信息、常量、static变量、*即时编译后的代码 *等。
    + 存放每个类的结构信息
    + 类属性
    + 类的方法
    + 方法和类的构造函数的代码（包括类实例在初始化、接口初始化中使用的特殊方法）
- 线程共享。
- 常量池是方法区的一部分。
    + class文件常量池
    + 运行时常量池
- 在JDK 1.7及以前，方法区是堆的一个逻辑部分；为了与堆区分，被称为“非堆”或“永久代”。

### 5.1 class 文件常量池

class 文件常量池存在于 .class 字节码文件中。

存储编译器生成的各种 字面量 和 符号引用 。

- 字面量：文本字符串、final 常量、基本类型常量的值
- 符号引用：
    + 类和接口的全限定名：用于在运行时类加载过程“解析”阶段得到直接引用。
    + 方法的名称和描述符：描述符即参数类型和返回值类型。
    + 字段的名称和描述符：包括类变量（static）、实例变量。

### 5.2 运行时常量池

- 运行时常量池是线程共享的。
- 存储 Java class文件常量池中的符号信息。在类加载时，第一步是“加载”，包括三步：（1）通过类全限定名来获取二进制字节流；（2）把字节流所代表的静态存储结构转化为方法区的运行时数据结构；（3）方法区中生成Class对象，作为该类的各种数据访问入口。其中，第（2）步中就包含了class常量池中进入运行时常量池的过程。
- 存放直接引用。类加载的“解析”阶段会将符号引用所翻译出来的直接引用(直接指向实例对象的指针)存储在 运行时常量池 中。
- 常量不一定编译时才能产生，运行时产生的常量会放入运行时常量池。

### 5.3 字符串常量池（看Reference 3、4） 
- JDK 1.7 之前，字符串常量池存在于运行时常量池（方法区）内；
- JDK 1.7 把其移到了Java 堆中。
- JDK 1.8 中，字符串常量池被移到了元空间，独立于堆。

常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。

> 通过new的方式创建String, 其直接引用对象是在堆中，先判断字符串常量池内有无该字符串，如果有，在堆中复制一个副本，把副本的地址给引用；如果没有，先在字符串常量池中创建一个，然后复制到堆中，把堆中地址给引用。

> String.intern() 方法会返回字符串在字符串常量池中的引用。

### 5.4 基本类型包装类的常量池

整型的包装类在对应值小于等于127时才可使用对象池。这里常量池中缓存的是包装类对象，而不是基本数据类型。

### 5.5 方法区随 JDK 版本的变化

#### JDK 1.7

JDK 1.7时的Hotspot VM，把方法区中的静态变量、字符串常量池等移到了堆内存。

#### Jdk 1.8

JDK 1.8中，方法区被替换为元空间 Meta Space，它没有占用堆内存，而是直接占用本地内存。

方法区的参数取代为：

- -XX:MetaspaceSize
- -XX:MaxMetaspaceSize

JDK1.8中，class对象在堆中，且静态变量在class对象中




## todo 逃逸分析和栈上分配


## Reference

[一文搞懂JVM内存结构](https://blog.csdn.net/rongtaoup/article/details/89142396)

[JVM常量池浅析](https://www.jianshu.com/p/cf78e68e3a99)

[JVM中的常量池详解](https://www.cnblogs.com/superyc/p/9975254.html)
