---
title: 集合注意的事
date: 2021-2-28
cover:
top_img:
categories: java集合框架
tags: 
mathjax: true
katex: true
---
# 1 初始容量

- Collection的初始容量很重要，能够减少时间,因为扩容机制很耗时间
```
public static void main(String[] args) {
    StudentVO student = null;
    long begin1 = System.currentTimeMillis();
    List<StudentVO> list1 = new ArrayList<>();
    for(int i = 0 ; i < 1000000; i++){
        student = new StudentVO(i,"chenssy_"+i,i);
        list1.add(student);
    }
    long end1 = System.currentTimeMillis();
    System.out.println("list1 time：" + (end1 - begin1));
    
    long begin2 = System.currentTimeMillis();
    List<StudentVO> list2 = new ArrayList<>(1000000);
    for(int i = 0 ; i < 1000000; i++){
        student = new StudentVO(i,"chenssy_"+i,i);
        list2.add(student);
    }
    long end2 = System.currentTimeMillis();
    System.out.println("list2 time：" + (end2 - begin2));
}
```
上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：
```
list1 time：1638
list2 time：921
```
# 2 asList的缺陷
1. 避免使用基本数据类型数组转换为列表，举例如下：
```
public static void main(String[] args) {
        int[] ints = {1,2,3,4,5};
        List list = Arrays.asList(ints);
        System.out.println("list'size：" + list.size());
    }
------------------------------------
outPut：
list'size：1
```
```
public static <T> List<T> asList(T... a) {
        return new ArrayList<>(a);
    }
```
从源码中可以看出，asList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法泛型化的，也就是说，8个基本类型无法作为asList的参数的，要想作为泛型参数就必须使用其所对应的包装类型。
实际中将数组作为一个对象传入了，所以asList转换后得到只有一个int的列表，如下
```
public static void main(String[] args) {
    int[] ints = {1,2,3,4,5};
    List list = Arrays.asList(ints);
    System.out.println("list 的类型:" + list.get(0).getClass());
    System.out.println("list.get(0) == ints：" + list.get(0).equals(ints));
}
outPut: list 的类型:class [I list.get(0) == ints：true
```
- 为了避免上述问题，将int[]改为Integer[]即可
```
public static void main(String[] args) {
        Integer[] ints = {1,2,3,4,5};
        List list = Arrays.asList(ints);
        System.out.println("list'size：" + list.size());
        System.out.println("list.get(0) 的类型:" + list.get(0).getClass());
        System.out.println("list.get(0) == ints[0]：" + list.get(0).equals(ints[0]));
    }
----------------------------------------
outPut:
list'size：5
list.get(0) 的类型:class java.lang.Integer
list.get(0) == ints[0]：true
```
2. asList产生的列表不可操作
<br>举例
```
public static void main(String[] args) {
        Integer[] ints = {1,2,3,4,5};
        List list = Arrays.asList(ints);
        list.add(6);
    }
```
结果会跑出UnsupportedOperationException异常

因为此时的内部类不是正常的ArrayList，而是Arrays的内部类，调用原始的方法就会抛出上述异常。

# subList的缺陷

我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。

1. subList返回的仅仅是一个视图

sunList返回的SubList同样也是AbstractList的子类，同时他的方法如get、set、add、remove等都是在原列表上面做操作，它没有像subString一样生成一个新的对象。
2. subList生成子列表后，不要试图去操作原列表

因为fail-fast机制也被继承了，会抛出异常。
```
public int size() {
            checkForComodification();
            return this.size;
        }
```
```
private void checkForComodification() {
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
        }
```
一个安全的做法是将原列表设置为只读
```
List<Integer> list3 = list1.subList(0, list1.size());
list1 = Collections.unmodifiableList(list1);
```
3. 推荐使用subList处理局部列表
<br>如下
```
for(int i = 0 ; i < list1.size() ; i++){
   if(i >= 100 && i <= 200){
       list1.remove(i);
       /*
        * 当然这段代码存在问题，list remove之后后面的元素会填充上来，
         * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。
         */
   }
}
//修改为下面的
list1.subList(100, 200).clear();
```
# 4 保持compareTo和equals同步

indexOf和binarySearch的实现机制都是不同的

- indexOf是基于equals来实现的只要equals返回TRUE就认为已经找到了相同的元素
- 而binarySearch是基于compareTo方法的，当compareTo返回0 时就认为已经找到了该元素。
 
所以我们要保证这两者同步，compareTo相等时equals也相等，而compareTo不相等时equals也不相等