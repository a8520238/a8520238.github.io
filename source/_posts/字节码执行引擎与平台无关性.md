---
title: 字节码执行引擎与平台无关性
date: 2021-2-28
cover:
top_img:
categories: JVM
tags: 
mathjax: true
katex: true
---
# 字节码执行引擎与平台无关性

## 1 平台无关性
总的来说，java语言包括前端编译和后端编译
- 前端编译也就是java源代码生成class字节码的过程，javac命令
- 后端编译由JVM完成，由字节码生成机器指令

## 2 字节码执行引擎

在 Java 虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。从外观上来看，所有Java虚拟机的执行引擎是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

**在其他地方已经记录了java虚拟机的各个部分，这篇主要记录java虚拟机执行中，以及动态链接相关知识**

### 2.1 动态连接（常量池该帧栈所属方法的引用）

每个栈帧都包含一个常量池中该栈帧所属方法的引用。持有该引用的目的是为了支持方法调用中的动态连接。Class文件的常量池中存在大量的符号引用。这些符号引用一部分会在类加载阶段或者第一次使用的时候转化为直接引用，这种方式称为静态解析。另一部分会在每次运行期间转化为直接引用，这种称为动态连接。

### 2.2 方法调用

方法调用的任务是确定哪个方法被调用。不同于传统的静态连接的语言，Java采用动态连接。Class文件在编译过程中存储的只是符号引用，而不是方法在运行时内存布局的入口地址（直接引用）。因此，目标方法的直接引用，需要在类加载时期，甚至是运行时才能够最终确定

1. 解析调用

有些方法在类加载的解析阶段，就可以将符号引用转化为直接引用，这种方式称为解析调用（Resolution）。解析能够成立的前提是：方法在编译期就有一个可确定的调用版本，并且这个版本在运行时不可改变。符合上述特征的方法主要包括静态方法、私有方法、实例构造器、父类方法以及final方法

2. 分派调用

解析调用是一个静态的过程（符号引用转变为直接引用的过程不会延迟到运行时），分派调用（Dispatch）可以是静态的，也可以是动态的。

- 静态分派的实质是调用重载
- 动态分派的实质是调用重写
**详细请看 动态分派与静态分派专栏**

3. 在这期间命令invokevirtual指令的运行解析过程：
- 找到操作数栈顶的第一个元素所指向对象的实际类型C
- 然后在C中查找与常量池中描述符和简单名称都相符的方法，如果找到，则进行权限验证，如果通过验证则返回这个方法的直接引用，否则抛出java.lang.AbstractMethodError异常
- 否则，按照继承关系自下而上对C的父类进行第二步的查找和验证
- 如果没有找到则抛出java.lang.AbstractMethodError异常
- 可以看出invokevirtual指令的第一步就是查找对象的实际类型，这就是Java中方法重写（Override）的本质。这种在运行时通过实际类型来决定方法执行版本的分派方式就称为动态分派
> 动态分派的实现：依赖于虚方法表。虚方法表中存放着各个方法的实际入口地址。如果子类中没有重写父类的某个方法，那么在子类的虚方法表中存储的就是父类中该方法的地址入口。如果子类中重写了父类的某个方法或者新声明并且实现了某个方法，那么在子类的虚方法表中存储的就是子类中该方法的地址入口。

## 2.3 基于栈的字节码解释执行引擎

虚拟机在执行代码的时候有解释执行和编译执行。

Java编译器输出的指令流，基本上是一种基于栈的指令集架构。
- 基于栈的指令集：
```
    iconst_1
    
    iconst_1
    
    iadd
    
    istore_0
```

- 基于寄存器的指令集
```
    mov eax, 1
    
    add eax, 1
```
基于栈的指令集优点是不直接依赖硬件，可移植性强。而基于寄存器的指令集直接依赖于硬件，直接受硬件制约。也正因如此，基于栈的指令集通常来说执行效率不如基于寄存器的指令集。