---
title: 死锁
date: 2021-2-28
cover:
top_img:
categories: 操作系统
tags: 
mathjax: true
katex: true
---
#  死锁

多个进程因为竞争资源造成的一种僵局（互相等待）

## 死锁的四个必要条件
- 互斥条件： 进程要求对所分配的资源进行排他性控制，在一段时间内资源仅为一个进程所有。
- 不可剥夺条件：进程所获得资源未使用完毕之前，不能被其他进程强行夺走，只能等获得资源的进程自己主动释放。
- 请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，而该资源已被其他进程占有。此时进程被阻塞，但是对自己资源不释放。
- 循环等待条件：存在某一进程的循环等待链，链中每个进程已获得的资源同时被链中下一个进程的请求。

## 死锁的处理策略

死锁的处理便是破坏四个必要条件，使得死锁无法发生

### 1 鸵鸟策略

把头埋在沙子里，假装问题没有发生

由于解决死锁问题的代价往往很高，鸵鸟策略在很多情况下可以取得更高的性能

大多数操作系统，Unix、Linux、windows处理死锁都是采用鸵鸟策略

### 2 死锁预防
1. 破坏互斥条件：对于可共享的资源竞争，不会发生死锁
2. 破坏不剥夺条件：当一个进程无法获取其需要的资源时，将之前已获得的资源释放，待需要时在重新申请
3. 破坏请求和保持条件：预先分配的静态方法，在进程运行前一次申请完它需要的所有资源。在资源不满足前不运行，一旦运行这些资源都归其所有。
4. 破坏循环等待：资源顺序分配法，为资源编号，每个进程申请分配某个资源后，再之后只能申请该编号以后的资源

### 3 死锁避免
1. 系统的安全状态：所谓安全状态，是系统能按照某种进程推进顺序（P1，P2，，）为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个系统进程都能顺序完成，则（P1，P2，，）称为安全序列，如果无法找到安全序列，则系统处于不安全状态。
2. 允许进程池动态的申请资源，但是每次分配资源前系统都会计算资源分配的安全性，如果分配资源不会导致系统进入不安全状态，将资源分配给进程；否则进程等待。
- 银行家算法是最著名的死锁避免算法。他的思想是把操作系统看成银行家，操作系统管理的资源当成银行家管理的资金，向操作系统请求资源相当于向银行请求贷款 
- 进程请求资源时，系统评估该进程的最大需求资源，检查资源分配后系统是否还处于安全状态，由此来决定是否分配该资源。也就是进程需求的资源数《=剩余的资源数才是安全序列。

[银行家算法死锁避免](https://zhuanlan.zhihu.com/p/59533950)
### 4 死锁的检测和接触

1. 死锁检测
- 死锁定理：可以通过资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：
    - 在资源分配图中，找到既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的节点。在这里要注意一个问题，判断某种资源是否空闲，应该用它的资源数量减去它在资源分配图中的出度。
    - 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可以变为非阻塞进程。根据1中的方法进行一系列简化后，若能消去图中所有的边，则称改图是可完全简化的。

S为死锁的条件是：当且仅当S状态的资源分配图是不可完全简化的，该条件为死锁定理

[详细解释死锁定理](https://blog.csdn.net/u011240016/article/details/53305118)
2. 死锁解除
    - 资源剥夺法：挂起死锁进程，抢占其资源分配给其他进程
    - 销进程法：强制撤销一些死锁进程
    - 进程回退法：借助历史信息使一个或多个进程回退到系统不在死锁的地步