---
title: 锁
date: 2021-2-28
cover:
top_img:
categories: java并发编程
tags: 
mathjax: true
katex: true
---
# Java中的各种锁

## 1 主流锁
1. 悲观锁
- 悲观锁认为自己在使用数据时一定有别的线程来修改数据，Java中，synchronized关键字和Lock的实现类都是悲观锁。
- 悲观锁适用于写操作多的情况
2. 乐观锁
- 乐观锁认为自己在使用数据时不会有别的线程来修改数据，所以不添加锁，Java中最常见的乐观锁是CAS。
- 乐观锁适合读操作多的情况。
3. 自旋锁（适应性自旋锁）
- 使用场景：阻塞和唤醒一个线程需要操作系统切换CPU状态来完成，耗费处理器时间。许多情况下，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场可能会让系统得不偿失。
- 自旋锁不会阻塞线程，而是会在while循环中等待
- 如果锁占用的时间很长，自旋会浪费处理器资源，因此，自旋等待的时间必须有限度，如果超过次数没有获得，挂起线程。
- 自适应自旋锁：自旋的时间或次数不再固定，而是由上一个同一个锁的自旋时间决定，如果刚刚成功了，认为很有可能自旋成功。自旋时间加长，反之减少。
> 在JDK6之前，synchronized是依赖于操作系统Mutex Lock所实现的重量级锁，JDK6为了优化，引入了无锁->偏向锁->轻量级锁->重量级锁。

> 4,5,6,7这四种锁状态是针对synchronized的。

4. 无锁
- 无锁没有对资源进行锁定，所有线程都能访问并修改同一资源，但同一时刻只有一个线程能成功。
- 无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的
5. 偏向锁
- 偏向锁是某一个锁对象第一个被某线程访问时加的，大多数情况下，锁都是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。
- 偏向锁只有遇到其他线程尝试竞争时才会释放锁，线程不会主动释放偏向锁。
6. 轻量级锁
- 当锁是偏向锁时，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋尝试获得锁，不会阻塞。
7. 重量级锁
- 重量级锁会阻塞线程。
- 重量级锁依赖于操作系统的互斥量（mutex）
8. 公平锁
- 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。
- 优点是等待锁的线程不会饿死。
- 缺点是整体吞吐效率相对非公平锁要低。
- 公平锁比非公平锁效率低的原因：后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在wait，如果有自己挂起，加到队列后面，然后唤醒队列前面的线程。比非公平锁多了一次挂起和唤醒。
9. 非公平锁
- 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。缺点是队列中的线程可能会饿死。
10. 可重入锁
- 可重入锁又名递归锁，在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法会自动获取锁（前提是同一对象或者class）,不会因为之前已经获得的没有释放而阻塞。
- java中ReentrantLock和synchronized都是可重入
- 可重入锁可以一定程度避免死锁。
- 可重入锁内维护status，表示加了几次锁
11. 不可重入锁
- 不能重复对一个对象加锁
- 可能会出现死锁
12. 共享锁
- 共享锁可以被多个线程所持有，获得共享锁的线程只能读数据，不能修改数据。
13. 排它锁
- 也叫独享锁，指该锁一次只能被一个线程持有。如果线程A对数据加上排他锁后，其他线程不能再对A加任何类型的锁。
- Java中的synchronized和JUC中的Lock的实现类就是互斥锁。

> java中的锁都是对象锁，class类是特殊的java对象，所以类锁也是对象锁。
## 2 对象头和monitor

![对象头](http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/4183BEC251C242948F3A5F75F84A54D5/10477)
1. java对象头包括：
- Mark Word
- 指向类信息的指针Klass Pointer
- 数组的长度

2. Mark Word存储对象的HashCode，分代年龄和锁标志位信息。
3. Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
4. 锁升级的整个流程
- 当一个线程第一次访问一个同步块时，会在对象头和帧栈中记录偏向锁的线程id,当下一次线程再次进入同步块时，会检查Mark Word中的线程id是否为当前线程。
- 如果是当前线程直接进入，不需要通过CAS进行加锁和解锁。
- 如果不是当前线程，说明存在锁竞争，此时尝试使用CAS修改Mark Word中的线程id为当前的id。
    + 如果成功，表明之前的竞争锁的线程不存在了，锁不会升级，仍然是偏向锁。
    + 如果CAS（这里CAS的期望值是null）执行失败，则表明之前竞争锁的线程仍然存在，则暂停之前的线程，并把偏向锁标识设置为0，线程id设为空；同时锁升级为轻量级锁。
    + 这里对CAS的过程解释：当一个线程获得偏向锁后，会将对象锁状态标记为偏向锁（线程不会主动释放），有线程竞争后，会执行锁撤销过程，如果锁对象中记录的线程死亡或同步块进行完毕，撤销成功，CAS修改为偏向锁。
- 此时有两个线程竞争锁，对象锁状态为轻量级锁，虚拟机首先在当前线程的帧栈中建立一个名为锁记录的空间（Lock Record），用于存储对象目前的Mark Word的拷贝。（重入的时候会多一个锁记录为null）（锁的计数加一）
- 拷贝对象头中的Mark Word到锁记录中。
- 拷贝成功后，虚拟机会使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将owner指针指向对象的Mark Word。
- 之后是轻量级锁的加锁
    + 如果线程获得锁时，发现是轻量级锁，把Mark Word复制到虚拟机帧栈中的锁记录（Displaced Mark Word）
    + 线程尝试CAS操作(这里cas的期望不是当前被修改线程的值，而是锁记录中的值，锁释放回写之前会一直失败)，将锁的Mark Word替换为指向帧栈中锁记录的指针
        + 如果成功替换，则当前线程获得锁
        + 如果替换失败，自旋请求锁
- 如果自旋一直失败或者增加到三个及以上线程竞争锁，升级为重量级锁。
- 锁升级后会等代当前持有锁的线程将同步块内的方法执行完毕。
- 轻量级锁释放时，当前持有锁的线程会进行CAS操作，将锁记录中的内容回写到Mark Word中
    + 如果没有锁竞争，操作成功
    + 如果已经升级为重量级锁，CAS失败，释放锁，唤醒所有线程
5. 锁升级中的注意事项
- 在一个全局安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。