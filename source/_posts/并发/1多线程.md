---
title: 多线程
date: 2021-2-28
cover:
top_img:
categories: java并发编程
tags: 
mathjax: true
katex: true
---
# 1 java 中多线程的实现

1. 继承Thread类，并重写run()方法
2. 实现Runnable接口， 并重写run()方法
3. 实现Callable接口，并重写call()方法
4. 使用线程池创建

其中前两种较为常见。

## 1.1 Thread类

继承Thread类，并重写run() 方法

Thread类底层也是实现了Runnable接口，并重写了run()方法。

调用start()方法后，JVN会创建一个新的线程，并将该线程设置为可运行状态Runnable，但并没有直接运行。

- 当线程第一次得到时间片时，run()方法得以运行。

```
public class Demo {
    public static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("ok");
        }
    }
    
    public static void main(String[] args) {
        Thread myThread = new MyThread();
        myThread.start();
    }
}
```
> start()方法不可被多次调用，否则会抛出异常。

### 1.1.1 Thread类常用方法

- Thread.currentThread(): 静态方法，返回对当前正在执行线程对象的引用。
- start(): 开始线程，把新线程设置为就绪态。
- run(): 线程获得时间片时，自动被异步调用，真正开始执行该线程。
- yield(): 让出当前的CPU时间片，并重新变成就绪状态，重新竞争CPU。
    + 让出后，可能当前CPU使用权还会被该线程获取。
- Thread.sleep(): 静态方法，让当前线程睡眠一段时间。
- sleep对应线程，wait对应对象
- join(): 让当前线程等待另一个线程执行完毕后再继续执行。
    + 底层是使用得Object类的wait()方法
    + join执行前要先拿到对象锁，如果线程不在Alive或者超时，继续执行主线程。[join()方法的理解](https://www.cnblogs.com/aademeng/articles/10882539.html)

### 1.1.2 yield()和sleep()的异同

1. 都能暂停当前线程，yield()依赖于CPU时间片划分(让出的时间不固定)，sleep()可以指定具体休眠时间。
2. 二者若持有锁，则在暂停线程时都不会释放锁。
3. yield()不能被中断，sleep()可以被中断。

### 1.1.3 sleep中断的例子
1. 使用interrupt方法

```
package com.bjpowernode.java_learning;

 

public class D106_1_ {

  public static void main(String[] args) throws InterruptedException{

    Processer106 p1 = new Processer106();

    p1.start();

    //需求：子线程启动后0.5s之后打断它的休眠

    Thread.sleep(500);

    p1.interrupt();//这样就会是子线程打断休眠,调用这句话后，p1线程直接结束，不会执行sleep后的代码

    //这个底层的实现方法是一个调用中断异常的方式，因此，这个休眠之后的操作就不会执行了

    //在这个代码中就会直接进行下一次循环

    for(int i=0;i<5;i++) {

      System.out.println(Thread.currentThread().getName()+"---->"+i);

      //下面这个语句也可以使用对象.sleep()；因为sleep方法是一个静态方法。

      //即p1.sleep(200);这个main线程也会休眠200ms

      Thread.sleep(200);

    }

  }

}

class Processer106 extends Thread{

  //Thread中的run方法不抛出异常，因此重写run方法，在run方法的声明位置不能使用throws

  //所以run方法中只能使用try...catch.....

  public void run() {

    for(int i=0;i<5;i++) {

     

      System.out.println(Thread.currentThread().getName()+"--->"+i);

      try {

        Thread.sleep(1000);//当前线程阻塞1s

        System.out.println(i);

      }catch(InterruptedException e) {

        e.printStackTrace();

      }

    }

  }

  //m1方法是可以使用throws的

}
```
![](http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/8185F489D4E145489B0FA7E8A3EBD39B/9327)
2. 使用一个flag停止一个进程，不报异常
```
package com.bjpowernode.java_learning;

 

public class D106_2_InterruptSleep {

  public static void main(String[] args) throws Exception{

    Processer106_2 p = new Processer106_2();

    Thread t = new Thread(p);

    t.setName("t");

    t.start();

    //5s之后终止

    Thread.sleep(5000);

    p.run1 = false;

    //这种非异常的方法更好，因为不会抛出异常。

     

  }

 

}

class Processer106_2 implements Runnable{

 

  boolean run1 = true;

 

  public void run() {

    for(int i=0;i<10;i++) {

      if(run1) {

        try {

          Thread.sleep(1000);

        }catch(InterruptedException e) {

          e.printStackTrace();

        }

        System.out.println(Thread.currentThread().getName()+"-->"+i);

      }else {

        return;

      }

     

    }

  }

}
```

## 1.2 Runnable接口

Runnable接口是一个函数式接口，支持函数式编程
```
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
通过Runnable接口来创建并启动线程，有两种方式：
1. 通过普通类的方式或函数式编程匿名类的方式来创建Runnable接口的实现类，并实现run()方法。
2. 传入Runnable的实现类，实例化Thread类对象。
3. 调用start()方法来启动该线程。
```
public class Demo {
    public static class MyThread implements Runnable {
        @Override
        public void run() {
            System.out.println("MyThread");
        }
    }

    public static void main(String[] args) {
        // 通过 Thread 类来创建新线程
        new Thread(new MyThread()).start();

        // Java 8 函数式编程，创建匿名类
        new Thread(() -> {
            System.out.println("Java 8 匿名内部类");
        }).start();
    }
}
```
> Thread和Runnable接口的区别和联系：最终都是通过Thread对象来控制线程的创建。推荐使用Runnable的方式来实现多线程。

## 1.3 Callable
1. 相比run()方法，Callable功能更强大些：
- 相比run()方法，可以有返回值
- 方法可以抛出异常
- 支持泛型的返回值
- 需要借助FutureTask类，比如获取返回结果
```
class numThread implements Callable {

    @Override
    public Object call () {
        int sum =0;
        return sum;

    }
}
public class ThreadTest3 {
    public static void main(String[] args) {
        numThread nt = new numThread();

        FutureTask f = new FutureTask(nt);

        new Thread(f){}.start();

        try {
            Object sum = f.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```
## 1.4 使用线程池

经常创建和销毁、使用量特别大的资源，比如并发情况下的线程。需要提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。
```
class numThread2 implements Runnable{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            if (i%2==0){
                System.out.println(i);
            }
        }
    }
}
class nT implements Callable{
    @Override
    public Object call() throws Exception {
        for(int i=0;i<100;i++){
            if(i%2!=0){
                System.out.println(i);
            }
        }
        return null;
    }
}
public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        //execute无返回值
        executorService.execute(new numThread2());
        //执行Callable方法
        //submit有返回值
        executorService.submit(new nT());
        executorService.shutdown();

    }
}
```
## 1.6 内核线程与用户线程
[Linux用户级线程和内核级线程区别](https://www.cnblogs.com/Mered1th/p/10745137.html)
1. 用户级线程仅存在于用户空间。
2. 内核并不能看到用户线程。
3. 可以认为一个内核线程对应一个CPU逻辑线程，多个用户线程可以对应一个CPU逻辑线程。
4. 内核资源的分配仍然是按照进程进行分配的；各个用户线程只能在进程内进行资源竞争。
5. 内核线程的作用
    - 周期性地将修改的内存页与页来源块设备同步
    - 如果内存页很少使用，则写入交换区
    - 管理延时动作,　如２号进程接手内核进程的创建
    - 实现文件系统的事务日志
6. 内核线程执行
    - 线程启动后一直等待，直至内核请求线程执行某一特定操作。
    - 线程启动后按周期性间隔运行，检测特定资源的使用，在用量超出或低于预置的限制时采取行动。
7. 内核线程由内核自身生成，其特点在于
    - 它们在CPU的管态执行，而不是用户态。
    - 它们只可以访问虚拟地址空间的内核部分（高于TASK_SIZE的所有地址），但不能访问用户空间