---
title: 编译和优化
date: 2021-2-28
cover:
top_img:
categories: java并发编程
tags: 
mathjax: true
katex: true
---
# 4 逃逸分析

逃逸是指一个对象在某个方法中被创建后，会被其他方法或其他线程所引用。通俗的说，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针（或对象）的逃逸（Escape）。
- 方法逃逸：该对象被作为参数传递到其他方法中。在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。
- 线程逃逸：该对象被关联到其他线程中可以访问到的实例变量。这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。
线程逃逸的逃逸程度比方法逃逸更高。

如果能证明一个对象不会发生逃逸，或者逃逸程度比较低，则可以对该实例对象进行不同的优化。JDK1.7默认开启逃逸分析：
```
-XX:+DoEscapeAnalysis // 打开逃逸分析
-XX:+PrintEscapeAnalysis // 查看逃逸分析结果
-XX:+EliminateAllocations // 开启标量替换
```
## 4.1 栈上分配
一般来说，对象实例会在堆中进行内存分配，但对堆的内存回收和整理会耗费大量资源。如果确定了一个对象不会发生逃逸或只可能发生方法逃逸。则可以把对象分配在栈上，使变量随着方法的结束而自动销毁，从而减轻垃圾回收系统的压力。
- 只支持方法逃逸，不支持线程逃逸。
- 栈上分配没有被直接实现，而是采用了标量替换来代替。因为目前对一个对象进行彻底的逃逸分析所占用的计算资源太大。

## 4.2 标量替换
若一个数据无法分解为更小的数据，则可以被称为标量。如Java中的int,reference类型等。否则，被称为聚合量，如对象。

定义：在JIT（just in time）阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

标量替换是指如果逃逸分析能证明一个对象不会逃逸出该方法，并且该对象可以被拆散，则程序执行时可能并不会去创建这个对象，而是直接创建他的成员变量。这样，标量成员可以直接分配在栈上。
- 标量替换是栈上分配的一种特例，它的要求比栈上分配更苛刻。它要求对象不能发生方法逃逸。
举例，我们要创建一个User对象，但只在一个线程中调用了getUser()方法访问了name和age属性，则会进行标量替换，不会创建对象User,只会创建它的两个成员变量。
```
public class EscapeObject {
    private static void getUser() {
        User user = new User("张三", 18);
        System.out.println("user name is " + user.name + ", age is " + user.age);
    }

    public static void main(String[] args) {
        getUser();
    }
}

class User {
    String name;
    int age;
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```
标量替换后的等价代码：
```
private static void getUser() {
    String name = "张三";
    int age = 18;
    System.out.println("user name is " + name + ", age is " + age);
}

public static void main(String[] args) {
    getUs er();
}
```
## 4.3 同步消除
如果发现某个变量不会被多线程访问，即一定是线程安全的，则会执行锁消除。