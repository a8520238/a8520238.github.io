---
title: 线程状态及转换
date: 2021-2-28
cover:
top_img:
categories: java并发编程
tags: 
mathjax: true
katex: true
---
# 3 线程状态及转化

线程是轻量级进程，所以线程和进程状态一致。

Java线程状态转化图：

![](http://note.youdao.com/yws/public/resource/5cd10a62158ca44fb1f7fbe48671fb51/xmlnote/BAA7FD3CE96347F1943D9D7CCD030630/9512)

## 3.1 Java线程的6个状态

`Thread.State`源码：

```
    NEW,                // 新创建的线程，未调用 start() 方法
    RUNNABLE,           // 线程正在运行中：可能是在JVM中运行，也可能在等待CPU时间片
    BLOCKED,            // 阻塞状态： 正等待锁的释放以进入同步区
    WAITING,            // 等待状态： 需要被其他线程唤醒才能重新进入 RUNNABLE 状态
    TIMED_WAITING,      // 超时等待状态： 等待一个具体的时间段，到期会被自动唤醒
    TERMINATED;         // 线程执行结束
}
```
1. `start()` 方法只能调用一次，即使该线程已经执行完毕
- `threadStates`变量在`start()`方法未运行时为0，第一次调用`start()`方法后，值会改变；而当线程执行完毕后，该变量会变成2,代表线程TERMINATED
2. 以下情况会使线程进入WAITING状态：
- `Object.wait()`: 使当前线程处于等待状态直到另一个线程唤醒它；
    + `Object.wait()` 会释放锁
- `Thread.join()`：让调用者等待当前线程执行完毕，底层调用时Object.wait();
- `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。
3. 以下情况会使线程进入TIMED_WAITING状态：
- `Thread.sleep(long millis)`: 使当前线程睡眠指定时间；
    + `sleep()` 不会释放锁
- `Object.wait(long timeout)`: 线程休眠指定时间，等待期间可以通过`notify()`或`notifyAll()`唤醒；
    + `notify()` 会随即唤醒单个等待锁的线程
    + `notify()` 会唤醒所有等待锁的线程
- `Thread.join(long millis)`: 等待当前线程最多millis毫秒，如果millis=0，则不等待；
- `LockSupport.parkNanos(long nanos)`: 除非获得调用许可，否则在指定时间内禁止当前线程进行线程调度；
- `LockSupport.parkUntil(long deadline)`: 与上面类似

## 3.2 线程中断interrupt()
Java线程中断机制是一种协作机制。
- 中断操作不能直接终止该线程的运行，而是把对应线程的中断状态设置为true,然后被中断的线程可以选择如何去处理中断请求，或者不处理中断，继续执行下去。

### 3.2.1 Java中线程中断的方法
- `Thread.interrupt()`: 中断线程。并不会立即停止线程，而是设置线程的中断状态为true(默认是false);
-` Thread.interrupted()`: 测试当前线程是否被中断，返回线程当前的 中断标志位。调用该方法会影响线程的中断状态：
    + 调用`interrupted()`方法会反转线程的中断状态
- `Thread.isInterrupted()`:测试当前线程是否被中断。
    + 调用这个方法不会影响线程的中断状态。

## 3.3 join()
如果一个线程实例A执行了`threadB.join()`，其含义是：当前线程A会等待threadB线程终止后threadA才会继续执行

## 3.4 sleep()
`sleep()`会使线程休眠，只是让出CPU使用权，但不会放弃锁。

## 3.5 wait()
`wait()` 方法必须在同步方法或者同步块中执行，即线程必须已经获得了锁。

`wait()`方法调用会释放锁，线程会进入等待池，遇到`notify()`或`notifyAll()`后，才会离开等待池，变成可运行状态。
## 3.6 yield()

方法调用后，该线程会让出CPU使用权，重新参与CPU时间片的竞争。
- 线程从`Running`状态转变为`Runnable`状态
- 下一次CPU时间片会根据线程优先级来确定，也可能该线程在让出CPU后，还会立即获得CPU时间片
- 只能使同优先级的线程有执行的机会。

## 3.7 notify() 和 notifyAll()
- notifyAll 会让所有处于等待池的线程全部进入锁池的机会
- notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。

1. `wait()`和`notify()`都是定义在Object类中，为什么如此设计。因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用`wait()`和`notify()`，并且只有同一把锁才能对线程进行操作，不同锁之间是不可以相互操作的，所以wait和notify属于Object。
2. 调用wait方法可以让当前线程进入等待唤醒状态，该线程会处于等待唤醒状态直到另一个线程调用了object对象的notify方法或者notifyAll方法。
3. notifyAll()不会立刻释放锁，要等到synchronized代码块执行结束
4. notifyAll不是通过for循环唤醒所有线程的，借助了monitorexit，notify是通过调用notify的线程在退出其同步块的时候唤醒最后一个进入wait状态的线程，该线程在退出的时候继续唤醒倒数第二个进入的线程，依次类推。

> 也就是说wait和notify是对锁对象进行调用

比如对list加锁
```
//定义list对象
 private LinkedList list = new LinkedList();
 //加锁
 synchronized (list){
     list.wait()
     list.notifyAll()
 }
```
[notify()相关](https://www.jianshu.com/p/ffc0c755fd8d)

## 3.8 阻塞相关
1. 等待阻塞：运行(running) 的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
2. 同步阻塞：运行(running) 的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
3. 其它阻塞：链接：https://www.nowcoder.com/questionTerminal/bc40db02e4f14bf6b8e271928de3a08a?source=relative
来源：牛客网

运行(running) 的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入 可运行(runnable) 状态。