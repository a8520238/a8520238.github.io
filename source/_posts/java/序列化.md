---
title: 序列化
date: 2021-2-28
cover:
top_img:
categories: javaSE
tags: 
mathjax: true
katex: true
---
# 序列化

序列化可以将对象转化为可传输格式的过程。是一种数据的持久化手段，一般用与网络传输，RMI和RPC等场景中。

序列化是将对象的状态信息转换为可存储或传输的形式的过程。一般是以字节码或XML格式传输。

字节码或XML编码格式可以还原为完全相等的对象，这个相反的过程称之为反序列化。

## 1 Java实现序列化和反序列化

对象序列化机制是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以反序列化为对象。对象序列化很容易在JVM中的活动对象和字节数组（流）之间进行转换。

## 2 相关接口和类

- java.io.Serializable
- java.io.Externalizable
- ObjectOutput
- ObjectInput
- ObjectOutputStream
- ObjectInputStream

### 2.1 Serializable接口


类通过实现java.io.Serializable接口以启用其序列化功能。序列化接口没有方法或字段，仅用于标识可序列化的语义。

1. 当试图对一个对象进行序列化的时候，如果遇到不支持Serializable接口的对象。将抛出NotSerializableException.
2. 如果要序列化的类有父类，要想同时将在父类  中定义过的变量持久化下来，那么父类也应该实现java.io.Serializable接口
```
package com.hollischaung.serialization.SerializableDemos;
import java.io.Serializable;
/**
 * Created by hollis on 16/2/17.
 * 实现Serializable接口
 */
public class User1 implements Serializable {

    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
通过下面的代码进行序列化和反序列化

```
package com.hollischaung.serialization.SerializableDemos;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import java.io.*;
/**
 * Created by hollis on 16/2/17.
 * SerializableDemo1 结合SerializableDemo2说明 一个类要想被序列化必须实现Serializable接口
 */
public class SerializableDemo1 {

    public static void main(String[] args) {
        //Initializes The Object
        User1 user = new User1();
        user.setName("hollis");
        user.setAge(23);
        System.out.println(user);

        //Write Obj to File
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
            oos.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(oos);
        }

        //Read Obj from File
        File file = new File("tempFile");
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream(file));
            User1 newUser = (User1) ois.readObject();
            System.out.println(newUser);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(ois);
            try {
                FileUtils.forceDelete(file);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}

//OutPut:
//User{name='hollis', age=23}
//User{name='hollis', age=23}
```
### 2.2 Externalizable接口

```
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/**
 * Created by hollis on 16/2/17.
 * 实现Externalizable接口
 */
public class User1 implements Externalizable {

    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void writeExternal(ObjectOutput out) throws IOException {

    }

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

```
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.*;

/**
 * Created by hollis on 16/2/17.
 */
public class ExternalizableDemo1 {

    //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记
    //IOException直接抛出
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //Write Obj to file
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
        User1 user = new User1();
        user.setName("hollis");
        user.setAge(23);
        oos.writeObject(user);
        //Read Obj from file
        File file = new File("tempFile");
        ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));
        User1 newInstance = (User1) ois.readObject();
        //output
        System.out.println(newInstance);
    }
}
//OutPut:
//User{name='null', age=0}
```
- 通过上面的实例可以发现，对User1类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态没有被持久化下来。这就是Externalizable接口和Serializable接口的区别。
- Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。

将上面的代码修改如下：
```
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/**
 * Created by hollis on 16/2/17.
 * 实现Externalizable接口,并实现writeExternal和readExternal方法
 */
public class User2 implements Externalizable {

    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(name);
        out.writeInt(age);
    }

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = (String) in.readObject();
        age = in.readInt();
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

```
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.*;

/**
 * Created by hollis on 16/2/17.
 */
public class ExternalizableDemo2 {

    //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记
    //IOException直接抛出
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //Write Obj to file
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
        User2 user = new User2();
        user.setName("hollis");
        user.setAge(23);
        oos.writeObject(user);
        //Read Obj from file
        File file = new File("tempFile");
        ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));
        User2 newInstance = (User2) ois.readObject();
        //output
        System.out.println(newInstance);
    }
}
//OutPut:
//User{name='hollis', age=23}
```
> 如果User类中没有无参数的构造函数，在运行时会抛出异常：java.io.InvalidClassException

## 3 Serializable和Externalizable区别

1. Externalizable继承了Serializable， 该接⼜中定义了两个抽象⽅法：writeExternal()与readExternal()。 当使⽤Externalizable接口来进⾏序列化与反序列化的时候需要开发⼈员重写writeExternal()与readExternal()⽅法
2. 如果没有在这两个⽅法中定义序列化实现细节， 那么序列化之后， 对象内容为空。
3. 实现Externalizable接⼜的类必须要提供⼀个public的⽆参的构造器。
4. 实现Externalizable， 并实现writeExternal()和readExternal()⽅法可以指定序列化哪些属性。

## 4 serialVersionUID

序列化是将对象的状态信息转换为可存储或传输的形式的过程。
- 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个重要的点是两个类的序列化Id是否一致，即serialVersionUID要求一致。
- 在进⾏反序列化时， JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进⾏⽐较， 如果相同就认为是⼀致的， 可以进⾏反序列化， 否则就会出现序列化版本不⼀致的异常， 即是InvalidCastException。
- 这样做是为了保证安全，因为文件存储中的内容可能被篡改。
- 当实现java.io.Serializable接口的类没有显示地定义一个serialVersionUID变量时候，java序列化机制会根据编译的Class自动生成一个serialVersionUID做为序列化版本比较，在这种情况下，如果Class文件没有发生变化，就算再编译多次，serialVersionUID也不会发生变化。
- 但是如果发生了变化，那么这个文件对应的serialVersionUID也就会发生变化。
- 由此可以得出，如果我们一个类实现了Serializable接口，但是没有定义serialVersionUID，然后序列化，在序列化之后，由于某些原因我们对该类做了变更，重新启动应用后，我们相对之前序列化过的对象进行反序列画的画就会报错。

### 4.1 为什么serialVersionUID不能随便改

- 序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败，如果完全不兼容升级，便面反序列化混乱，那么请修改serialVersionUID值。
> 说明：注意serialVersionUID不一致会跑出序列化运行时异常。

-. 在进行序列化操作的时候，会判断要被序列化的类是否是Enum、Array和Serializable类型，如果都不是则直接抛出NotSerializableExption.

### 4.2 transient

transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int为0，对象是null.

### 4.3 自定义序列化策略

在序列化过程中，如果被序列化的类中定义了writeObject和readObject方法，虚拟机会试图调用对象类里面的方法，进行自定义序列化和反序列化。

如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。

- 所以，对于一些特殊字段需要定义序列化的策略的时候，可以考虑使用transient修饰，并自己重写writeObject 和 readObject 方法，如java.util.ArrayList中就有这样的实现。
- 我们随便找几个Java中实现了序列化接口的类，如String、Integer等，我们可以发现一个细节，那就是这些类除了实现了Serializable外，还定义了一个serialVersionUID

### 4.4 什么是serialVersionUID

虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，这个所谓的序列化ID，就是我们在代码中定义的serialVersionUID。

也就是说serialVersionUID是验证版本一致性的。

严格的规范：如果一个类实现了Serializable接口，就必须手动添加private static final long serialVersionUID变量，并且设置初始值。

如果一个类实现了Serializable接口，一定要记得定义serialVersionUID，否则会发生异常。可以在IDE中通过设置，让他帮忙提示，并且可以一键快速生成一个serialVersionUID。

## 5 transient

java语言关键字，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。这里的对象存储是指，Java的serialization提供的一种持久化对象实例的机制。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。使用情况是：当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。

简单点说，就是被修饰的成员变量，在序列化的时候值会被忽略，在被反序列化后，transient变量的值被设为初始值，如int是0，对象是null.

## 6 序列化底层原理


1. 除了在持久化对象时会用到对象序列化之外，当时用RMI（远程方法调用）或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制。
2. 在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。
3. 通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化
4. 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）
5. 对象序列化不会关注类中的静态变量
6. Tiansient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值。
7. 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串，在序列化的时候需要进行加密。

### 6.1 ArrayList的序列化
```
//数组是transient
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;
    transient Object[] elementData; // non-private to simplify nested class access
    private int size;
}
//尽管是transient，序列化仍能够成功
public static void main(String[] args) throws IOException, ClassNotFoundException {
        List<String> stringList = new ArrayList<String>();
        stringList.add("hello");
        stringList.add("world");
        stringList.add("hollis");
        stringList.add("chuang");
        System.out.println("init StringList" + stringList);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("stringlist"));
        objectOutputStream.writeObject(stringList);

        IOUtils.close(objectOutputStream);
        File file = new File("stringlist");
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));
        List<String> newStringList = (List<String>)objectInputStream.readObject();
        IOUtils.close(objectInputStream);
        if(file.exists()){
            file.delete();
        }
        System.out.println("new StringList" + newStringList);
    }
//init StringList[hello, world, hollis, chuang]
//new StringList[hello, world, hollis, chuang]

//上述的现象是通过readObject和writeObject实现的
private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size > 0) {
            // be like clone(), allocate array based upon size not capacity
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i<size; i++) {
                a[i] = s.readObject();
            }
        }
    }
    
private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
```
- ArrayList是动态数组，每次放满之后自动增长设定长度值，为了避免数组中大量null值，设置为transient（优化存储）。
- writeObjectMethod.invoke(obj, new Object[]{ out });是关键，通过反射的方式调用writeObjectMethod方法。官方是这么解释这个writeObjectMethod的：

### 6.2 调用的问题

1. 类中的writeObject和readObject方法调用：
- 在使用ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法时，会通过反射的方式调用。
2. Serializable明明就是一个空的接口，它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢？
- 在进行序列化操作时，会判断要被序列化的类是否是Enum、Array和Serializable类型，如果不是则直接抛出NotSerializableException。

## 7 序列化破坏单例模式

> 除了反射可以破坏单例，序列化也可以破坏

1. ObjectInputStream
- 对象的序列化通过ObjectOutputStream和ObjectInputStream来实现的，如下图：
![](http://note.youdao.com/yws/public/resource/cf631267d2ad6409b8796f1bae308c36/xmlnote/47751346A3AB4EEB8294A98FE3F5CB4B/8588)

2. 分析readOrdinaryObject方法的代码片段
```
private Object readOrdinaryObject(boolean unshared)
        throws IOException
    {
        //此处省略部分代码

        Object obj;
        try {
            obj = desc.isInstantiable() ? desc.newInstance() : null;
        } catch (Exception ex) {
            throw (IOException) new InvalidClassException(
                desc.forClass().getName(),
                "unable to create instance").initCause(ex);
        }

        //此处省略部分代码

        if (obj != null &&
            handles.lookupException(passHandle) == null &&
            desc.hasReadResolveMethod())
        {
            Object rep = desc.invokeReadResolve(obj);
            if (unshared && rep.getClass().isArray()) {
                rep = cloneArray(rep);
            }
            if (rep != obj) {
                handles.setObject(passHandle, obj = rep);
            }
        }

        return obj;
    }
```
对上述代码进行分析：
```
//上段的核心
Object obj;
try {
    obj = desc.isInstantiable() ? desc.newInstance() : null;
} catch (Exception ex) {
    throw (IOException) new InvalidClassException(desc.forClass().getName(),"unable to create instance").initCause(ex);
}
```
![](http://note.youdao.com/yws/public/resource/cf631267d2ad6409b8796f1bae308c36/xmlnote/2B1718FB474F4806AE7AA4EC846949BD/8591)

> isInstantiable：如果一个serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。针对serializable和externalizable我会在其他文章中介绍。

> 该方法通过反射的方式调用无参构造方法新建一个对象。

通过上述分析可以得出，序列化之所以会破坏单例是因为用过反射调用无参数的构造方法创建一个新的对象。

### 7.1 防止序列化破坏单例模式

只要在Singleton类中定义readResolve就可以解决

回顾上述代码中的第二段核心
```
if (obj != null &&
            handles.lookupException(passHandle) == null &&
            desc.hasReadResolveMethod())
        {
            Object rep = desc.invokeReadResolve(obj);
            if (unshared && rep.getClass().isArray()) {
                rep = cloneArray(rep);
            }
            if (rep != obj) {
                handles.setObject(passHandle, obj = rep);
            }
        }
```
- hasReadResolveMethod:如果实现了serializable 或者 externalizable接口的类中包含readResolve则返回true
- invokeReadResolve:通过反射的方式调用要被反序列化的类的readResolve方法。

> 注意，序列化名字前尽量不加is

## 8 protobuf

Protocol Buffer是Google出品的序列化库

Todo: 研究一下漏洞
> [Apache-Commons-Collections的反序列化漏洞](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/bug-in-apache-commons-collections)

> [fastjson的反序列化漏洞](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/bug-in-fastjson)