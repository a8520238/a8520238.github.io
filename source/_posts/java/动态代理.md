---
title: 动态代理
date: 2021-2-28
cover:
top_img:
categories: javaSE
tags: 
mathjax: true
katex: true
---
# 动态代理

## 1 JDK动态代理
java.lang.reflect包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。

## 2 Cglib动态代理
Cglib(Code Generation Library)是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。

## 3 JDK动态代理和Cglib动态代理的区别

使用JDK动态代理对象必须实现一个或多个接口。如果代理没有实现接口的类，就可以使用CGLIB实现。

Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。

使用动态代理的对象必须实现一个或多个接口。
使用cglib代理的对象则无需实现接口，达到代理类无侵入。

## 4 Java实现动态代理的大致步骤

1. 定义一个委托类和公共接口。
2. 自己定义一个类（调用处理器，即实现InvocationHandler接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器。
3. 生成代理对象，需要为它指定
- 委托对象
- 实现的一系列接口
- 调用处理器类的实例
-由此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。

### 4.1 Java实现动态代理主要涉及哪几个类

java.lang.reflect.Proxy:这是生成代理类的主类，通过Proxy类生成的代理类都继承了Proxy类。

java.lang.reflect.InvocationHandler:这里称之为调用处理器，是一个接口，动态生成的代理类需要完成的具体内容需要自己定义一个类，这个类必须实现InvocationHandler接口。

### 4.2 动态代理的实现

```
//委托对象
public class UserServiceImpl implements UserService {

    @Override
    public void add() {
        // TODO Auto-generated method stub
        System.out.println("--------------------add----------------------");
    }
}
```

1. jdk动态代理
```
//调用处理器实例
public class MyInvocationHandler implements InvocationHandler {

    private Object target;

    public MyInvocationHandler(Object target) {

        super();
        this.target = target;

    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        PerformanceMonior.begin(target.getClass().getName()+"."+method.getName());
        //System.out.println("-----------------begin "+method.getName()+"-----------------");
        Object result = method.invoke(target, args);
        //System.out.println("-----------------end "+method.getName()+"-----------------");
        PerformanceMonior.end();
        return result;
    }

    public Object getProxy(){

        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), this);
    }

}

public static void main(String[] args) {

  UserService service = new UserServiceImpl();
  MyInvocationHandler handler = new MyInvocationHandler(service);
  UserService proxy = (UserService) handler.getProxy();
  proxy.add();
}
```
2. cglib动态代理
```
public class CglibProxy implements MethodInterceptor{  
 private Enhancer enhancer = new Enhancer();  
 public Object getProxy(Class clazz){  
  //设置需要创建子类的类  
  enhancer.setSuperclass(clazz);  
  enhancer.setCallback(this);  
  //通过字节码技术动态创建子类实例  
  return enhancer.create();  
 }  
 //实现MethodInterceptor接口方法  
 public Object intercept(Object obj, Method method, Object[] args,  
   MethodProxy proxy) throws Throwable {  
  System.out.println("前置代理");  
  //通过代理类调用父类中的方法  
  Object result = proxy.invokeSuper(obj, args);  
  System.out.println("后置代理");  
  return result;  
 }  
}  

public class DoCGLib {  
 public static void main(String[] args) {  
  CglibProxy proxy = new CglibProxy();  
  //通过生成子类的方式创建代理类  
  UserServiceImpl proxyImp = (UserServiceImpl)proxy.getProxy(UserServiceImpl.class);  
  proxyImp.add();  
 }  
}
```