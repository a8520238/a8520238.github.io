---
title: 反射
date: 2021-2-28
cover:
top_img:
categories: javaSE
tags: 
mathjax: true
katex: true
---
# 反射

> 反射可以调用私有方法

> 反射让java变成了准动态语言，运行时创建类
## 1 Java的反射机制

反射（Reflection）,能在执行期间得到类的内部信息，通过实例对象得到类的信息（包括注解）。

反射对性能有一些影响。

- java.lang.Class:代表一个类
- java.lang.reflect.Method:代表类的方法
- java.lang.reflect.Field:代表类的成员变量
- java.lang.reflect.Constructor:代表类的构造器

### 1.1 使用

Class<?> c1 = Class.forName("com.test.User");
- 一个类在内存中只有一个Class对象
- 一个类被加载后，类的整个结构都会被封装在Class对象中

对象可以反射类名，Object类中有getClass()方法。

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/CFCF5DA53ACA483A9543B20DAB37D790/5764)

### 1.2 获取Class类的实例

1. 若是已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能高。
```
Class clazz = Person.class;
```
2. 已知某个类的实例，调用该实例的getClass()方法获取Class对象。
```
Class clazz = person.getClass();
```
3. 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
```
Class clazz = Class.forName("com.User");
```
4. 内置的基本数据类型可以直接用类名
```
Integer.TYPE
```
5. 还可以利用ClassLoader
![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/D45947069DBC4D66B57CD46D1C589526/5799)

### 1.3 什么时候发生类的初始化

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/0A01BA6042124D6689A883D107ECA48A/5805)

### 1.4 获取系统类的加载器

- //获取系统类(应用类)加载器 (自定义类类)
```ClassLoader systemClassLoader = ClassLoader.getSystenClassLoader();```
- //获取系统类加载器的父类加载器-->扩展类加载器(Jre/lib/ext/*.jar)
```ClassLoader parent = systemClassLoader.getParent();```
- //获取扩展类加载器的父类-->跟加载器 （JDK类）Jre/lib/rt.jar
```ClassLoader parent1 = parent.getParent();```

1. 获得系统类加载器可以加载的路径
```System.out.println(System.getProperty("java.class.path"))```

## 2 获取类的运行时结构

通过反射能获取运行时类的完整结构
Field、Method、Constructor、Superclass、Interface、Annotation

getDeclared方法有private的 构造器时当前的

通过反射获取对象
```
Class c1 = Class.forname("com.User");
User user = (User) c1.newInstance();
```
通过构造器创建对象
```
Constructor constructor = c1.getDeclaredConstructor(String.class, int.class)
User user2 = (User)constructor.newInstance("test", 11);
```
通过反射获取方法
```
Method setName = c1.getDeclaredMethod("setName", String.class);
```
调用反射的方法
```
setName.invoke(user, "test"); 
//invoke中的参数 第一个是对象，第二个是方法的值
```

通过反射操作字段
```
Field name = c1.getDeclaredField("name");
name.setAccessible(true) //关闭权限检测
name.set(user, "test");
```

> 性能普通方法  快于  关闭检测（setAccessible）的反射  快于  反射

## 3 泛型相关

判断参数泛型和返回值泛型是否是一种参数化泛型（ParameterizedType）,从而强转，调用方法，得到真实类型
![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/58B6F919876D4E82AC7B49C2011FA35D/5926)

获取运行时泛型参数信息(genericParameterTypes)(method.getGenericParameterTypes)

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/62D51B0A46154D3BA682D3C030B38ACE/5900)

获取返回时泛型参数信息(genericReturnType)(method.getGenericReturnType())

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/3A89AD64E44D4AC2991E3A53AFC7FC4A/5914)

## 4 反射操作注解

orm 对象关系模型，利用注解和反射完成对类和表结构的对应关系。

通过反射方法，可以获得注解内的配置信息，个人感觉是理解的关键。

1. 定义注解

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/287D56CA586D41C7A5B75B5EDDA55F8C/5941)

2. 配置注解

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/01FB78EDA9DA472699529A15BB2C2A83/5943)

3. 反射获得注解的值

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/E3B18F5DA87F4091B3FFC39B10AFA9AE/5945)

4. 获得注解的示例

![](http://note.youdao.com/yws/public/resource/5cf00375bd027272dff28d8755142c56/xmlnote/A0D9B96B91F548ECB280143FD2D4F4B0/5947)