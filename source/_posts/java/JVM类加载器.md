---
title: JVM 类加载器
date: 2021-2-28
cover:
top_img:
categories: JVM
tags: 
mathjax: true
katex: true
---
# Java类加载机制总结

# 1 Class文件

Class 文件中只有两种数据类型： 无符号数、表。
- 无符号数：u1、u2、u4、u8 分别表示 1字节、2字节、4字节、8字节的无符号数。
- 表：由 0 个或多个大小可变的项组成，一个类就相当于一个表。

>  Class 文件中没有任何对齐和填充的说法，所有数据都按照特定的顺序紧凑的排列在 Class 文件中。

> 不像堆中的对象内存一样，会填充为 8 字节的整数倍。


## 1.1 class 文件的结构

```
ClassFile {
    u4             magic;//魔数
    u2             minor_version;//次版本号
    u2             major_version;//主版本号
    u2             constant_pool_count;//常量池数量
    cp_info        constant_pool[constant_pool_count-1];//常量池信息
    u2             access_flags;//访问标志
    u2             this_class;//类索引
    u2             super_class;//父类索引
    u2             interfaces_count;//接口数(2位，所以一个类最多65535个接口)
    u2             interfaces[interfaces_count];//接口索引 
    u2             fields_count;//字段数
    field_info     fields[fields_count];//字段表集合 
    u2             methods_count;//方法数
    method_info    methods[methods_count];//方法集合
    u2             attributes_count;//属性数
    attribute_info attributes[attributes_count];//属性表集合
}

```

# 2 类加载的机制

Java中的类加载、连接和初始化都是在运行时完成的，Java的动态扩展的特性就依赖于运行时的动态加载和动态连接。如果某一类在生成对象时没有发现类加载器，会根据类名查找编译好的class文件，进行类加载。

图中前五部分被称为类加载。包括：加载、验证、准备、解析、初始化。

![类加载过程](http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/742ED79DCD2E4E3FBA8C6709C6F13281/2884)

## 2.1 类加载的前提：编译

在 JVM 运行之前，java 代码被编译器 javac 编译成 .class 字节码文件。一些类加载时需要用到的编译期知识：

- 编译期间的常量：
    + 编译期间，知道确定值的常量会直接被加入到常量池中，不会经历类加载过程。
    + 不知道确定值的常量，则会在运行时对该常量所在的类进行初始化。
    + 如果该static final类型是 基本类型 或者 字符串，则会被编译器标记成ConstantValue，后面运行时类加载中的 “准备” 阶段会对其进行直接初始化。
- 编译时，编译器会按照代码顺序自动收集类中所有的 静态变量的赋值动作 和 静态语句块 中的语句，合并产生<clinit>()方法。如果没有符合要求的语句，则不生成。
    + （接口因为也有static，所以也会生成<clinit>()方法）


## 2.2 加载Loading

加载过程主要做三件事：

1 通过一个类的全限定名来获取定义此类的二进制字节流。
- 二进制字节流的来源：.class 文件、jar 包等压缩包、网络中获取、动态代理动态生成 .class 文件等

2 将这个字节流所代表的**静态存储结构**转化为方法区的运行时数据结构。

3 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中该类的各种数据的访问入口。

> Class类是特殊的对象，不一定分配在堆中，Hot Spot 虚拟机分配在方法区中。

### 2.2.1类加载器

引用类型包括类、接口、数组类、泛型参数。

- 泛型参数会在编译期间进行泛型擦除，不涉及运行时。
- 数组类没有字节流，不通过类加载器进行加载，而是虚拟机直接创建。但是若数组的组件类型是引用类型，则递归地去用类加载器加载其组件类型。
- 类和接口通过类加载器去获取字节流。
 
![类加载器](http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/8E67E195CF8A4E0FA5FB787D307A4A2F/2886)

除了“启动类加载器”，其他类加载器都是java.lang.ClassLoader的子类。

- 启动类加载器：C++实现，没有对应的Java对象。用于加载最基础、最重要的类，如JRE的 /lib 目录下的 jar 包中的类。
- 扩展类加载器：负责加载次要但通用的类，如JRE的 /lib/ext 目录下 jar 包中的类。
- 应用类加载器：负责加载应用程序路径下的类。

### 2.2.2 双亲委派机制

> 当一个类加载器收到类加载任务，它自己首先不会自己主动去加载这个类，而是先交给其父类加载器去尝试加载，直到传递到顶层的启动类加载器。只有当父类加载器无法完成加载任务时，才会尝试子类加载器执行加载任务。

> 双亲委派机制保证了：对同一个类，不管是哪个加载器加载这个类，最终都是委托给可能的最顶层的类加载器进行加载，来保证使用不同的类加载器都会得到相同的 Object 对象。

![双亲委派机制](http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/DE9926B13DD34504BADB21AE24F5D96C/2879)

- 启动类加载器 BootstrapClassLoader：负责加载 $JAVA_HOME\lib 下的类或者被参数 -Xbootclasspath 指定的能被虚拟机识别的类通过jar名字识别，如：rt.jar，启动类加载器由 Java 虚拟机直接控制，开发者不能直接使用启动类加载器。
    + 启动类加载器没有子类，但是在逻辑上当扩展类加载器会将收到的类加载请求传递给启动类加载器来进行优先加载。

- 扩展类加载器 ExtensionClassLoader：负责加载 $JAVA_HOME\lib\ext 下的类，或者被 java.ext.dirs 系统变量指定路径中的所有类库( System.getProperty(“java.ext.dirs”) )，开发者可以直接使用这个类加载器。

- 应用程序类加载器 ApplicationClassLoader，负责加载 $CLASS_PATH 中指定的类库。开发者能直接使用这个类加载器。
    + 正常情况下如果没有自定义类加载器，一般用的就是这个类加载器。
- 自定义类加载器：可以通过继承 java.lang.ClassLoader 来自定义类加载器,一般我们都选择继承 URLClassLoader 来进行适当的改写就可以了。

> 可以通过继承 java.lang.ClassLoader ，并重写其中的 loadClass() 方法来破坏双亲委派机制。

## 2.3 连接Linking

### 2.3.1 验证Verification

确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。

1. 文件格式验证：比如说是不是以魔数开头，jdk 版本号的正确性等等。
2. 元数据验证：比如说类中的字段是否合法，是否有父类，父类是否合法等等。
3. 字节码验证：确定程序语义是合法的、符合逻辑的。
4. 符号引用验证：类对自身以外（常量池中的各种符号引用）的信息进行匹配性校验，目的是确保解析动作能正常执行。

### 2.3.2 准备 Preparation

为类或接口的静态字段 static（类变量、静态常量）分配内存（在方法区中），并初始化为默认值。

- 若不是 static final，该初始值指的是类型对应的默认初始值（如下表），并非开发者对变量赋值的初值。
- 若为 static final，即为静态常量，则直接初始化为赋予的初始值。
    + 常量在编译期会被添加常量标志 ConstantValue，JVM 以此来判断是不是常量。

![默认初始值](http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/55297C9F825142EBA3E6F291411092E4/2888)
### 2.3.3 解析Resolution

解析是虚拟机把常量池内的符号引用替换为直接引用的过程。直接引用是直接指向目标的指针等，前提是引用的目标已经在内存中了（这也意味着解析阶段必须在准备阶段之后，因为准备阶段才正式开始分配内存）。

- 符号引用：符号可以是任意形式的字面量，该符号可以唯一定位到引用的目标。
- 直接引用：直接指向目标的指针、相对偏移量、或是一个能间接定位到目标的句柄。

> 因为 Java 支持动态绑定，所以有些引用要等到具体使用的时候才会知道指向，所以解析可以在初始化之后进行。

#### 2.3.3.1类或接口的解析

若一个类或接口的符号引用未被解析，

1. 如果不是数组类型，则通过全限定名给类加载器去加载该类。
2. 如果是数组类型，且元素类型是对象，则按 1 规则加载其元素类型的类。
3. 解析完成前进行符号引用验证，确认是否有对其的引用访问权限。
4. 继承相关的解析
- 对于不含静态方法的非抽象类而言，如果你只是创建了一个类的空引用，并没有执行new操作，该类是不会被加载的。也就是说，一个不含静态方法的非抽象类要被加载的话，肯定是在第一次实例化对象时，才会发生类的加载，同时生成实例化对象。但是之后再实例化对象，类的加载过程不会再发生，类的加载过程只发生一次。
- 对于含静态方法的非抽象类而言，第一次执行new操作进行实例化或者调用类方法（即该类的静态方法）时，该类才会被加载的。
- 对于不含静态方法的抽象类而言，只有继承了该类的非抽象子类要被加载时，该不含静态方法的抽象类才会被加载。且抽象父类先加载，非抽象子类后加载。
- 对于含静态方法的抽象类而言，继承了该类的非抽象子类要被加载时或者调用该含静态方法的抽象类的类方法（即该类的静态方法）时，该含静态方法的抽象类才会被加载。
- 接口和不含静态方法的抽象类情况类似，都是只有继承了该接口的非抽象子类要被加载时，该接口才会被加载。应该是父接口先加载，非抽象子类后加载。
- 子接口初始化的时候并不要求其父接口也完成初始化，只有在真正使用到父接口的时候它才会被初始化（比如引用接口上的常量的时候啦）。换句话说，如果子接口实现了多个父接口，只有实现子类调用某一特定父接口的方法时，才会加载该父接口。
#### 2.3.3.2字段的解析

#### 2.3.3.3 类方法的解析

#### 2.3.3.4 接口方法的解析

## 2.4 初始化 Initialization

初始化阶段是真正开始执行字节码进行赋值操作，会把准备阶段的默认值替换为真正的初始值。初始化过程会执行静态代码块方法。

初始化过程就是<clinit>()执行的过程。初始化完成后，类即成为可执行状态。

- 在一个类的<clinit>()方法执行前，其父类的<clinit>()方法已经执行完毕。因此第一个执行该方法的类肯定是java.lang.Object。
- 如果一个实现类或子接口实现了某父接口，则不需要先执行父接口的<clinit>()方法。当父接口中的某些属性被使用到的时候才会触发父接口的初始化。
- JVM 会通过加锁来保证类的<clinit>()方法只被执行一次。

### 2.4.1 初始化何时被触发

JVM 规定了 5 种情况必须进行立即初始化，也被称为主动引用。
1. 当虚拟机启动时，主类（main 方法所在的类）被初始化。
2. new 实例化一个类对象时；或者调用或设置某类的静态方法或静态字段（除final）时，初始化所在的类。
3. 当初始化子类时，如果父类还没初始化，则先触发父类的初始化。若类实现了某定义了default方法的接口，则该类的初始化会触发该接口的初始化。
4. 使用反射 API 对某个类进行反射调用时。
5. JDK 1.7 开始提供的动态语言支持，如果一个 java.lang.invoke.MethodHandle 实例解析的结果REF_getStatic，REF_putStatic，REF_invokeStatic 的方法句柄对应的类没有被初始化，需要触发其初始化。

#### 2.4.1.1 对于父接口

当接口被初始化时，不要求其父接口全部初始化，只有真正使用到父接口时才会触发父接口的初始化。如使用到了父接口中定义的常量等。

#### 2.4.1.2 对于数组

构造数组对象和直接构造对象是用过不同的字节码来实现的，创建数组对象是通过 newarray 指令来实现，所以并不会初始化 Object 对象。

### 2.4.2 被动引用不会触发初始化

1. 通过数组定义类 A 的引用，不会触发该类 A 的初始化 A[] = new A[10];
2. 通过子类访问父类的静态域时，只有父类会被初始化（即真正声明这个域的类）。
3. 引用常量不会导致类的初始化，因为常量在编译期就被加入了常量池。

#  Reference

[虚拟机类加载机制 深入理解Java虚拟机总结](https://www.jianshu.com/p/20f902788988)

[深入理解Java类加载机制](https://www.jianshu.com/p/8cab58ac37e3)

[java类到底是如何加载并初始化的？](https://www.cnblogs.com/jimxz/p/3974939.html)

[类加载之  和 ](https://www.jianshu.com/p/7ff65c3040ec)

[深入理解JVM内存分配和常量池](https://www.cnblogs.com/zzuli/p/9403928.html)

# Todo

spi 服务扩展机制

打破双亲委派的类加载器