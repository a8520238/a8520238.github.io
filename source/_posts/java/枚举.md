---
title: 枚举
date: 2021-2-28
cover:
top_img:
categories: javaSE
tags: 
mathjax: true
katex: true
---
# 枚举

## 1 定义

枚举类型（enum type）是由一组固定的常量组成的合法的类型。Java中有关键字enum来定义一个枚举类型。下面是枚举类型的定义。
```
public enum Sesson {
    SPRING, SUMMER, AUTUMN, WINTER;
}
```

## 2 特点
- 使用关键字enum
- 类型名称 比如上述的Season
- 一串允许的值
- 枚举可以单独定义在一个文件，也可以嵌在其他Java类中。
- 枚举可以实现一个或多个接口
- 可以定义新的变量
- 可以定义新的方法
- 可以定义根据具体枚举值而相异的类

```
public enum Season {
    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);

    private int code;
    private Season(int code){
        this.code = code;
    }

    public int getCode(){
        return code;
    }
}
public class UseSeason {
    /**
     * 将英文的季节转换成中文季节
     * @param season
     * @return
     */
    public String getChineseSeason(Season season){
        StringBuffer result = new StringBuffer();
        switch(season){
            case SPRING :
                result.append("[中文：春天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                break;
            case AUTUMN :
                result.append("[中文：秋天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                break;
            case SUMMER : 
                result.append("[中文：夏天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                break;
            case WINTER :
                result.append("[中文：冬天，枚举常量:" + season.name() + "，数据:" + season.getCode() + "]");
                break;
            default :
                result.append("地球没有的季节 " + season.name());
                break;
        }
        return result.toString();
    }

    public void doSomething(){
        for(Season s : Season.values()){
            System.out.println(getChineseSeason(s));//这是正常的场景
        }
        //System.out.println(getChineseSeason(5));
        //此处已经是编译不通过了，这就保证了类型安全
    }

    public static void main(String[] arg){
        UseSeason useSeason = new UseSeason();
        useSeason.doSomething();
    }
}
```

## 3 理解

从反编译的代码可以看出，枚举类继承了Enum类，成员变量包括一个String类型，一个int类型，都保存在一个T[]数组中，所以方法超过数组边界是不会通过编译的。所有成员变量，包括枚举类都是final的。

## 4 枚举与单例

1. 双重校验锁实现单例
```
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}  
```
2. 枚举实现单例
```
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}  
```

- 枚举类如何保证线程安全
    + 反编译后的枚举值是static和final的，并在静态代码块中赋值，静态代码块赋值会调用ClassLoader中的loadClass方法，这个方法用同步代码块保证了线程安全。
- 枚举类单例的本质
    + 当枚举类中只有一个枚举值时，它本质上是枚举类（如下方代码）内部的一个内部类，又因为他是static final的，所以只会被创建一个。无论直接调用枚举类方法还是枚举类实例方法，都不会创建多个。
```
class Type extends Enum{
    public static final Type A;
    public static final Type B;
    ...
}
```
- 枚举可以解决反序列化会破坏单例的问题
    + 在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。
    + 普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以这就破坏了单例。
    + 枚举的反序列化并不是通过反射实现的。所以，也就不会发生由于反序列化导致的单例破坏问题。如下代码：
```
public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name) {  
            T result = enumType.enumConstantDirectory().get(name);  
            if (result != null)  
                return result;  
            if (name == null)  
                throw new NullPointerException("Name is null");  
            throw new IllegalArgumentException(  
                "No enum const " + enumType +"." + name);  
        }  
```
- 在所有的单例实现方式中，枚举是一种在代码写法上最简单的方式，之所以代码十分简洁，是因为Java给我们提供了enum关键字，我们便可以很方便的声明一个枚举类型，而不需要关心其初始化过程中的线程安全问题，因为枚举类在被虚拟机加载的时候会保证线程安全的被初始化。除此之外，在序列化方面，Java中有明确规定，枚举的序列化和反序列化是有特殊定制的。这就可以避免反序列化过程中由于反射而导致的单例被破坏问题。

## 5 java枚举如何比较

1. java 枚举值比较用 == 和 equals 方法没啥区别，两个随便用都是一样的效果。
2. 因为枚举 Enum 类的 equals 方法默认实现就是通过 == 来比较的；
3. 类似的 Enum 的 compareTo 方法比较的是 Enum 的 ordinal 顺序大小；
4. 类似的还有 Enum 的 name 方法和 toString 方法一样都返回的是 Enum 的 name 值。、

## 6 switch对枚举的支持

编译器会将枚举switch转换为类似
```
switch(s.ordinal()) { 
    case Status.START.ordinal() 
}
```
其实比较的是int

## 7 深入理解枚举序列化

上述代码反编译后 如下
```
public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }

    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }

    public static final T SPRING;
    public static final T SUMMER;
    public static final T AUTUMN;
    public static final T WINTER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        AUTUMN = new T("AUTUMN", 2);
        WINTER = new T("WINTER", 3);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER, AUTUMN, WINTER
        });
    }
}
```