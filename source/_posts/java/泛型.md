---
title: 泛型
date: 2021-2-28
cover:
top_img:
categories: javaSE
tags: 
mathjax: true
katex: true
---
# 泛型

## 1 各种语言如何处理泛型

通常情况下，一个编译器处理泛型有两种方式：
1. code specialization. 在实例化一个泛型类或泛型泛型方法时都产生一份新的目标代码（字节码或者二进制代码）。例如，针对一个泛型list,可能需要针对string,integer,float产生三份目标代码。
2. code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。

- C++ 中的类模板时候code specialization实现。C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中integer list和string list是两种不同的类型。这样会导致代码膨胀
- java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原生类型（Raw Type 裸类型），并且在相应的地方插入了强制转型的代码，因此对于运行期的java语言来说，Arraylist<int>与ArrayList<String>就是同一个类。所以说泛型技术实际上是java语言的一颗语法糖，java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型。

## 2 什么是类型擦除

类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。类型擦除可以简单地理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型代码直接转换为普通java字节码。类型擦除的主要过程如下：
1. 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。
2. 移除所有的类型参数

举例
```
//例1
interface Comparable<A> {
    public int compareTo(A that);
}

public final class NumericValue implements Comparable<NumericValue> {
    private byte value;

    public NumericValue(byte value) {
        this.value = value;
    }

    public byte getValue() {
        return value;
    }

    public int compareTo(NumericValue that) {
        return this.value - that.value;
    }
}
//反编译后如下：
interface Comparable {
  public int compareTo( Object that);
} 

public final class NumericValue
    implements Comparable
{
    public NumericValue(byte value)
    {
        this.value = value;
    }
    public byte getValue()
    {
        return value;
    }
    public int compareTo(NumericValue that)
    {
        return value - that.value;
    }
    public volatile int compareTo(Object obj)
    {
        return compareTo((NumericValue)obj);
    }
    private byte value;
}
// 例2
public class Collections {
    public static <A extends Comparable<A>> A max(Collection<A> xs) {
        Iterator<A> xi = xs.iterator();
        A w = xi.next();
        while (xi.hasNext()) {
            A x = xi.next();
            if (w.compareTo(x) < 0)
                w = x;
        }
        return w;
    }
}

public class Collections
{
    public Collections()
    {
    }
    public static Comparable max(Collection xs)
    {
        Iterator xi = xs.iterator();
        Comparable w = (Comparable)xi.next();
        while(xi.hasNext())
        {
            Comparable x = (Comparable)xi.next();
            if(w.compareTo(x) < 0)
                w = x;
        }
        return w;
    }
}
```
解释：第一个泛型类```Comparable<A>```擦除后A被替换为最左边界Object。```Comparable<NumericValue>```的类型参数NumericValue被擦除掉，但是这直接导致NumericValue没有实现接口Comparable的compareTo(Object that)方法，于是编译器充当好人，添加了一个桥接方法。第二个示例中限定了类型参数的边界```<A extends Comparable<A>> A```,然后去掉参数类型A，得到最终的擦除后结果。

## 3 泛型遇到的问题

### 3.1 当泛型遇到重载

```
public class GenericTypes {  

    public static void method(List<String> list) {  
        System.out.println("invoke method(List<String> list)");  
    }  

    public static void method(List<Integer> list) {  
        System.out.println("invoke method(List<Integer> list)");  
    }  
}  
```

上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是```List<Integer> 和List<String>```编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变的一模一样。

### 3.2 当泛型遇到catch

如果我们自定义了一个泛型异常类GenericException，那么，不要尝试用多个catch取匹配不同的异常类型，例如你想要分别捕获GenericException、GenericException，这也是有问题的。

### 3.3 当泛型内包含静态变量
```
public class StaticTest{
    public static void main(String[] args){
        GT<Integer> gti = new GT<Integer>();
        gti.var=1;
        GT<String> gts = new GT<String>();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT<T>{
    public static int var=0;
    public void nothing(T x){}
}
```
答案是2 ， 由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。

## 4 总结

1. 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类没有自己独有的class类对象。比如并不存在```List<String>.class或是List<Integer>.class```，而只有List.class。
2. 创建泛型对象时请指明类型，让编译器尽早的做参数检查（不要在新代码中使用原生态类型）
3. 不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你
4. 静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<T>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<String>还是new MyClass<Integer>创建的对象，都是共享一个静态变量。
5. 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。
6. 

## 5 泛型中的K T V E
- E - Element(在集合中使用，因为集合中存放的是元素)
- T - Type（Java类）
- K - key （键）
- V - Value (值)
- N - Number（数值类型）
- ？ - 表示不确定的java类型（无限制通配符类型）
> Object - 是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。

### 5.1 限定通配符

限定通配符对类型进⾏限制， 泛型中有两种限定通配符：

- 表示类型的上界，格式为：<？ extends T>，即类型必须为T类型或者T子类
    + List<? extends GrandFaClass> 表示 “具有任何从GrandFaClass继承类型的列表”，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象。可以添加null,因为null 可以表示任何类型。所以List 的add 方法不能添加任何有意义的元素，但是可以接受现有的子类型List 赋值。

表示类型的下界，格式为：<？ super T>，即类型必须为T类型或者T的父类

泛型类型必须⽤限定内的类型来进⾏初始化，否则会导致编译错误。

```
public class Food {}
public class Fruit extends Food {}
public class Apple extends Fruit {}
public class Banana extends Fruit{}

public class GenericTest {

    public void testExtends(List<? extends Fruit> list){

        //报错,extends为上界通配符,只能取值,不能放.
        //因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错
        //list.add(new Apple());

        //可以正常获取
        Fruit fruit = list.get(1);
    }

    public void testSuper(List<? super Fruit> list){

        //super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲，
        //无法确定Fruit的父类是否只有Food一个(Object是超级父类)
        //因此放入Food的实例编译不通过
        list.add(new Apple());
//        list.add(new Food());

        Object object = list.get(1);
    }
}
```
在testExtends方法中，因为泛型中用的是extends，在向list中存放元素的时候，我们并不能确定List中的元素的具体类型，即可能是Apple也可能是Banana。因此调用add方法时，不论传入new Apple()还是new Banana()，都会出现编译错误。

理解了extends之后，再看super就很容易理解了，即我们不能确定testSuper方法的参数中的泛型是Fruit的哪个父类，因此在调用get方法时只能返回Object类型。结合extends可见，在获取泛型元素时，使用extends获取到的是泛型中的上边界的类型(本例子中为Fruit),范围更小。

在使用泛型时，存取元素时用super,获取元素时，用extends。

频繁往外读取内容的，适合用上界Extends。经常往里插入的，适合用下界Super。

**List集合上下通配符和普通对象上下通配符差异的根本原因在于，List集合不能呢个安全保证，比如上界中不能存子类对象，不是因为上界不能存，而是因为如果存了子类对象，那势必会出现存了多种子类对象的现象，不同子类对象未必有相同的方法，从而会出现报错。**


- 使用场景
    + 一个方法声明a(List<? extends A>)
    + 调用时先创建`List<B> list = new ArrayList<>();//B是A的子类 `
    + 再调用方法`a(list)`

## 6 List、List<?>和原始类型List之间的区别

- 原始类型List和带参数类型List<Object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查
- 通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。
- 它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>对象传递给接受 List<Object>的方法，因为会产生编译错误。(类似上界通配符)
- List<?> 是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。

## 7 泛型数组 
正确如下
```
Pair<String, String>[] pairs = (Pair<String, String>[]) new Pair[10];
```

错误：
```
Pair<String, String>[] pairs = new Pair<String, String>[10];  //类型擦除后不安全
```

## 8 数组的上下转型
数组可以向上转型，向上转型后的数组可以向下转型回来

数组不能直接向下转型 如Object[]不能直接转为String[]，即使Object[]中存的都是String