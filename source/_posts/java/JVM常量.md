---
title: JVM 常量
date: 2021-2-28
cover:
top_img:
categories: JVM
tags: 
mathjax: true
katex: true
---
> 常量：即final修饰的成员变量（实例变量）和静态变量（静态变量也只能是用static修饰的成员变量），那么用final修饰的局部变量（方法内）我们也可以称之为不可变变量。（存储在栈中）

# 1 class文件常量池

常量池主要用来存放两大类常量：字面量和符号引用量，字面量相当于Java语言的常量，如文本字符串，声明为final的常量等，符号引用包括以下三种

类和接口的全限定名

字段名称和描述符

方法名称和描述符

# 2 方法区中的运行常量池

- 运行时常量池主要保存字面量和符号引用
- class文件中的常量池中的内容会在类加载后进入方法区的运行时常量池。相对于常量池，运行时常量池的重要特征是具有动态性，java并不要求常量只有在编译器才会产生，运行期间也可以将新的常量存放入池中，这种特性用的最多的String类中的intern()方法。
- 字面量：固定值，举例
```
int a = 123;
String s = "hollis";
```
- 上面的代码事例中，123和hollis都是字面量。
- 符号引用：
    + 类和接口的全限定名
    + 字段的名称和描述符 
    + 方法的名称和描述符

# 3 解析与常量池

方法区还包括一个常量池，用来存储编译期间生成的字面量和符号引用。这部分内容在类被加载后，都会存储到方法区中的RCP。值得注意的是，运行时产生的新常量也可以被放入常量池中，比如 String 类中的 intern() 方法产生的常量。

# 4 字符串常量池

![](http://note.youdao.com/yws/public/resource/7839ea220156efcfc3c18b40b088fedd/xmlnote/138C510A3032446EB507656AB3BD87CC/6644)

# 5 运行时常量池的位置

- 在JDK 1.7之前，方法区位于堆内存的永久代中，运行时常量池作为方法区的一部分，也处于永久代中。

- 因为使用永久代实现方法区可能导致内存泄露问题，所以，从JDK1.7开始，JVM尝试解决这一问题，在1.7中，将原本位于永久代中的运行时常量池移动到堆内存中。（永久代在JDK 1.7并没有完全移除，只是原来方法区中的运行时常量池、类的静态变量等移动到了堆内存中。）

- 在JDK 1.8中，彻底移除了永久代，方法区通过元空间的方式实现。随之，运行时常量池也在元空间中实现。

# 6 运行时常量池、Class常量池、字符串常量池的区别与联系

- 虚拟机启动过程中，会将各个Class文件中的常量池载入到运行时常量池中。
- 所以， Class常量池只是一个媒介场所。在JVM真的运行时，需要把常量池中的常量加载到内存中，进入到运行时常量池。
- 字符串常量池可以理解为运行时常量池分出来的部分。加载时，对于class的静态常量池，如果字符串会被装到字符串常量池中。